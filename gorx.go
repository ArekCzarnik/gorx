package gorx

// NOTE: This file was generated by github.com/alecthomas/cmd/gorx. Do not modify.

import (
	"errors"
	"sync/atomic"
)

type Subscription interface {
	// Unsubscribe from the subscription.
	Unsubscribe()
	// Unsubscribed returns true if this subscription has been unsubscribed.
	Unsubscribed() bool
}

type GenericSubscription int32

func (t *GenericSubscription) Unsubscribe() {
	atomic.StoreInt32((*int32)(t), 1)
}

func (t *GenericSubscription) Unsubscribed() bool {
	return atomic.LoadInt32((*int32)(t)) == 1
}

type PartialObserver interface {
	Error(error)
	Complete()
}

type GenericObserver interface {
	PartialObserver
	Next(interface{})
}

type GenericObserverFunc func(interface{}, error, bool)

func (f GenericObserverFunc) Next(next interface{}) { f(next, nil, false) }
func (f GenericObserverFunc) Error(err error)       { f(nil, err, false) }
func (f GenericObserverFunc) Complete()             { f(nil, nil, true) }

type GenericObservableFilter func(next interface{}, err error, complete bool, observer GenericObserver)

// Turtles all the way down!
type GenericObservableFilterFactory func() GenericObservableFilter

func distinctFilter() GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		seen := map[interface{}]struct{}{}
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if _, ok := seen[next]; ok {
					return
				}
				seen[next] = struct{}{}
				observer.Next(next)
			}
		}
	}
}

func elementAtFilter(n int) GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		i := 0
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if i == n {
					observer.Next(next)
				}
				i++
			}
		}
	}
}

func filterFilter(f func(next interface{}) bool) GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if f(next) {
					observer.Next(next)
				}
			}
		}
	}
}

func firstFilter() GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		start := true
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if start {
					observer.Next(next)
				}
				start = false
			}
		}
	}
}

func lastFilter() GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		have := false
		var last interface{}
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				if have {
					observer.Next(last)
				}
				observer.Error(err)
			case complete:
				if have {
					observer.Next(last)
				}
				observer.Complete()
			default:
				last = next
				have = true
			}
		}
	}
}

func skipFilter(n int) GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		i := 0
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if i >= n {
					observer.Next(next)
				}
				i++
			}
		}
	}
}

func skipLastFilter(n int) GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		read := 0
		write := 0
		buffer := make([]interface{}, n+1)
		n++
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				buffer[write] = next
				write = (write + 1) % n
				if write == read {
					observer.Next(buffer[read])
					read = (read + 1) % n
				}
			}
		}
	}
}

func oneFilter() GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		count := 0
		var value interface{}
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				if count != 1 {
					observer.Error(errors.New("expected one value"))
				} else {
					observer.Next(value)
					observer.Complete()
				}
			default:
				count++
				if count == 2 {
					observer.Error(errors.New("expected one value"))
					return
				}
				value = next
			}
		}
	}
}

func raiseFilter(err error) GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			observer.Error(err)
		}
	}
}



type IntObserver interface {
	Next(int)
	PartialObserver
}

func PassthroughInt(next int, err error, complete bool, observer IntObserver) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

type IntObserverFunc func(int, error, bool)

var zeroInt = *new(int)

func (f IntObserverFunc) Next(next int) { f(next, nil, false) }
func (f IntObserverFunc) Error(err error)  { f(zeroInt, err, false) }
func (f IntObserverFunc) Complete()        { f(zeroInt, nil, true) }

type IntObservable interface {
	Subscribe(IntObserver) Subscription
}

// Convert a GenericObservableFilter to a IntObservable
func (f GenericObservableFilterFactory) Int(parent IntObservable) IntObservable {
	return MapIntIntObservable(parent, func() MappingIntIntFunc {
		// Initialise the adapter.
		filter := f()
		return func(next int, err error, complete bool, observer IntObserver) {
			filter(next, err, complete, GenericObserverFunc(func(next interface{}, err error, complete bool) {
				switch {
				case err != nil:
					observer.Error(err)
				case complete:
					observer.Complete()
				default:
					observer.Next(next.(int))
				}
			}))
		}
	})
}

type ObservableIntComplete struct {}

func (o *ObservableIntComplete) Subscribe(observer IntObserver) Subscription {
	subscription := new(GenericSubscription)
	go func() {
		observer.Complete()
		subscription.Unsubscribe()
	}()
	return subscription
}

func FromIntComplete() *IntStream {
	return FromIntObservable(&ObservableIntComplete{})
}

type ObservableIntError struct {
	Err error
}

func (o *ObservableIntError) Error() string {
	return o.Err.Error()
}

func (o *ObservableIntError) Subscribe(observer IntObserver) Subscription {
	subscription := new(GenericSubscription)
	go func() {
		observer.Error(o)
		subscription.Unsubscribe()
	}()
	return subscription
}

func FromIntError(err error) *IntStream {
	return FromIntObservable(&ObservableIntError{ err })
}

type ObservableIntArray []int

func (o ObservableIntArray) Subscribe(observer IntObserver) Subscription {
	subscription := new(GenericSubscription)
	go func() {
		for _, v := range o {
			observer.Next(v)
			if subscription.Unsubscribed() {
				break
			}
		}
		observer.Complete()
		subscription.Unsubscribe()
	}()
	return subscription
}

func FromIntArray(array []int) *IntStream {
	return FromIntObservable(ObservableIntArray(array))
}

type ObservableIntChannel <-chan int

func (o ObservableIntChannel) Subscribe(observer IntObserver) Subscription {
	subscription := new(GenericSubscription)
	go func() {
		for v := range o {
			observer.Next(v)
			if subscription.Unsubscribed() {
				break
			}
		}
		observer.Complete()
		subscription.Unsubscribe()
	}()
	return subscription
}


func FromIntChannel(ch <-chan int) *IntStream {
	return FromIntObservable(ObservableIntChannel(ch))
}

type IntStream struct {
	IntObservable
}

func FromIntObservable(observable IntObservable) *IntStream {
	return &IntStream{observable}
}

func (s *IntStream) SubscribeFunc(f IntObserverFunc) Subscription {
	return s.Subscribe(f)
}

// Distinct removes duplicate elements in the stream.
func (s *IntStream) Distinct() *IntStream {
	return FromIntObservable(distinctFilter().Int(s))
}

// ElementAt yields the Nth element of the stream.
func (s *IntStream) ElementAt(n int) *IntStream {
	return FromIntObservable(elementAtFilter(n).Int(s))
}

// Filter elements in the stream on a function.
func (s *IntStream) Filter(f func(int) bool) *IntStream {
	return FromIntObservable(filterFilter(func(v interface{}) bool { return f(v.(int)) }).Int(s))
}

// Last returns just the first element of the stream.
func (s *IntStream) First() *IntStream {
	return FromIntObservable(firstFilter().Int(s))
}

// Last returns just the last element of the stream.
func (s *IntStream) Last() *IntStream {
	return FromIntObservable(lastFilter().Int(s))
}

// SkipLast skips the first N elements of the stream.
func (s *IntStream) Skip(n int) *IntStream {
	return FromIntObservable(skipFilter(n).Int(s))
}

// SkipLast skips the last N elements of the stream.
func (s *IntStream) SkipLast(n int) *IntStream {
	return FromIntObservable(skipLastFilter(n).Int(s))
}

// Do applies a function for each value passing through the stream.
func (s *IntStream) Do(f func(next int)) *IntStream {
	return FromIntObservable(MapIntIntObserveNext(s, func(next int) int {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *IntStream) DoOnError(f func(err error)) *IntStream {
	return FromIntObservable(MapIntIntObservable(s, func() MappingIntIntFunc {
		return func(next int, err error, complete bool, observer IntObserver) {
			if err != nil {
				f(err)
			}
			PassthroughInt(next, err, complete, observer)
		}
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *IntStream) DoOnComplete(f func()) *IntStream {
	return FromIntObservable(MapIntIntObservable(s, func() MappingIntIntFunc {
		return func(next int, err error, complete bool, observer IntObserver) {
			if complete {
				f()
			}
			PassthroughInt(next, err, complete, observer)
		}
	}))
}

func (s *IntStream) Reduce(initial int, reducer func (int, int) int) *IntStream {
	return FromIntObservable(MapIntIntObservable(s, func() MappingIntIntFunc {
		value := initial
		return func(next int, err error, complete bool, observer IntObserver) {
			switch {
			case err != nil:
				observer.Next(value)
				observer.Error(err)
			case complete:
				observer.Next(value)
				observer.Complete()
			default:
				value = reducer(value, next)
			}
		}
	}))
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *IntStream) ToOneWithError() (int, error) {
	valuech := make(chan int)
	errch := make(chan error)
	FromIntObservable(oneFilter().Int(s)).SubscribeFunc(func (next int, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroInt, err
	}
}

func (s *IntStream) ToOne() int {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array, returning it and any error.
func (s *IntStream) ToArrayWithError() ([]int, error) {
	array := []int{}
	completech := make(chan bool)
	errch := make(chan error)
	s.SubscribeFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			completech <- true
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

func (s *IntStream) ToArray() []int {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *IntStream) ToChannelWithError() (<-chan int, <-chan error) {
	ch := make(chan int)
	errch := make(chan error)
	s.SubscribeFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *IntStream) ToChannel() <-chan int {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *IntStream) Count() *IntStream {
	return FromIntObservable(MapIntIntObservable(s, func() MappingIntIntFunc {
		count := 0
		return func(next int, err error, complete bool, observer IntObserver) {
			switch {
			case err != nil:
				observer.Next(count)
				observer.Error(err)
			case complete:
				observer.Next(count)
				observer.Complete()
			default:
				count++
			}
		}
	}))
}

func (s *IntStream) Average() *IntStream {
	return FromIntObservable(MapIntIntObservable(s, func() MappingIntIntFunc {
		var sum int
		var count int
		return func(next int, err error, complete bool, observer IntObserver) {
			switch {
			case err != nil:
				observer.Next(sum / count)
				observer.Error(err)
			case complete:
				observer.Next(sum / count)
				observer.Complete()
			default:
				sum += next
				count++
			}
		}
	}))
}

func (s *IntStream) Sum() *IntStream {
	return FromIntObservable(MapIntIntObservable(s, func() MappingIntIntFunc {
		var sum int
		return func(next int, err error, complete bool, observer IntObserver) {
			switch {
			case err != nil:
				observer.Next(sum)
				observer.Error(err)
			case complete:
				observer.Next(sum)
				observer.Complete()
			default:
				sum += next
			}
		}
	}))
}

func (s *IntStream) Min() *IntStream {
	return FromIntObservable(MapIntIntObservable(s, func() MappingIntIntFunc {
		started := false
		var min int
		return func(next int, err error, complete bool, observer IntObserver) {
			switch {
			case err != nil:
				if started {
					observer.Next(min)
				}
				observer.Error(err)
			case complete:
				if started {
					observer.Next(min)
				}
				observer.Complete()
			default:
				if started {
					if min > next {
						min = next
					}
				} else {
					min = next
					started = true
				}
			}
		}
	}))
}

func (s *IntStream) Max() *IntStream {
	return FromIntObservable(MapIntIntObservable(s, func() MappingIntIntFunc {
		started := false
		var max int
		return func(next int, err error, complete bool, observer IntObserver) {
			switch {
			case err != nil:
				if started {
					observer.Next(max)
				}
				observer.Error(err)
			case complete:
				if started {
					observer.Next(max)
				}
				observer.Complete()
			default:
				if started {
					if max <= next {
						max = next
					}
				} else {
					max = next
					started = true
				}
			}
		}
	}))
}

type MappingIntIntFunc func(next int, err error, complete bool, observer IntObserver)
type MappingIntIntFuncFactory func() MappingIntIntFunc

type MappingIntIntObservable struct {
	parent  IntObservable
	factory MappingIntIntFuncFactory
}

func MapIntIntObservable(parent IntObservable, factory MappingIntIntFuncFactory) IntObservable {
	return &MappingIntIntObservable{
		parent:  parent,
		factory: factory,
	}
}

func MapIntIntObserveNext(parent IntObservable, mapper func(int) int) IntObservable {
	return MapIntIntObservable(parent, func() MappingIntIntFunc {
		return func(next int, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingIntIntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.factory()
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}



type MappingIntStringFunc func(next int, err error, complete bool, observer StringObserver)
type MappingIntStringFuncFactory func() MappingIntStringFunc

type MappingIntStringObservable struct {
	parent  IntObservable
	factory MappingIntStringFuncFactory
}

func MapIntStringObservable(parent IntObservable, factory MappingIntStringFuncFactory) StringObservable {
	return &MappingIntStringObservable{
		parent:  parent,
		factory: factory,
	}
}

func MapIntStringObserveNext(parent IntObservable, mapper func(int) string) StringObservable {
	return MapIntStringObservable(parent, func() MappingIntStringFunc {
		return func(next int, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingIntStringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.factory()
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}


// MapString maps this stream to an StringStream via f.
func (s *IntStream) MapString(f func (int) string) *StringStream {
	return FromStringObservable(MapIntStringObserveNext(s, f))
}

type MappingIntFloat32Func func(next int, err error, complete bool, observer Float32Observer)
type MappingIntFloat32FuncFactory func() MappingIntFloat32Func

type MappingIntFloat32Observable struct {
	parent  IntObservable
	factory MappingIntFloat32FuncFactory
}

func MapIntFloat32Observable(parent IntObservable, factory MappingIntFloat32FuncFactory) Float32Observable {
	return &MappingIntFloat32Observable{
		parent:  parent,
		factory: factory,
	}
}

func MapIntFloat32ObserveNext(parent IntObservable, mapper func(int) float32) Float32Observable {
	return MapIntFloat32Observable(parent, func() MappingIntFloat32Func {
		return func(next int, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingIntFloat32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.factory()
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}


// MapFloat32 maps this stream to an Float32Stream via f.
func (s *IntStream) MapFloat32(f func (int) float32) *Float32Stream {
	return FromFloat32Observable(MapIntFloat32ObserveNext(s, f))
}



type StringObserver interface {
	Next(string)
	PartialObserver
}

func PassthroughString(next string, err error, complete bool, observer StringObserver) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

type StringObserverFunc func(string, error, bool)

var zeroString = *new(string)

func (f StringObserverFunc) Next(next string) { f(next, nil, false) }
func (f StringObserverFunc) Error(err error)  { f(zeroString, err, false) }
func (f StringObserverFunc) Complete()        { f(zeroString, nil, true) }

type StringObservable interface {
	Subscribe(StringObserver) Subscription
}

// Convert a GenericObservableFilter to a StringObservable
func (f GenericObservableFilterFactory) String(parent StringObservable) StringObservable {
	return MapStringStringObservable(parent, func() MappingStringStringFunc {
		// Initialise the adapter.
		filter := f()
		return func(next string, err error, complete bool, observer StringObserver) {
			filter(next, err, complete, GenericObserverFunc(func(next interface{}, err error, complete bool) {
				switch {
				case err != nil:
					observer.Error(err)
				case complete:
					observer.Complete()
				default:
					observer.Next(next.(string))
				}
			}))
		}
	})
}

type ObservableStringComplete struct {}

func (o *ObservableStringComplete) Subscribe(observer StringObserver) Subscription {
	subscription := new(GenericSubscription)
	go func() {
		observer.Complete()
		subscription.Unsubscribe()
	}()
	return subscription
}

func FromStringComplete() *StringStream {
	return FromStringObservable(&ObservableStringComplete{})
}

type ObservableStringError struct {
	Err error
}

func (o *ObservableStringError) Error() string {
	return o.Err.Error()
}

func (o *ObservableStringError) Subscribe(observer StringObserver) Subscription {
	subscription := new(GenericSubscription)
	go func() {
		observer.Error(o)
		subscription.Unsubscribe()
	}()
	return subscription
}

func FromStringError(err error) *StringStream {
	return FromStringObservable(&ObservableStringError{ err })
}

type ObservableStringArray []string

func (o ObservableStringArray) Subscribe(observer StringObserver) Subscription {
	subscription := new(GenericSubscription)
	go func() {
		for _, v := range o {
			observer.Next(v)
			if subscription.Unsubscribed() {
				break
			}
		}
		observer.Complete()
		subscription.Unsubscribe()
	}()
	return subscription
}

func FromStringArray(array []string) *StringStream {
	return FromStringObservable(ObservableStringArray(array))
}

type ObservableStringChannel <-chan string

func (o ObservableStringChannel) Subscribe(observer StringObserver) Subscription {
	subscription := new(GenericSubscription)
	go func() {
		for v := range o {
			observer.Next(v)
			if subscription.Unsubscribed() {
				break
			}
		}
		observer.Complete()
		subscription.Unsubscribe()
	}()
	return subscription
}


func FromStringChannel(ch <-chan string) *StringStream {
	return FromStringObservable(ObservableStringChannel(ch))
}

type StringStream struct {
	StringObservable
}

func FromStringObservable(observable StringObservable) *StringStream {
	return &StringStream{observable}
}

func (s *StringStream) SubscribeFunc(f StringObserverFunc) Subscription {
	return s.Subscribe(f)
}

// Distinct removes duplicate elements in the stream.
func (s *StringStream) Distinct() *StringStream {
	return FromStringObservable(distinctFilter().String(s))
}

// ElementAt yields the Nth element of the stream.
func (s *StringStream) ElementAt(n int) *StringStream {
	return FromStringObservable(elementAtFilter(n).String(s))
}

// Filter elements in the stream on a function.
func (s *StringStream) Filter(f func(string) bool) *StringStream {
	return FromStringObservable(filterFilter(func(v interface{}) bool { return f(v.(string)) }).String(s))
}

// Last returns just the first element of the stream.
func (s *StringStream) First() *StringStream {
	return FromStringObservable(firstFilter().String(s))
}

// Last returns just the last element of the stream.
func (s *StringStream) Last() *StringStream {
	return FromStringObservable(lastFilter().String(s))
}

// SkipLast skips the first N elements of the stream.
func (s *StringStream) Skip(n int) *StringStream {
	return FromStringObservable(skipFilter(n).String(s))
}

// SkipLast skips the last N elements of the stream.
func (s *StringStream) SkipLast(n int) *StringStream {
	return FromStringObservable(skipLastFilter(n).String(s))
}

// Do applies a function for each value passing through the stream.
func (s *StringStream) Do(f func(next string)) *StringStream {
	return FromStringObservable(MapStringStringObserveNext(s, func(next string) string {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *StringStream) DoOnError(f func(err error)) *StringStream {
	return FromStringObservable(MapStringStringObservable(s, func() MappingStringStringFunc {
		return func(next string, err error, complete bool, observer StringObserver) {
			if err != nil {
				f(err)
			}
			PassthroughString(next, err, complete, observer)
		}
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *StringStream) DoOnComplete(f func()) *StringStream {
	return FromStringObservable(MapStringStringObservable(s, func() MappingStringStringFunc {
		return func(next string, err error, complete bool, observer StringObserver) {
			if complete {
				f()
			}
			PassthroughString(next, err, complete, observer)
		}
	}))
}

func (s *StringStream) Reduce(initial string, reducer func (string, string) string) *StringStream {
	return FromStringObservable(MapStringStringObservable(s, func() MappingStringStringFunc {
		value := initial
		return func(next string, err error, complete bool, observer StringObserver) {
			switch {
			case err != nil:
				observer.Next(value)
				observer.Error(err)
			case complete:
				observer.Next(value)
				observer.Complete()
			default:
				value = reducer(value, next)
			}
		}
	}))
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *StringStream) ToOneWithError() (string, error) {
	valuech := make(chan string)
	errch := make(chan error)
	FromStringObservable(oneFilter().String(s)).SubscribeFunc(func (next string, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroString, err
	}
}

func (s *StringStream) ToOne() string {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array, returning it and any error.
func (s *StringStream) ToArrayWithError() ([]string, error) {
	array := []string{}
	completech := make(chan bool)
	errch := make(chan error)
	s.SubscribeFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			completech <- true
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

func (s *StringStream) ToArray() []string {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *StringStream) ToChannelWithError() (<-chan string, <-chan error) {
	ch := make(chan string)
	errch := make(chan error)
	s.SubscribeFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *StringStream) ToChannel() <-chan string {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *StringStream) Count() *IntStream {
	return FromIntObservable(MapStringIntObservable(s, func() MappingStringIntFunc {
		count := 0
		return func(next string, err error, complete bool, observer IntObserver) {
			switch {
			case err != nil:
				observer.Next(count)
				observer.Error(err)
			case complete:
				observer.Next(count)
				observer.Complete()
			default:
				count++
			}
		}
	}))
}


type MappingStringIntFunc func(next string, err error, complete bool, observer IntObserver)
type MappingStringIntFuncFactory func() MappingStringIntFunc

type MappingStringIntObservable struct {
	parent  StringObservable
	factory MappingStringIntFuncFactory
}

func MapStringIntObservable(parent StringObservable, factory MappingStringIntFuncFactory) IntObservable {
	return &MappingStringIntObservable{
		parent:  parent,
		factory: factory,
	}
}

func MapStringIntObserveNext(parent StringObservable, mapper func(string) int) IntObservable {
	return MapStringIntObservable(parent, func() MappingStringIntFunc {
		return func(next string, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingStringIntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.factory()
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}


// MapInt maps this stream to an IntStream via f.
func (s *StringStream) MapInt(f func (string) int) *IntStream {
	return FromIntObservable(MapStringIntObserveNext(s, f))
}

type MappingStringStringFunc func(next string, err error, complete bool, observer StringObserver)
type MappingStringStringFuncFactory func() MappingStringStringFunc

type MappingStringStringObservable struct {
	parent  StringObservable
	factory MappingStringStringFuncFactory
}

func MapStringStringObservable(parent StringObservable, factory MappingStringStringFuncFactory) StringObservable {
	return &MappingStringStringObservable{
		parent:  parent,
		factory: factory,
	}
}

func MapStringStringObserveNext(parent StringObservable, mapper func(string) string) StringObservable {
	return MapStringStringObservable(parent, func() MappingStringStringFunc {
		return func(next string, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingStringStringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.factory()
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}



type MappingStringFloat32Func func(next string, err error, complete bool, observer Float32Observer)
type MappingStringFloat32FuncFactory func() MappingStringFloat32Func

type MappingStringFloat32Observable struct {
	parent  StringObservable
	factory MappingStringFloat32FuncFactory
}

func MapStringFloat32Observable(parent StringObservable, factory MappingStringFloat32FuncFactory) Float32Observable {
	return &MappingStringFloat32Observable{
		parent:  parent,
		factory: factory,
	}
}

func MapStringFloat32ObserveNext(parent StringObservable, mapper func(string) float32) Float32Observable {
	return MapStringFloat32Observable(parent, func() MappingStringFloat32Func {
		return func(next string, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingStringFloat32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.factory()
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}


// MapFloat32 maps this stream to an Float32Stream via f.
func (s *StringStream) MapFloat32(f func (string) float32) *Float32Stream {
	return FromFloat32Observable(MapStringFloat32ObserveNext(s, f))
}



type Float32Observer interface {
	Next(float32)
	PartialObserver
}

func PassthroughFloat32(next float32, err error, complete bool, observer Float32Observer) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

type Float32ObserverFunc func(float32, error, bool)

var zeroFloat32 = *new(float32)

func (f Float32ObserverFunc) Next(next float32) { f(next, nil, false) }
func (f Float32ObserverFunc) Error(err error)  { f(zeroFloat32, err, false) }
func (f Float32ObserverFunc) Complete()        { f(zeroFloat32, nil, true) }

type Float32Observable interface {
	Subscribe(Float32Observer) Subscription
}

// Convert a GenericObservableFilter to a Float32Observable
func (f GenericObservableFilterFactory) Float32(parent Float32Observable) Float32Observable {
	return MapFloat32Float32Observable(parent, func() MappingFloat32Float32Func {
		// Initialise the adapter.
		filter := f()
		return func(next float32, err error, complete bool, observer Float32Observer) {
			filter(next, err, complete, GenericObserverFunc(func(next interface{}, err error, complete bool) {
				switch {
				case err != nil:
					observer.Error(err)
				case complete:
					observer.Complete()
				default:
					observer.Next(next.(float32))
				}
			}))
		}
	})
}

type ObservableFloat32Complete struct {}

func (o *ObservableFloat32Complete) Subscribe(observer Float32Observer) Subscription {
	subscription := new(GenericSubscription)
	go func() {
		observer.Complete()
		subscription.Unsubscribe()
	}()
	return subscription
}

func FromFloat32Complete() *Float32Stream {
	return FromFloat32Observable(&ObservableFloat32Complete{})
}

type ObservableFloat32Error struct {
	Err error
}

func (o *ObservableFloat32Error) Error() string {
	return o.Err.Error()
}

func (o *ObservableFloat32Error) Subscribe(observer Float32Observer) Subscription {
	subscription := new(GenericSubscription)
	go func() {
		observer.Error(o)
		subscription.Unsubscribe()
	}()
	return subscription
}

func FromFloat32Error(err error) *Float32Stream {
	return FromFloat32Observable(&ObservableFloat32Error{ err })
}

type ObservableFloat32Array []float32

func (o ObservableFloat32Array) Subscribe(observer Float32Observer) Subscription {
	subscription := new(GenericSubscription)
	go func() {
		for _, v := range o {
			observer.Next(v)
			if subscription.Unsubscribed() {
				break
			}
		}
		observer.Complete()
		subscription.Unsubscribe()
	}()
	return subscription
}

func FromFloat32Array(array []float32) *Float32Stream {
	return FromFloat32Observable(ObservableFloat32Array(array))
}

type ObservableFloat32Channel <-chan float32

func (o ObservableFloat32Channel) Subscribe(observer Float32Observer) Subscription {
	subscription := new(GenericSubscription)
	go func() {
		for v := range o {
			observer.Next(v)
			if subscription.Unsubscribed() {
				break
			}
		}
		observer.Complete()
		subscription.Unsubscribe()
	}()
	return subscription
}


func FromFloat32Channel(ch <-chan float32) *Float32Stream {
	return FromFloat32Observable(ObservableFloat32Channel(ch))
}

type Float32Stream struct {
	Float32Observable
}

func FromFloat32Observable(observable Float32Observable) *Float32Stream {
	return &Float32Stream{observable}
}

func (s *Float32Stream) SubscribeFunc(f Float32ObserverFunc) Subscription {
	return s.Subscribe(f)
}

// Distinct removes duplicate elements in the stream.
func (s *Float32Stream) Distinct() *Float32Stream {
	return FromFloat32Observable(distinctFilter().Float32(s))
}

// ElementAt yields the Nth element of the stream.
func (s *Float32Stream) ElementAt(n int) *Float32Stream {
	return FromFloat32Observable(elementAtFilter(n).Float32(s))
}

// Filter elements in the stream on a function.
func (s *Float32Stream) Filter(f func(float32) bool) *Float32Stream {
	return FromFloat32Observable(filterFilter(func(v interface{}) bool { return f(v.(float32)) }).Float32(s))
}

// Last returns just the first element of the stream.
func (s *Float32Stream) First() *Float32Stream {
	return FromFloat32Observable(firstFilter().Float32(s))
}

// Last returns just the last element of the stream.
func (s *Float32Stream) Last() *Float32Stream {
	return FromFloat32Observable(lastFilter().Float32(s))
}

// SkipLast skips the first N elements of the stream.
func (s *Float32Stream) Skip(n int) *Float32Stream {
	return FromFloat32Observable(skipFilter(n).Float32(s))
}

// SkipLast skips the last N elements of the stream.
func (s *Float32Stream) SkipLast(n int) *Float32Stream {
	return FromFloat32Observable(skipLastFilter(n).Float32(s))
}

// Do applies a function for each value passing through the stream.
func (s *Float32Stream) Do(f func(next float32)) *Float32Stream {
	return FromFloat32Observable(MapFloat32Float32ObserveNext(s, func(next float32) float32 {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *Float32Stream) DoOnError(f func(err error)) *Float32Stream {
	return FromFloat32Observable(MapFloat32Float32Observable(s, func() MappingFloat32Float32Func {
		return func(next float32, err error, complete bool, observer Float32Observer) {
			if err != nil {
				f(err)
			}
			PassthroughFloat32(next, err, complete, observer)
		}
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *Float32Stream) DoOnComplete(f func()) *Float32Stream {
	return FromFloat32Observable(MapFloat32Float32Observable(s, func() MappingFloat32Float32Func {
		return func(next float32, err error, complete bool, observer Float32Observer) {
			if complete {
				f()
			}
			PassthroughFloat32(next, err, complete, observer)
		}
	}))
}

func (s *Float32Stream) Reduce(initial float32, reducer func (float32, float32) float32) *Float32Stream {
	return FromFloat32Observable(MapFloat32Float32Observable(s, func() MappingFloat32Float32Func {
		value := initial
		return func(next float32, err error, complete bool, observer Float32Observer) {
			switch {
			case err != nil:
				observer.Next(value)
				observer.Error(err)
			case complete:
				observer.Next(value)
				observer.Complete()
			default:
				value = reducer(value, next)
			}
		}
	}))
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *Float32Stream) ToOneWithError() (float32, error) {
	valuech := make(chan float32)
	errch := make(chan error)
	FromFloat32Observable(oneFilter().Float32(s)).SubscribeFunc(func (next float32, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroFloat32, err
	}
}

func (s *Float32Stream) ToOne() float32 {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array, returning it and any error.
func (s *Float32Stream) ToArrayWithError() ([]float32, error) {
	array := []float32{}
	completech := make(chan bool)
	errch := make(chan error)
	s.SubscribeFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			completech <- true
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

func (s *Float32Stream) ToArray() []float32 {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *Float32Stream) ToChannelWithError() (<-chan float32, <-chan error) {
	ch := make(chan float32)
	errch := make(chan error)
	s.SubscribeFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *Float32Stream) ToChannel() <-chan float32 {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *Float32Stream) Count() *IntStream {
	return FromIntObservable(MapFloat32IntObservable(s, func() MappingFloat32IntFunc {
		count := 0
		return func(next float32, err error, complete bool, observer IntObserver) {
			switch {
			case err != nil:
				observer.Next(count)
				observer.Error(err)
			case complete:
				observer.Next(count)
				observer.Complete()
			default:
				count++
			}
		}
	}))
}

func (s *Float32Stream) Average() *Float32Stream {
	return FromFloat32Observable(MapFloat32Float32Observable(s, func() MappingFloat32Float32Func {
		var sum float32
		var count float32
		return func(next float32, err error, complete bool, observer Float32Observer) {
			switch {
			case err != nil:
				observer.Next(sum / count)
				observer.Error(err)
			case complete:
				observer.Next(sum / count)
				observer.Complete()
			default:
				sum += next
				count++
			}
		}
	}))
}

func (s *Float32Stream) Sum() *Float32Stream {
	return FromFloat32Observable(MapFloat32Float32Observable(s, func() MappingFloat32Float32Func {
		var sum float32
		return func(next float32, err error, complete bool, observer Float32Observer) {
			switch {
			case err != nil:
				observer.Next(sum)
				observer.Error(err)
			case complete:
				observer.Next(sum)
				observer.Complete()
			default:
				sum += next
			}
		}
	}))
}

func (s *Float32Stream) Min() *Float32Stream {
	return FromFloat32Observable(MapFloat32Float32Observable(s, func() MappingFloat32Float32Func {
		started := false
		var min float32
		return func(next float32, err error, complete bool, observer Float32Observer) {
			switch {
			case err != nil:
				if started {
					observer.Next(min)
				}
				observer.Error(err)
			case complete:
				if started {
					observer.Next(min)
				}
				observer.Complete()
			default:
				if started {
					if min > next {
						min = next
					}
				} else {
					min = next
					started = true
				}
			}
		}
	}))
}

func (s *Float32Stream) Max() *Float32Stream {
	return FromFloat32Observable(MapFloat32Float32Observable(s, func() MappingFloat32Float32Func {
		started := false
		var max float32
		return func(next float32, err error, complete bool, observer Float32Observer) {
			switch {
			case err != nil:
				if started {
					observer.Next(max)
				}
				observer.Error(err)
			case complete:
				if started {
					observer.Next(max)
				}
				observer.Complete()
			default:
				if started {
					if max <= next {
						max = next
					}
				} else {
					max = next
					started = true
				}
			}
		}
	}))
}

type MappingFloat32IntFunc func(next float32, err error, complete bool, observer IntObserver)
type MappingFloat32IntFuncFactory func() MappingFloat32IntFunc

type MappingFloat32IntObservable struct {
	parent  Float32Observable
	factory MappingFloat32IntFuncFactory
}

func MapFloat32IntObservable(parent Float32Observable, factory MappingFloat32IntFuncFactory) IntObservable {
	return &MappingFloat32IntObservable{
		parent:  parent,
		factory: factory,
	}
}

func MapFloat32IntObserveNext(parent Float32Observable, mapper func(float32) int) IntObservable {
	return MapFloat32IntObservable(parent, func() MappingFloat32IntFunc {
		return func(next float32, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingFloat32IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.factory()
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}


// MapInt maps this stream to an IntStream via f.
func (s *Float32Stream) MapInt(f func (float32) int) *IntStream {
	return FromIntObservable(MapFloat32IntObserveNext(s, f))
}

type MappingFloat32StringFunc func(next float32, err error, complete bool, observer StringObserver)
type MappingFloat32StringFuncFactory func() MappingFloat32StringFunc

type MappingFloat32StringObservable struct {
	parent  Float32Observable
	factory MappingFloat32StringFuncFactory
}

func MapFloat32StringObservable(parent Float32Observable, factory MappingFloat32StringFuncFactory) StringObservable {
	return &MappingFloat32StringObservable{
		parent:  parent,
		factory: factory,
	}
}

func MapFloat32StringObserveNext(parent Float32Observable, mapper func(float32) string) StringObservable {
	return MapFloat32StringObservable(parent, func() MappingFloat32StringFunc {
		return func(next float32, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingFloat32StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.factory()
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}


// MapString maps this stream to an StringStream via f.
func (s *Float32Stream) MapString(f func (float32) string) *StringStream {
	return FromStringObservable(MapFloat32StringObserveNext(s, f))
}

type MappingFloat32Float32Func func(next float32, err error, complete bool, observer Float32Observer)
type MappingFloat32Float32FuncFactory func() MappingFloat32Float32Func

type MappingFloat32Float32Observable struct {
	parent  Float32Observable
	factory MappingFloat32Float32FuncFactory
}

func MapFloat32Float32Observable(parent Float32Observable, factory MappingFloat32Float32FuncFactory) Float32Observable {
	return &MappingFloat32Float32Observable{
		parent:  parent,
		factory: factory,
	}
}

func MapFloat32Float32ObserveNext(parent Float32Observable, mapper func(float32) float32) Float32Observable {
	return MapFloat32Float32Observable(parent, func() MappingFloat32Float32Func {
		return func(next float32, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingFloat32Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.factory()
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}



