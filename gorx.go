// Package gorx implements ReactiveX extensions for Go.
package gorx

//go:generate gorx -o gorx.go gorx --base-types

// NOTE: This file was generated by github.com/alecthomas/gorx/cmd/gorx. Do not modify.

import (
	"errors"
	"io"
	"sync"
	"sync/atomic"
	"time"
)

// ErrTimeout is delivered to an observer if the stream times out.
var ErrTimeout = errors.New("timeout")

// MaxReplaySize is the maximum size of a replay buffer. Can be modified.
var MaxReplaySize = 16384

// A Subscription to an observable.
type Subscription interface {
	// Unsubscribe from the subscription.
	io.Closer
	// Closed returns true if this subscription has been unsubscribed.
	Closed() bool
}

// SubscriptionEvents provides lifecycle event callbacks for a Subscription.
type SubscriptionEvents interface {
	OnUnsubscribe(func())
}

// A Subscription that is already closed.
type closedSubscription struct{}

func (closedSubscription) Close() error { return nil }
func (closedSubscription) Closed() bool { return true }

// ClosedSubscription always returns true for Closed()
var ClosedSubscription Subscription = closedSubscription{}

// A LinkedSubscription is a link to a (possible) future Subscription.
type LinkedSubscription struct {
	lock         sync.Mutex
	unsubscribed bool
	linked       Subscription
}

func NewLinkedSubscription() *LinkedSubscription {
	return &LinkedSubscription{}
}

func (l *LinkedSubscription) Link(subscription Subscription) {
	l.lock.Lock()
	defer l.lock.Unlock()
	if l.linked != nil {
		panic("LinkedSubscription is already linked")
	}
	l.linked = subscription
	if l.unsubscribed {
		l.linked.Close()
	}
}

func (l *LinkedSubscription) Close() error {
	l.lock.Lock()
	defer l.lock.Unlock()
	l.unsubscribed = true
	if l.linked != nil {
		return l.linked.Close()
	}
	return nil
}

func (l *LinkedSubscription) Closed() bool {
	l.lock.Lock()
	defer l.lock.Unlock()
	if l.linked != nil {
		return l.linked.Closed()
	}
	return l.unsubscribed
}

// ChannelSubscription is implemented with a channel which is closed when
// unsubscribed.
type ChannelSubscription chan struct{}

func NewChannelSubscription() ChannelSubscription {
	return make(ChannelSubscription)
}

func (c ChannelSubscription) Close() error {
	defer recover()
	close(c)
	return nil
}

func (c ChannelSubscription) Closed() bool {
	select {
	case _, ok := <-c:
		return !ok
	default:
		return false
	}
}
func (c ChannelSubscription) OnUnsubscribe(handler func()) {
	go func() {
		<-c
		handler()
	}()
}

// GenericSubscription is implemented with atomic operations.
type GenericSubscription int32

func NewGenericSubscription() Subscription {
	return new(GenericSubscription)
}

func (t *GenericSubscription) Close() error {
	atomic.StoreInt32((*int32)(t), 1)
	return nil
}

func (t *GenericSubscription) Closed() bool {
	return atomic.LoadInt32((*int32)(t)) == 1
}

// TerminationObserver contains functions for observing termination of a stream.
type TerminationObserver interface {
	Error(error)
	Complete()
}

type GenericObserver interface {
	TerminationObserver
	Next(interface{})
}

type GenericObserverFunc struct {
	f func(interface{}, error, bool)
	Subscription
}

func NewGenericObserverFunc(f func(interface{}, error, bool)) *GenericObserverFunc {
	return &GenericObserverFunc{f, NewGenericSubscription()}
}

func (f *GenericObserverFunc) Next(next interface{}) { f.f(next, nil, false) }
func (f *GenericObserverFunc) Error(err error)       { f.f(nil, err, false) }
func (f *GenericObserverFunc) Complete()             { f.f(nil, nil, true) }

type GenericObservableFilter func(next interface{}, err error, complete bool, observer GenericObserver)

// Turtles all the way down!
type GenericObservableFilterFactory func(GenericObserver) GenericObservableFilter

func ignoreCompletionFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				break
			default:
				observer.Next(next)
			}
		}
	}
}

func distinctFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		seen := map[interface{}]struct{}{}
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if _, ok := seen[next]; ok {
					return
				}
				seen[next] = struct{}{}
				observer.Next(next)
			}
		}
	}
}

func elementAtFilter(n int) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		i := 0
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if i == n {
					observer.Next(next)
				}
				i++
			}
		}
	}
}

func filterFilter(f func(next interface{}) bool) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if f(next) {
					observer.Next(next)
				}
			}
		}
	}
}

func firstFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		start := true
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if start {
					observer.Next(next)
				}
				start = false
			}
		}
	}
}

func lastFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		have := false
		var last interface{}
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				if have {
					observer.Next(last)
				}
				observer.Error(err)
			case complete:
				if have {
					observer.Next(last)
				}
				observer.Complete()
			default:
				last = next
				have = true
			}
		}
	}
}

func takeLastFilter(n int) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		read := 0
		write := 0
		n++
		buffer := make([]interface{}, n)
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				for read != write {
					observer.Next(buffer[read])
					read = (read + 1) % n
				}
				observer.Error(err)
			case complete:
				for read != write {
					observer.Next(buffer[read])
					read = (read + 1) % n
				}
				observer.Complete()
			default:
				buffer[write] = next
				write = (write + 1) % n
				if write == read {
					read = (read + 1) % n
				}
			}
		}
	}
}

func takeFilter(n int) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		taken := 0
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			if taken >= n {
				return
			}
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				observer.Next(next)
				taken++
				if taken >= n {
					observer.Complete()
				}
			}
		}
	}
}

func ignoreElementsFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			}
		}
	}
}

func skipFilter(n int) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		i := 0
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if i >= n {
					observer.Next(next)
				}
				i++
			}
		}
	}
}

func skipLastFilter(n int) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		read := 0
		write := 0
		n++
		buffer := make([]interface{}, n)
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				buffer[write] = next
				write = (write + 1) % n
				if write == read {
					observer.Next(buffer[read])
					read = (read + 1) % n
				}
			}
		}
	}
}

func oneFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		count := 0
		var value interface{}
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			if count > 1 {
				return
			}
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				if count == 2 {
					observer.Error(errors.New("expected one value"))
				} else {
					observer.Next(value)
					observer.Complete()
				}
			default:
				count++
				if count == 2 {
					observer.Error(errors.New("expected one value"))
					return
				}
				value = next
			}
		}
	}
}

func sampleFilter(window time.Duration) GenericObservableFilterFactory {
	return func(observer GenericObserver) GenericObservableFilter {
		mutex := &sync.Mutex{}
		cancel := make(chan bool, 1)
		var last interface{}
		haveNew := false
		go func() {
			for {
				select {
				case <-time.After(window):
					mutex.Lock()
					if haveNew {
						observer.Next(last)
						haveNew = false
					}
					mutex.Unlock()
				case <-cancel:
					return
				}
			}
		}()
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				cancel <- true
				observer.Error(err)
			case complete:
				cancel <- true
				observer.Complete()
			default:
				mutex.Lock()
				last = next
				haveNew = true
				mutex.Unlock()
			}
		}
	}
}

func debounceFilter(duration time.Duration) GenericObservableFilterFactory {
	return func(observer GenericObserver) GenericObservableFilter {
		errch := make(chan error)
		completech := make(chan bool)
		valuech := make(chan interface{})
		go func() {
			var timeout <-chan time.Time
			var nextValue interface{}
			for {
				select {
				case <-timeout:
					observer.Next(nextValue)
					timeout = nil
				case nextValue = <-valuech:
					timeout = time.After(duration)
				case err := <-errch:
					if timeout != nil {
						observer.Next(nextValue)
					}
					observer.Error(err)
					return
				case <-completech:
					if timeout != nil {
						observer.Next(nextValue)
					}
					observer.Complete()
					return
				}
			}
		}()
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				errch <- err
			case complete:
				completech <- true
			default:
				valuech <- next
			}
		}
	}
}

type timedEntry struct {
	v interface{}
	t time.Time
}

func replayFilter(size int, duration time.Duration) GenericObservableFilterFactory {
	read := 0
	write := 0
	if size == 0 {
		size = MaxReplaySize
	}
	if duration == 0 {
		duration = time.Hour * 24 * 7 * 52
	}
	size++
	buffer := make([]timedEntry, size)
	return func(observer GenericObserver) GenericObservableFilter {
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			now := time.Now()
			switch {
			case err != nil:
				cursor := read
				for cursor != write {
					if buffer[cursor].t.After(now) {
						observer.Next(buffer[cursor].v)
					}
					cursor = (cursor + 1) % size
				}
				observer.Error(err)
			case complete:
				cursor := read
				for cursor != write {
					if buffer[cursor].t.After(now) {
						observer.Next(buffer[cursor].v)
					}
					cursor = (cursor + 1) % size
				}
				observer.Complete()
			default:
				buffer[write] = timedEntry{next, time.Now().Add(duration)}
				write = (write + 1) % size
				if write == read {
					if buffer[read].t.After(now) {
						observer.Next(buffer[read].v)
					}
					read = (read + 1) % size
				}
			}
		}
	}
}

func Range(start, count int) *IntStream {
	end := start + count
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		for i := start; i < end; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(i)
		}
		observer.Complete()
		subscription.Close()
	})
}

func Interval(interval time.Duration) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		i := 0
		for {
			time.Sleep(interval)
			if subscription.Closed() {
				return
			}
			observer.Next(i)
			i++
		}
	})
}

type BoolObserver interface {
	Next(bool)
	TerminationObserver
}

// A BoolSubscriber represents a subscribed BoolObserver.
type BoolSubscriber interface {
	Subscription
	BoolObserver
}

type implBoolSubscriber struct {
	Subscription
	BoolObserver
}

func BoolObserverAsGenericObserver(observer BoolObserver) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(bool))
		}
	})
}

func GenericObserverAsBoolObserver(observer GenericObserver) BoolObserver {
	return BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type BoolObservableFactory func(observer BoolObserver, subscription Subscription)

func (f BoolObservableFactory) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateBool calls f(observer, subscription) to produce values for a stream.
func CreateBool(f func(observer BoolObserver, subscription Subscription)) *BoolStream {
	return FromBoolObservable(BoolObservableFactory(f))
}

// Repeat value count times.
func RepeatBool(value bool, count int) *BoolStream {
	return CreateBool(func(observer BoolObserver, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartBool is designed to be used with functions that return a
// (bool, error) tuple.
//
// If the error is non-nil the returned BoolStream will be that error,
// otherwise it will be a single-value stream of bool.
func StartBool(f func() (bool, error)) *BoolStream {
	return CreateBool(func(observer BoolObserver, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughBool(next bool, err error, complete bool, observer BoolObserver) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroBool = *new(bool)

type BoolObserverFunc func(bool, error, bool)

func (f BoolObserverFunc) Next(next bool)  { f(next, nil, false) }
func (f BoolObserverFunc) Error(err error) { f(zeroBool, err, false) }
func (f BoolObserverFunc) Complete()       { f(zeroBool, nil, true) }

type BoolObservable interface {
	Subscribe(BoolObserver) Subscription
}

// Convert a GenericObservableFilter to a BoolObservable
func (f GenericObservableFilterFactory) Bool(parent BoolObservable) BoolObservable {
	return MapBool2BoolObservable(parent, func(observer BoolObserver) MappingBool2BoolFunc {
		gobserver := BoolObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next bool, err error, complete bool, observer BoolObserver) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverBool() *BoolStream {
	return CreateBool(func(observer BoolObserver, subscription Subscription) {})
}

func EmptyBool() *BoolStream {
	return CreateBool(func(observer BoolObserver, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowBool(err error) *BoolStream {
	return CreateBool(func(observer BoolObserver, subscription Subscription) {
		observer.Error(err)
	})
}

func FromBoolArray(array []bool) *BoolStream {
	return CreateBool(func(observer BoolObserver, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromBools(array ...bool) *BoolStream {
	return FromBoolArray(array)
}

func JustBool(element bool) *BoolStream {
	return FromBoolArray([]bool{element})
}

func MergeBool(observables ...BoolObservable) *BoolStream {
	if len(observables) == 0 {
		return EmptyBool()
	}
	return (&BoolStream{observables[0]}).Merge(observables[1:]...)
}

func MergeBoolDelayError(observables ...BoolObservable) *BoolStream {
	if len(observables) == 0 {
		return EmptyBool()
	}
	return (&BoolStream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromBoolChannel(ch <-chan bool) *BoolStream {
	return CreateBool(func(observer BoolObserver, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type BoolStream struct {
	BoolObservable
}

func FromBoolObservable(observable BoolObservable) *BoolStream {
	return &BoolStream{observable}
}

func (s *BoolStream) SubscribeFunc(f func(bool, error, bool)) Subscription {
	return s.Subscribe(BoolObserverFunc(f))
}

func (s *BoolStream) SubscribeNext(f func(v bool)) Subscription {
	return s.SubscribeFunc(func(next bool, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *BoolStream) Distinct() *BoolStream {
	return FromBoolObservable(distinctFilter().Bool(s))
}

// ElementAt yields the Nth element of the stream.
func (s *BoolStream) ElementAt(n int) *BoolStream {
	return FromBoolObservable(elementAtFilter(n).Bool(s))
}

// Filter elements in the stream on a function.
func (s *BoolStream) Filter(f func(bool) bool) *BoolStream {
	return FromBoolObservable(filterFilter(func(v interface{}) bool { return f(v.(bool)) }).Bool(s))
}

// Last returns just the first element of the stream.
func (s *BoolStream) First() *BoolStream {
	return FromBoolObservable(firstFilter().Bool(s))
}

// Last returns just the last element of the stream.
func (s *BoolStream) Last() *BoolStream {
	return FromBoolObservable(lastFilter().Bool(s))
}

// SkipLast skips the first N elements of the stream.
func (s *BoolStream) Skip(n int) *BoolStream {
	return FromBoolObservable(skipFilter(n).Bool(s))
}

// SkipLast skips the last N elements of the stream.
func (s *BoolStream) SkipLast(n int) *BoolStream {
	return FromBoolObservable(skipLastFilter(n).Bool(s))
}

// Take returns just the first N elements of the stream.
func (s *BoolStream) Take(n int) *BoolStream {
	return FromBoolObservable(takeFilter(n).Bool(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *BoolStream) TakeLast(n int) *BoolStream {
	return FromBoolObservable(takeLastFilter(n).Bool(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *BoolStream) IgnoreElements() *BoolStream {
	return FromBoolObservable(ignoreElementsFilter().Bool(s))
}

func (s *BoolStream) Replay(size int, duration time.Duration) *BoolStream {
	return FromBoolObservable(replayFilter(size, duration).Bool(s))
}

func (s *BoolStream) Sample(duration time.Duration) *BoolStream {
	return FromBoolObservable(sampleFilter(duration).Bool(s))
}

func (s *BoolStream) Debounce(duration time.Duration) *BoolStream {
	return FromBoolObservable(debounceFilter(duration).Bool(s))
}

// Wait for completion of the stream and return any error.
func (s *BoolStream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeBoolSubscriber(observer BoolObserver) BoolSubscriber {
	if subscriber, ok := observer.(BoolSubscriber); ok {
		return subscriber
	}
	return &implBoolSubscriber{NewGenericSubscription(), observer}
}

type concatBoolSubscriber struct {
	observable  int
	observer    BoolObserver
	observables []BoolObservable
	Subscription
}

func (c *concatBoolSubscriber) Next(next bool) {
	c.observer.Next(next)
}

func (c *concatBoolSubscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatBoolSubscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatBoolObservable struct {
	observables []BoolObservable
}

func (m *concatBoolObservable) Subscribe(observer BoolObserver) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatBoolSubscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *BoolStream) Concat(observables ...BoolObservable) *BoolStream {
	return &BoolStream{&concatBoolObservable{append([]BoolObservable{s}, observables...)}}
}

type mergeBoolObservable struct {
	delayError  bool
	observables []BoolObservable
}

func (m *mergeBoolObservable) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next bool, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(BoolObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *BoolStream) Merge(other ...BoolObservable) *BoolStream {
	if len(other) == 0 {
		return s
	}
	return &BoolStream{&mergeBoolObservable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *BoolStream) MergeDelayError(other ...BoolObservable) *BoolStream {
	if len(other) == 0 {
		return s
	}
	return &BoolStream{&mergeBoolObservable{true, append(other, s)}}
}

type catchBoolObservable struct {
	parent BoolObservable
	catch  BoolObservable
}

func (r *catchBoolObservable) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	run := func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(BoolObserverFunc(run))
	return subscription
}

func (s *BoolStream) Catch(catch BoolObservable) *BoolStream {
	return &BoolStream{&catchBoolObservable{s, catch}}
}

type retryBoolObservable struct {
	observable BoolObservable
}

type retryBoolObserver struct {
	observable BoolObservable
	observer   BoolObserver
}

func (r *retryBoolObserver) retry(next bool, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(BoolObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryBoolObservable) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryBoolObserver{r.observable, observer}
	r.observable.Subscribe(BoolObserverFunc(ro.retry))
	return subscription
}

func (s *BoolStream) Retry() *BoolStream {
	return &BoolStream{&retryBoolObservable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *BoolStream) Do(f func(next bool)) *BoolStream {
	return FromBoolObservable(MapBool2BoolObserveNext(s, func(next bool) bool {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *BoolStream) DoOnError(f func(err error)) *BoolStream {
	return FromBoolObservable(MapBool2BoolObserveDirect(s, func(next bool, err error, complete bool, observer BoolObserver) {
		if err != nil {
			f(err)
		}
		PassthroughBool(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *BoolStream) DoOnComplete(f func()) *BoolStream {
	return FromBoolObservable(MapBool2BoolObserveDirect(s, func(next bool, err error, complete bool, observer BoolObserver) {
		if complete {
			f()
		}
		PassthroughBool(next, err, complete, observer)
	}))
}

func (s *BoolStream) Reduce(initial bool, reducer func(bool, bool) bool) *BoolStream {
	value := initial
	return FromBoolObservable(MapBool2BoolObserveDirect(s, func(next bool, err error, complete bool, observer BoolObserver) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *BoolStream) Scan(initial bool, f func(bool, bool) bool) *BoolStream {
	value := initial
	return FromBoolObservable(MapBool2BoolObserveDirect(s, func(next bool, err error, complete bool, observer BoolObserver) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutBool struct {
	parent  BoolObservable
	timeout time.Duration
}

func (t *timeoutBool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *BoolStream) Timeout(timeout time.Duration) *BoolStream {
	return &BoolStream{&timeoutBool{s, timeout}}
}

type forkedBoolStream struct {
	lock      sync.Mutex
	parent    BoolObservable
	observers []BoolObserver
}

func (f *forkedBoolStream) Subscribe(observer BoolObserver) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *BoolStream) Fork() *BoolStream {
	f := &forkedBoolStream{parent: s}
	go s.Subscribe(BoolObserverFunc(func(n bool, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &BoolStream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *BoolStream) ToOneWithError() (bool, error) {
	valuech := make(chan bool, 1)
	errch := make(chan error, 1)
	FromBoolObservable(oneFilter().Bool(s)).SubscribeFunc(func(next bool, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroBool, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *BoolStream) ToOne() bool {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *BoolStream) ToArrayWithError() ([]bool, error) {
	array := []bool{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *BoolStream) ToArray() []bool {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *BoolStream) ToChannelWithError() (<-chan bool, <-chan error) {
	ch := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *BoolStream) ToChannel() <-chan bool {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *BoolStream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapBool2IntObserveDirect(s, func(next bool, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

type MappingBool2BoolFunc func(next bool, err error, complete bool, observer BoolObserver)
type MappingBool2BoolFuncFactory func(observer BoolObserver) MappingBool2BoolFunc

type MappingBool2BoolObservable struct {
	parent BoolObservable
	mapper MappingBool2BoolFuncFactory
}

func (f *MappingBool2BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2BoolObservable(parent BoolObservable, mapper MappingBool2BoolFuncFactory) BoolObservable {
	return &MappingBool2BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2BoolObserveDirect(parent BoolObservable, mapper MappingBool2BoolFunc) BoolObservable {
	return MapBool2BoolObservable(parent, func(BoolObserver) MappingBool2BoolFunc {
		return mapper
	})
}

func MapBool2BoolObserveNext(parent BoolObservable, mapper func(bool) bool) BoolObservable {
	return MapBool2BoolObservable(parent, func(BoolObserver) MappingBool2BoolFunc {
		return func(next bool, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Bool struct {
	parent BoolObservable
	mapper func(bool) BoolObservable
}

func (f *flatMapBool2Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *BoolStream) Map(f func(bool) bool) *BoolStream {
	return FromBoolObservable(MapBool2BoolObserveNext(s, f))
}

func (s *BoolStream) FlatMap(f func(bool) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapBool2Bool{s, f}}
}

type MappingBool2RuneFunc func(next bool, err error, complete bool, observer RuneObserver)
type MappingBool2RuneFuncFactory func(observer RuneObserver) MappingBool2RuneFunc

type MappingBool2RuneObservable struct {
	parent BoolObservable
	mapper MappingBool2RuneFuncFactory
}

func (f *MappingBool2RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2RuneObservable(parent BoolObservable, mapper MappingBool2RuneFuncFactory) RuneObservable {
	return &MappingBool2RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2RuneObserveDirect(parent BoolObservable, mapper MappingBool2RuneFunc) RuneObservable {
	return MapBool2RuneObservable(parent, func(RuneObserver) MappingBool2RuneFunc {
		return mapper
	})
}

func MapBool2RuneObserveNext(parent BoolObservable, mapper func(bool) rune) RuneObservable {
	return MapBool2RuneObservable(parent, func(RuneObserver) MappingBool2RuneFunc {
		return func(next bool, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Rune struct {
	parent BoolObservable
	mapper func(bool) RuneObservable
}

func (f *flatMapBool2Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *BoolStream) MapRune(f func(bool) rune) *RuneStream {
	return FromRuneObservable(MapBool2RuneObserveNext(s, f))
}

func (s *BoolStream) FlatMapRune(f func(bool) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapBool2Rune{s, f}}
}

type MappingBool2ByteFunc func(next bool, err error, complete bool, observer ByteObserver)
type MappingBool2ByteFuncFactory func(observer ByteObserver) MappingBool2ByteFunc

type MappingBool2ByteObservable struct {
	parent BoolObservable
	mapper MappingBool2ByteFuncFactory
}

func (f *MappingBool2ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2ByteObservable(parent BoolObservable, mapper MappingBool2ByteFuncFactory) ByteObservable {
	return &MappingBool2ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2ByteObserveDirect(parent BoolObservable, mapper MappingBool2ByteFunc) ByteObservable {
	return MapBool2ByteObservable(parent, func(ByteObserver) MappingBool2ByteFunc {
		return mapper
	})
}

func MapBool2ByteObserveNext(parent BoolObservable, mapper func(bool) byte) ByteObservable {
	return MapBool2ByteObservable(parent, func(ByteObserver) MappingBool2ByteFunc {
		return func(next bool, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Byte struct {
	parent BoolObservable
	mapper func(bool) ByteObservable
}

func (f *flatMapBool2Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *BoolStream) MapByte(f func(bool) byte) *ByteStream {
	return FromByteObservable(MapBool2ByteObserveNext(s, f))
}

func (s *BoolStream) FlatMapByte(f func(bool) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapBool2Byte{s, f}}
}

type MappingBool2StringFunc func(next bool, err error, complete bool, observer StringObserver)
type MappingBool2StringFuncFactory func(observer StringObserver) MappingBool2StringFunc

type MappingBool2StringObservable struct {
	parent BoolObservable
	mapper MappingBool2StringFuncFactory
}

func (f *MappingBool2StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2StringObservable(parent BoolObservable, mapper MappingBool2StringFuncFactory) StringObservable {
	return &MappingBool2StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2StringObserveDirect(parent BoolObservable, mapper MappingBool2StringFunc) StringObservable {
	return MapBool2StringObservable(parent, func(StringObserver) MappingBool2StringFunc {
		return mapper
	})
}

func MapBool2StringObserveNext(parent BoolObservable, mapper func(bool) string) StringObservable {
	return MapBool2StringObservable(parent, func(StringObserver) MappingBool2StringFunc {
		return func(next bool, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2String struct {
	parent BoolObservable
	mapper func(bool) StringObservable
}

func (f *flatMapBool2String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *BoolStream) MapString(f func(bool) string) *StringStream {
	return FromStringObservable(MapBool2StringObserveNext(s, f))
}

func (s *BoolStream) FlatMapString(f func(bool) StringObservable) *StringStream {
	return &StringStream{&flatMapBool2String{s, f}}
}

type MappingBool2UintFunc func(next bool, err error, complete bool, observer UintObserver)
type MappingBool2UintFuncFactory func(observer UintObserver) MappingBool2UintFunc

type MappingBool2UintObservable struct {
	parent BoolObservable
	mapper MappingBool2UintFuncFactory
}

func (f *MappingBool2UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2UintObservable(parent BoolObservable, mapper MappingBool2UintFuncFactory) UintObservable {
	return &MappingBool2UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2UintObserveDirect(parent BoolObservable, mapper MappingBool2UintFunc) UintObservable {
	return MapBool2UintObservable(parent, func(UintObserver) MappingBool2UintFunc {
		return mapper
	})
}

func MapBool2UintObserveNext(parent BoolObservable, mapper func(bool) uint) UintObservable {
	return MapBool2UintObservable(parent, func(UintObserver) MappingBool2UintFunc {
		return func(next bool, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Uint struct {
	parent BoolObservable
	mapper func(bool) UintObservable
}

func (f *flatMapBool2Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *BoolStream) MapUint(f func(bool) uint) *UintStream {
	return FromUintObservable(MapBool2UintObserveNext(s, f))
}

func (s *BoolStream) FlatMapUint(f func(bool) UintObservable) *UintStream {
	return &UintStream{&flatMapBool2Uint{s, f}}
}

type MappingBool2IntFunc func(next bool, err error, complete bool, observer IntObserver)
type MappingBool2IntFuncFactory func(observer IntObserver) MappingBool2IntFunc

type MappingBool2IntObservable struct {
	parent BoolObservable
	mapper MappingBool2IntFuncFactory
}

func (f *MappingBool2IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2IntObservable(parent BoolObservable, mapper MappingBool2IntFuncFactory) IntObservable {
	return &MappingBool2IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2IntObserveDirect(parent BoolObservable, mapper MappingBool2IntFunc) IntObservable {
	return MapBool2IntObservable(parent, func(IntObserver) MappingBool2IntFunc {
		return mapper
	})
}

func MapBool2IntObserveNext(parent BoolObservable, mapper func(bool) int) IntObservable {
	return MapBool2IntObservable(parent, func(IntObserver) MappingBool2IntFunc {
		return func(next bool, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Int struct {
	parent BoolObservable
	mapper func(bool) IntObservable
}

func (f *flatMapBool2Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *BoolStream) MapInt(f func(bool) int) *IntStream {
	return FromIntObservable(MapBool2IntObserveNext(s, f))
}

func (s *BoolStream) FlatMapInt(f func(bool) IntObservable) *IntStream {
	return &IntStream{&flatMapBool2Int{s, f}}
}

type MappingBool2Uint8Func func(next bool, err error, complete bool, observer Uint8Observer)
type MappingBool2Uint8FuncFactory func(observer Uint8Observer) MappingBool2Uint8Func

type MappingBool2Uint8Observable struct {
	parent BoolObservable
	mapper MappingBool2Uint8FuncFactory
}

func (f *MappingBool2Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2Uint8Observable(parent BoolObservable, mapper MappingBool2Uint8FuncFactory) Uint8Observable {
	return &MappingBool2Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2Uint8ObserveDirect(parent BoolObservable, mapper MappingBool2Uint8Func) Uint8Observable {
	return MapBool2Uint8Observable(parent, func(Uint8Observer) MappingBool2Uint8Func {
		return mapper
	})
}

func MapBool2Uint8ObserveNext(parent BoolObservable, mapper func(bool) uint8) Uint8Observable {
	return MapBool2Uint8Observable(parent, func(Uint8Observer) MappingBool2Uint8Func {
		return func(next bool, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Uint8 struct {
	parent BoolObservable
	mapper func(bool) Uint8Observable
}

func (f *flatMapBool2Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *BoolStream) MapUint8(f func(bool) uint8) *Uint8Stream {
	return FromUint8Observable(MapBool2Uint8ObserveNext(s, f))
}

func (s *BoolStream) FlatMapUint8(f func(bool) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapBool2Uint8{s, f}}
}

type MappingBool2Int8Func func(next bool, err error, complete bool, observer Int8Observer)
type MappingBool2Int8FuncFactory func(observer Int8Observer) MappingBool2Int8Func

type MappingBool2Int8Observable struct {
	parent BoolObservable
	mapper MappingBool2Int8FuncFactory
}

func (f *MappingBool2Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2Int8Observable(parent BoolObservable, mapper MappingBool2Int8FuncFactory) Int8Observable {
	return &MappingBool2Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2Int8ObserveDirect(parent BoolObservable, mapper MappingBool2Int8Func) Int8Observable {
	return MapBool2Int8Observable(parent, func(Int8Observer) MappingBool2Int8Func {
		return mapper
	})
}

func MapBool2Int8ObserveNext(parent BoolObservable, mapper func(bool) int8) Int8Observable {
	return MapBool2Int8Observable(parent, func(Int8Observer) MappingBool2Int8Func {
		return func(next bool, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Int8 struct {
	parent BoolObservable
	mapper func(bool) Int8Observable
}

func (f *flatMapBool2Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *BoolStream) MapInt8(f func(bool) int8) *Int8Stream {
	return FromInt8Observable(MapBool2Int8ObserveNext(s, f))
}

func (s *BoolStream) FlatMapInt8(f func(bool) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapBool2Int8{s, f}}
}

type MappingBool2Uint16Func func(next bool, err error, complete bool, observer Uint16Observer)
type MappingBool2Uint16FuncFactory func(observer Uint16Observer) MappingBool2Uint16Func

type MappingBool2Uint16Observable struct {
	parent BoolObservable
	mapper MappingBool2Uint16FuncFactory
}

func (f *MappingBool2Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2Uint16Observable(parent BoolObservable, mapper MappingBool2Uint16FuncFactory) Uint16Observable {
	return &MappingBool2Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2Uint16ObserveDirect(parent BoolObservable, mapper MappingBool2Uint16Func) Uint16Observable {
	return MapBool2Uint16Observable(parent, func(Uint16Observer) MappingBool2Uint16Func {
		return mapper
	})
}

func MapBool2Uint16ObserveNext(parent BoolObservable, mapper func(bool) uint16) Uint16Observable {
	return MapBool2Uint16Observable(parent, func(Uint16Observer) MappingBool2Uint16Func {
		return func(next bool, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Uint16 struct {
	parent BoolObservable
	mapper func(bool) Uint16Observable
}

func (f *flatMapBool2Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *BoolStream) MapUint16(f func(bool) uint16) *Uint16Stream {
	return FromUint16Observable(MapBool2Uint16ObserveNext(s, f))
}

func (s *BoolStream) FlatMapUint16(f func(bool) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapBool2Uint16{s, f}}
}

type MappingBool2Int16Func func(next bool, err error, complete bool, observer Int16Observer)
type MappingBool2Int16FuncFactory func(observer Int16Observer) MappingBool2Int16Func

type MappingBool2Int16Observable struct {
	parent BoolObservable
	mapper MappingBool2Int16FuncFactory
}

func (f *MappingBool2Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2Int16Observable(parent BoolObservable, mapper MappingBool2Int16FuncFactory) Int16Observable {
	return &MappingBool2Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2Int16ObserveDirect(parent BoolObservable, mapper MappingBool2Int16Func) Int16Observable {
	return MapBool2Int16Observable(parent, func(Int16Observer) MappingBool2Int16Func {
		return mapper
	})
}

func MapBool2Int16ObserveNext(parent BoolObservable, mapper func(bool) int16) Int16Observable {
	return MapBool2Int16Observable(parent, func(Int16Observer) MappingBool2Int16Func {
		return func(next bool, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Int16 struct {
	parent BoolObservable
	mapper func(bool) Int16Observable
}

func (f *flatMapBool2Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *BoolStream) MapInt16(f func(bool) int16) *Int16Stream {
	return FromInt16Observable(MapBool2Int16ObserveNext(s, f))
}

func (s *BoolStream) FlatMapInt16(f func(bool) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapBool2Int16{s, f}}
}

type MappingBool2Uint32Func func(next bool, err error, complete bool, observer Uint32Observer)
type MappingBool2Uint32FuncFactory func(observer Uint32Observer) MappingBool2Uint32Func

type MappingBool2Uint32Observable struct {
	parent BoolObservable
	mapper MappingBool2Uint32FuncFactory
}

func (f *MappingBool2Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2Uint32Observable(parent BoolObservable, mapper MappingBool2Uint32FuncFactory) Uint32Observable {
	return &MappingBool2Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2Uint32ObserveDirect(parent BoolObservable, mapper MappingBool2Uint32Func) Uint32Observable {
	return MapBool2Uint32Observable(parent, func(Uint32Observer) MappingBool2Uint32Func {
		return mapper
	})
}

func MapBool2Uint32ObserveNext(parent BoolObservable, mapper func(bool) uint32) Uint32Observable {
	return MapBool2Uint32Observable(parent, func(Uint32Observer) MappingBool2Uint32Func {
		return func(next bool, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Uint32 struct {
	parent BoolObservable
	mapper func(bool) Uint32Observable
}

func (f *flatMapBool2Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *BoolStream) MapUint32(f func(bool) uint32) *Uint32Stream {
	return FromUint32Observable(MapBool2Uint32ObserveNext(s, f))
}

func (s *BoolStream) FlatMapUint32(f func(bool) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapBool2Uint32{s, f}}
}

type MappingBool2Int32Func func(next bool, err error, complete bool, observer Int32Observer)
type MappingBool2Int32FuncFactory func(observer Int32Observer) MappingBool2Int32Func

type MappingBool2Int32Observable struct {
	parent BoolObservable
	mapper MappingBool2Int32FuncFactory
}

func (f *MappingBool2Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2Int32Observable(parent BoolObservable, mapper MappingBool2Int32FuncFactory) Int32Observable {
	return &MappingBool2Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2Int32ObserveDirect(parent BoolObservable, mapper MappingBool2Int32Func) Int32Observable {
	return MapBool2Int32Observable(parent, func(Int32Observer) MappingBool2Int32Func {
		return mapper
	})
}

func MapBool2Int32ObserveNext(parent BoolObservable, mapper func(bool) int32) Int32Observable {
	return MapBool2Int32Observable(parent, func(Int32Observer) MappingBool2Int32Func {
		return func(next bool, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Int32 struct {
	parent BoolObservable
	mapper func(bool) Int32Observable
}

func (f *flatMapBool2Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *BoolStream) MapInt32(f func(bool) int32) *Int32Stream {
	return FromInt32Observable(MapBool2Int32ObserveNext(s, f))
}

func (s *BoolStream) FlatMapInt32(f func(bool) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapBool2Int32{s, f}}
}

type MappingBool2Uint64Func func(next bool, err error, complete bool, observer Uint64Observer)
type MappingBool2Uint64FuncFactory func(observer Uint64Observer) MappingBool2Uint64Func

type MappingBool2Uint64Observable struct {
	parent BoolObservable
	mapper MappingBool2Uint64FuncFactory
}

func (f *MappingBool2Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2Uint64Observable(parent BoolObservable, mapper MappingBool2Uint64FuncFactory) Uint64Observable {
	return &MappingBool2Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2Uint64ObserveDirect(parent BoolObservable, mapper MappingBool2Uint64Func) Uint64Observable {
	return MapBool2Uint64Observable(parent, func(Uint64Observer) MappingBool2Uint64Func {
		return mapper
	})
}

func MapBool2Uint64ObserveNext(parent BoolObservable, mapper func(bool) uint64) Uint64Observable {
	return MapBool2Uint64Observable(parent, func(Uint64Observer) MappingBool2Uint64Func {
		return func(next bool, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Uint64 struct {
	parent BoolObservable
	mapper func(bool) Uint64Observable
}

func (f *flatMapBool2Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *BoolStream) MapUint64(f func(bool) uint64) *Uint64Stream {
	return FromUint64Observable(MapBool2Uint64ObserveNext(s, f))
}

func (s *BoolStream) FlatMapUint64(f func(bool) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapBool2Uint64{s, f}}
}

type MappingBool2Int64Func func(next bool, err error, complete bool, observer Int64Observer)
type MappingBool2Int64FuncFactory func(observer Int64Observer) MappingBool2Int64Func

type MappingBool2Int64Observable struct {
	parent BoolObservable
	mapper MappingBool2Int64FuncFactory
}

func (f *MappingBool2Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2Int64Observable(parent BoolObservable, mapper MappingBool2Int64FuncFactory) Int64Observable {
	return &MappingBool2Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2Int64ObserveDirect(parent BoolObservable, mapper MappingBool2Int64Func) Int64Observable {
	return MapBool2Int64Observable(parent, func(Int64Observer) MappingBool2Int64Func {
		return mapper
	})
}

func MapBool2Int64ObserveNext(parent BoolObservable, mapper func(bool) int64) Int64Observable {
	return MapBool2Int64Observable(parent, func(Int64Observer) MappingBool2Int64Func {
		return func(next bool, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Int64 struct {
	parent BoolObservable
	mapper func(bool) Int64Observable
}

func (f *flatMapBool2Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *BoolStream) MapInt64(f func(bool) int64) *Int64Stream {
	return FromInt64Observable(MapBool2Int64ObserveNext(s, f))
}

func (s *BoolStream) FlatMapInt64(f func(bool) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapBool2Int64{s, f}}
}

type MappingBool2Float32Func func(next bool, err error, complete bool, observer Float32Observer)
type MappingBool2Float32FuncFactory func(observer Float32Observer) MappingBool2Float32Func

type MappingBool2Float32Observable struct {
	parent BoolObservable
	mapper MappingBool2Float32FuncFactory
}

func (f *MappingBool2Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2Float32Observable(parent BoolObservable, mapper MappingBool2Float32FuncFactory) Float32Observable {
	return &MappingBool2Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2Float32ObserveDirect(parent BoolObservable, mapper MappingBool2Float32Func) Float32Observable {
	return MapBool2Float32Observable(parent, func(Float32Observer) MappingBool2Float32Func {
		return mapper
	})
}

func MapBool2Float32ObserveNext(parent BoolObservable, mapper func(bool) float32) Float32Observable {
	return MapBool2Float32Observable(parent, func(Float32Observer) MappingBool2Float32Func {
		return func(next bool, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Float32 struct {
	parent BoolObservable
	mapper func(bool) Float32Observable
}

func (f *flatMapBool2Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *BoolStream) MapFloat32(f func(bool) float32) *Float32Stream {
	return FromFloat32Observable(MapBool2Float32ObserveNext(s, f))
}

func (s *BoolStream) FlatMapFloat32(f func(bool) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapBool2Float32{s, f}}
}

type MappingBool2Float64Func func(next bool, err error, complete bool, observer Float64Observer)
type MappingBool2Float64FuncFactory func(observer Float64Observer) MappingBool2Float64Func

type MappingBool2Float64Observable struct {
	parent BoolObservable
	mapper MappingBool2Float64FuncFactory
}

func (f *MappingBool2Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2Float64Observable(parent BoolObservable, mapper MappingBool2Float64FuncFactory) Float64Observable {
	return &MappingBool2Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2Float64ObserveDirect(parent BoolObservable, mapper MappingBool2Float64Func) Float64Observable {
	return MapBool2Float64Observable(parent, func(Float64Observer) MappingBool2Float64Func {
		return mapper
	})
}

func MapBool2Float64ObserveNext(parent BoolObservable, mapper func(bool) float64) Float64Observable {
	return MapBool2Float64Observable(parent, func(Float64Observer) MappingBool2Float64Func {
		return func(next bool, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Float64 struct {
	parent BoolObservable
	mapper func(bool) Float64Observable
}

func (f *flatMapBool2Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *BoolStream) MapFloat64(f func(bool) float64) *Float64Stream {
	return FromFloat64Observable(MapBool2Float64ObserveNext(s, f))
}

func (s *BoolStream) FlatMapFloat64(f func(bool) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapBool2Float64{s, f}}
}

type MappingBool2Complex64Func func(next bool, err error, complete bool, observer Complex64Observer)
type MappingBool2Complex64FuncFactory func(observer Complex64Observer) MappingBool2Complex64Func

type MappingBool2Complex64Observable struct {
	parent BoolObservable
	mapper MappingBool2Complex64FuncFactory
}

func (f *MappingBool2Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2Complex64Observable(parent BoolObservable, mapper MappingBool2Complex64FuncFactory) Complex64Observable {
	return &MappingBool2Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2Complex64ObserveDirect(parent BoolObservable, mapper MappingBool2Complex64Func) Complex64Observable {
	return MapBool2Complex64Observable(parent, func(Complex64Observer) MappingBool2Complex64Func {
		return mapper
	})
}

func MapBool2Complex64ObserveNext(parent BoolObservable, mapper func(bool) complex64) Complex64Observable {
	return MapBool2Complex64Observable(parent, func(Complex64Observer) MappingBool2Complex64Func {
		return func(next bool, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Complex64 struct {
	parent BoolObservable
	mapper func(bool) Complex64Observable
}

func (f *flatMapBool2Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *BoolStream) MapComplex64(f func(bool) complex64) *Complex64Stream {
	return FromComplex64Observable(MapBool2Complex64ObserveNext(s, f))
}

func (s *BoolStream) FlatMapComplex64(f func(bool) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapBool2Complex64{s, f}}
}

type MappingBool2Complex128Func func(next bool, err error, complete bool, observer Complex128Observer)
type MappingBool2Complex128FuncFactory func(observer Complex128Observer) MappingBool2Complex128Func

type MappingBool2Complex128Observable struct {
	parent BoolObservable
	mapper MappingBool2Complex128FuncFactory
}

func (f *MappingBool2Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2Complex128Observable(parent BoolObservable, mapper MappingBool2Complex128FuncFactory) Complex128Observable {
	return &MappingBool2Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2Complex128ObserveDirect(parent BoolObservable, mapper MappingBool2Complex128Func) Complex128Observable {
	return MapBool2Complex128Observable(parent, func(Complex128Observer) MappingBool2Complex128Func {
		return mapper
	})
}

func MapBool2Complex128ObserveNext(parent BoolObservable, mapper func(bool) complex128) Complex128Observable {
	return MapBool2Complex128Observable(parent, func(Complex128Observer) MappingBool2Complex128Func {
		return func(next bool, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Complex128 struct {
	parent BoolObservable
	mapper func(bool) Complex128Observable
}

func (f *flatMapBool2Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *BoolStream) MapComplex128(f func(bool) complex128) *Complex128Stream {
	return FromComplex128Observable(MapBool2Complex128ObserveNext(s, f))
}

func (s *BoolStream) FlatMapComplex128(f func(bool) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapBool2Complex128{s, f}}
}

type MappingBool2TimeFunc func(next bool, err error, complete bool, observer TimeObserver)
type MappingBool2TimeFuncFactory func(observer TimeObserver) MappingBool2TimeFunc

type MappingBool2TimeObservable struct {
	parent BoolObservable
	mapper MappingBool2TimeFuncFactory
}

func (f *MappingBool2TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2TimeObservable(parent BoolObservable, mapper MappingBool2TimeFuncFactory) TimeObservable {
	return &MappingBool2TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2TimeObserveDirect(parent BoolObservable, mapper MappingBool2TimeFunc) TimeObservable {
	return MapBool2TimeObservable(parent, func(TimeObserver) MappingBool2TimeFunc {
		return mapper
	})
}

func MapBool2TimeObserveNext(parent BoolObservable, mapper func(bool) time.Time) TimeObservable {
	return MapBool2TimeObservable(parent, func(TimeObserver) MappingBool2TimeFunc {
		return func(next bool, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Time struct {
	parent BoolObservable
	mapper func(bool) TimeObservable
}

func (f *flatMapBool2Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *BoolStream) MapTime(f func(bool) time.Time) *TimeStream {
	return FromTimeObservable(MapBool2TimeObserveNext(s, f))
}

func (s *BoolStream) FlatMapTime(f func(bool) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapBool2Time{s, f}}
}

type MappingBool2DurationFunc func(next bool, err error, complete bool, observer DurationObserver)
type MappingBool2DurationFuncFactory func(observer DurationObserver) MappingBool2DurationFunc

type MappingBool2DurationObservable struct {
	parent BoolObservable
	mapper MappingBool2DurationFuncFactory
}

func (f *MappingBool2DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapBool2DurationObservable(parent BoolObservable, mapper MappingBool2DurationFuncFactory) DurationObservable {
	return &MappingBool2DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapBool2DurationObserveDirect(parent BoolObservable, mapper MappingBool2DurationFunc) DurationObservable {
	return MapBool2DurationObservable(parent, func(DurationObserver) MappingBool2DurationFunc {
		return mapper
	})
}

func MapBool2DurationObserveNext(parent BoolObservable, mapper func(bool) time.Duration) DurationObservable {
	return MapBool2DurationObservable(parent, func(DurationObserver) MappingBool2DurationFunc {
		return func(next bool, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapBool2Duration struct {
	parent BoolObservable
	mapper func(bool) DurationObservable
}

func (f *flatMapBool2Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(BoolObserverFunc(func(next bool, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *BoolStream) MapDuration(f func(bool) time.Duration) *DurationStream {
	return FromDurationObservable(MapBool2DurationObserveNext(s, f))
}

func (s *BoolStream) FlatMapDuration(f func(bool) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapBool2Duration{s, f}}
}

type RuneObserver interface {
	Next(rune)
	TerminationObserver
}

// A RuneSubscriber represents a subscribed RuneObserver.
type RuneSubscriber interface {
	Subscription
	RuneObserver
}

type implRuneSubscriber struct {
	Subscription
	RuneObserver
}

func RuneObserverAsGenericObserver(observer RuneObserver) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(rune))
		}
	})
}

func GenericObserverAsRuneObserver(observer GenericObserver) RuneObserver {
	return RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type RuneObservableFactory func(observer RuneObserver, subscription Subscription)

func (f RuneObservableFactory) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateRune calls f(observer, subscription) to produce values for a stream.
func CreateRune(f func(observer RuneObserver, subscription Subscription)) *RuneStream {
	return FromRuneObservable(RuneObservableFactory(f))
}

// Repeat value count times.
func RepeatRune(value rune, count int) *RuneStream {
	return CreateRune(func(observer RuneObserver, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartRune is designed to be used with functions that return a
// (rune, error) tuple.
//
// If the error is non-nil the returned RuneStream will be that error,
// otherwise it will be a single-value stream of rune.
func StartRune(f func() (rune, error)) *RuneStream {
	return CreateRune(func(observer RuneObserver, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughRune(next rune, err error, complete bool, observer RuneObserver) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroRune = *new(rune)

type RuneObserverFunc func(rune, error, bool)

func (f RuneObserverFunc) Next(next rune)  { f(next, nil, false) }
func (f RuneObserverFunc) Error(err error) { f(zeroRune, err, false) }
func (f RuneObserverFunc) Complete()       { f(zeroRune, nil, true) }

type RuneObservable interface {
	Subscribe(RuneObserver) Subscription
}

// Convert a GenericObservableFilter to a RuneObservable
func (f GenericObservableFilterFactory) Rune(parent RuneObservable) RuneObservable {
	return MapRune2RuneObservable(parent, func(observer RuneObserver) MappingRune2RuneFunc {
		gobserver := RuneObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next rune, err error, complete bool, observer RuneObserver) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverRune() *RuneStream {
	return CreateRune(func(observer RuneObserver, subscription Subscription) {})
}

func EmptyRune() *RuneStream {
	return CreateRune(func(observer RuneObserver, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowRune(err error) *RuneStream {
	return CreateRune(func(observer RuneObserver, subscription Subscription) {
		observer.Error(err)
	})
}

func FromRuneArray(array []rune) *RuneStream {
	return CreateRune(func(observer RuneObserver, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromRunes(array ...rune) *RuneStream {
	return FromRuneArray(array)
}

func JustRune(element rune) *RuneStream {
	return FromRuneArray([]rune{element})
}

func MergeRune(observables ...RuneObservable) *RuneStream {
	if len(observables) == 0 {
		return EmptyRune()
	}
	return (&RuneStream{observables[0]}).Merge(observables[1:]...)
}

func MergeRuneDelayError(observables ...RuneObservable) *RuneStream {
	if len(observables) == 0 {
		return EmptyRune()
	}
	return (&RuneStream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromRuneChannel(ch <-chan rune) *RuneStream {
	return CreateRune(func(observer RuneObserver, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type RuneStream struct {
	RuneObservable
}

func FromRuneObservable(observable RuneObservable) *RuneStream {
	return &RuneStream{observable}
}

func (s *RuneStream) SubscribeFunc(f func(rune, error, bool)) Subscription {
	return s.Subscribe(RuneObserverFunc(f))
}

func (s *RuneStream) SubscribeNext(f func(v rune)) Subscription {
	return s.SubscribeFunc(func(next rune, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *RuneStream) Distinct() *RuneStream {
	return FromRuneObservable(distinctFilter().Rune(s))
}

// ElementAt yields the Nth element of the stream.
func (s *RuneStream) ElementAt(n int) *RuneStream {
	return FromRuneObservable(elementAtFilter(n).Rune(s))
}

// Filter elements in the stream on a function.
func (s *RuneStream) Filter(f func(rune) bool) *RuneStream {
	return FromRuneObservable(filterFilter(func(v interface{}) bool { return f(v.(rune)) }).Rune(s))
}

// Last returns just the first element of the stream.
func (s *RuneStream) First() *RuneStream {
	return FromRuneObservable(firstFilter().Rune(s))
}

// Last returns just the last element of the stream.
func (s *RuneStream) Last() *RuneStream {
	return FromRuneObservable(lastFilter().Rune(s))
}

// SkipLast skips the first N elements of the stream.
func (s *RuneStream) Skip(n int) *RuneStream {
	return FromRuneObservable(skipFilter(n).Rune(s))
}

// SkipLast skips the last N elements of the stream.
func (s *RuneStream) SkipLast(n int) *RuneStream {
	return FromRuneObservable(skipLastFilter(n).Rune(s))
}

// Take returns just the first N elements of the stream.
func (s *RuneStream) Take(n int) *RuneStream {
	return FromRuneObservable(takeFilter(n).Rune(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *RuneStream) TakeLast(n int) *RuneStream {
	return FromRuneObservable(takeLastFilter(n).Rune(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *RuneStream) IgnoreElements() *RuneStream {
	return FromRuneObservable(ignoreElementsFilter().Rune(s))
}

func (s *RuneStream) Replay(size int, duration time.Duration) *RuneStream {
	return FromRuneObservable(replayFilter(size, duration).Rune(s))
}

func (s *RuneStream) Sample(duration time.Duration) *RuneStream {
	return FromRuneObservable(sampleFilter(duration).Rune(s))
}

func (s *RuneStream) Debounce(duration time.Duration) *RuneStream {
	return FromRuneObservable(debounceFilter(duration).Rune(s))
}

// Wait for completion of the stream and return any error.
func (s *RuneStream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeRuneSubscriber(observer RuneObserver) RuneSubscriber {
	if subscriber, ok := observer.(RuneSubscriber); ok {
		return subscriber
	}
	return &implRuneSubscriber{NewGenericSubscription(), observer}
}

type concatRuneSubscriber struct {
	observable  int
	observer    RuneObserver
	observables []RuneObservable
	Subscription
}

func (c *concatRuneSubscriber) Next(next rune) {
	c.observer.Next(next)
}

func (c *concatRuneSubscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatRuneSubscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatRuneObservable struct {
	observables []RuneObservable
}

func (m *concatRuneObservable) Subscribe(observer RuneObserver) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatRuneSubscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *RuneStream) Concat(observables ...RuneObservable) *RuneStream {
	return &RuneStream{&concatRuneObservable{append([]RuneObservable{s}, observables...)}}
}

type mergeRuneObservable struct {
	delayError  bool
	observables []RuneObservable
}

func (m *mergeRuneObservable) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next rune, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(RuneObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *RuneStream) Merge(other ...RuneObservable) *RuneStream {
	if len(other) == 0 {
		return s
	}
	return &RuneStream{&mergeRuneObservable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *RuneStream) MergeDelayError(other ...RuneObservable) *RuneStream {
	if len(other) == 0 {
		return s
	}
	return &RuneStream{&mergeRuneObservable{true, append(other, s)}}
}

type catchRuneObservable struct {
	parent RuneObservable
	catch  RuneObservable
}

func (r *catchRuneObservable) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	run := func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(RuneObserverFunc(run))
	return subscription
}

func (s *RuneStream) Catch(catch RuneObservable) *RuneStream {
	return &RuneStream{&catchRuneObservable{s, catch}}
}

type retryRuneObservable struct {
	observable RuneObservable
}

type retryRuneObserver struct {
	observable RuneObservable
	observer   RuneObserver
}

func (r *retryRuneObserver) retry(next rune, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(RuneObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryRuneObservable) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryRuneObserver{r.observable, observer}
	r.observable.Subscribe(RuneObserverFunc(ro.retry))
	return subscription
}

func (s *RuneStream) Retry() *RuneStream {
	return &RuneStream{&retryRuneObservable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *RuneStream) Do(f func(next rune)) *RuneStream {
	return FromRuneObservable(MapRune2RuneObserveNext(s, func(next rune) rune {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *RuneStream) DoOnError(f func(err error)) *RuneStream {
	return FromRuneObservable(MapRune2RuneObserveDirect(s, func(next rune, err error, complete bool, observer RuneObserver) {
		if err != nil {
			f(err)
		}
		PassthroughRune(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *RuneStream) DoOnComplete(f func()) *RuneStream {
	return FromRuneObservable(MapRune2RuneObserveDirect(s, func(next rune, err error, complete bool, observer RuneObserver) {
		if complete {
			f()
		}
		PassthroughRune(next, err, complete, observer)
	}))
}

func (s *RuneStream) Reduce(initial rune, reducer func(rune, rune) rune) *RuneStream {
	value := initial
	return FromRuneObservable(MapRune2RuneObserveDirect(s, func(next rune, err error, complete bool, observer RuneObserver) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *RuneStream) Scan(initial rune, f func(rune, rune) rune) *RuneStream {
	value := initial
	return FromRuneObservable(MapRune2RuneObserveDirect(s, func(next rune, err error, complete bool, observer RuneObserver) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutRune struct {
	parent  RuneObservable
	timeout time.Duration
}

func (t *timeoutRune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *RuneStream) Timeout(timeout time.Duration) *RuneStream {
	return &RuneStream{&timeoutRune{s, timeout}}
}

type forkedRuneStream struct {
	lock      sync.Mutex
	parent    RuneObservable
	observers []RuneObserver
}

func (f *forkedRuneStream) Subscribe(observer RuneObserver) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *RuneStream) Fork() *RuneStream {
	f := &forkedRuneStream{parent: s}
	go s.Subscribe(RuneObserverFunc(func(n rune, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &RuneStream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *RuneStream) ToOneWithError() (rune, error) {
	valuech := make(chan rune, 1)
	errch := make(chan error, 1)
	FromRuneObservable(oneFilter().Rune(s)).SubscribeFunc(func(next rune, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroRune, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *RuneStream) ToOne() rune {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *RuneStream) ToArrayWithError() ([]rune, error) {
	array := []rune{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *RuneStream) ToArray() []rune {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *RuneStream) ToChannelWithError() (<-chan rune, <-chan error) {
	ch := make(chan rune, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *RuneStream) ToChannel() <-chan rune {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *RuneStream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapRune2IntObserveDirect(s, func(next rune, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

type MappingRune2BoolFunc func(next rune, err error, complete bool, observer BoolObserver)
type MappingRune2BoolFuncFactory func(observer BoolObserver) MappingRune2BoolFunc

type MappingRune2BoolObservable struct {
	parent RuneObservable
	mapper MappingRune2BoolFuncFactory
}

func (f *MappingRune2BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2BoolObservable(parent RuneObservable, mapper MappingRune2BoolFuncFactory) BoolObservable {
	return &MappingRune2BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2BoolObserveDirect(parent RuneObservable, mapper MappingRune2BoolFunc) BoolObservable {
	return MapRune2BoolObservable(parent, func(BoolObserver) MappingRune2BoolFunc {
		return mapper
	})
}

func MapRune2BoolObserveNext(parent RuneObservable, mapper func(rune) bool) BoolObservable {
	return MapRune2BoolObservable(parent, func(BoolObserver) MappingRune2BoolFunc {
		return func(next rune, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Bool struct {
	parent RuneObservable
	mapper func(rune) BoolObservable
}

func (f *flatMapRune2Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *RuneStream) MapBool(f func(rune) bool) *BoolStream {
	return FromBoolObservable(MapRune2BoolObserveNext(s, f))
}

func (s *RuneStream) FlatMapBool(f func(rune) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapRune2Bool{s, f}}
}

type MappingRune2RuneFunc func(next rune, err error, complete bool, observer RuneObserver)
type MappingRune2RuneFuncFactory func(observer RuneObserver) MappingRune2RuneFunc

type MappingRune2RuneObservable struct {
	parent RuneObservable
	mapper MappingRune2RuneFuncFactory
}

func (f *MappingRune2RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2RuneObservable(parent RuneObservable, mapper MappingRune2RuneFuncFactory) RuneObservable {
	return &MappingRune2RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2RuneObserveDirect(parent RuneObservable, mapper MappingRune2RuneFunc) RuneObservable {
	return MapRune2RuneObservable(parent, func(RuneObserver) MappingRune2RuneFunc {
		return mapper
	})
}

func MapRune2RuneObserveNext(parent RuneObservable, mapper func(rune) rune) RuneObservable {
	return MapRune2RuneObservable(parent, func(RuneObserver) MappingRune2RuneFunc {
		return func(next rune, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Rune struct {
	parent RuneObservable
	mapper func(rune) RuneObservable
}

func (f *flatMapRune2Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *RuneStream) Map(f func(rune) rune) *RuneStream {
	return FromRuneObservable(MapRune2RuneObserveNext(s, f))
}

func (s *RuneStream) FlatMap(f func(rune) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapRune2Rune{s, f}}
}

type MappingRune2ByteFunc func(next rune, err error, complete bool, observer ByteObserver)
type MappingRune2ByteFuncFactory func(observer ByteObserver) MappingRune2ByteFunc

type MappingRune2ByteObservable struct {
	parent RuneObservable
	mapper MappingRune2ByteFuncFactory
}

func (f *MappingRune2ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2ByteObservable(parent RuneObservable, mapper MappingRune2ByteFuncFactory) ByteObservable {
	return &MappingRune2ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2ByteObserveDirect(parent RuneObservable, mapper MappingRune2ByteFunc) ByteObservable {
	return MapRune2ByteObservable(parent, func(ByteObserver) MappingRune2ByteFunc {
		return mapper
	})
}

func MapRune2ByteObserveNext(parent RuneObservable, mapper func(rune) byte) ByteObservable {
	return MapRune2ByteObservable(parent, func(ByteObserver) MappingRune2ByteFunc {
		return func(next rune, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Byte struct {
	parent RuneObservable
	mapper func(rune) ByteObservable
}

func (f *flatMapRune2Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *RuneStream) MapByte(f func(rune) byte) *ByteStream {
	return FromByteObservable(MapRune2ByteObserveNext(s, f))
}

func (s *RuneStream) FlatMapByte(f func(rune) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapRune2Byte{s, f}}
}

type MappingRune2StringFunc func(next rune, err error, complete bool, observer StringObserver)
type MappingRune2StringFuncFactory func(observer StringObserver) MappingRune2StringFunc

type MappingRune2StringObservable struct {
	parent RuneObservable
	mapper MappingRune2StringFuncFactory
}

func (f *MappingRune2StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2StringObservable(parent RuneObservable, mapper MappingRune2StringFuncFactory) StringObservable {
	return &MappingRune2StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2StringObserveDirect(parent RuneObservable, mapper MappingRune2StringFunc) StringObservable {
	return MapRune2StringObservable(parent, func(StringObserver) MappingRune2StringFunc {
		return mapper
	})
}

func MapRune2StringObserveNext(parent RuneObservable, mapper func(rune) string) StringObservable {
	return MapRune2StringObservable(parent, func(StringObserver) MappingRune2StringFunc {
		return func(next rune, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2String struct {
	parent RuneObservable
	mapper func(rune) StringObservable
}

func (f *flatMapRune2String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *RuneStream) MapString(f func(rune) string) *StringStream {
	return FromStringObservable(MapRune2StringObserveNext(s, f))
}

func (s *RuneStream) FlatMapString(f func(rune) StringObservable) *StringStream {
	return &StringStream{&flatMapRune2String{s, f}}
}

type MappingRune2UintFunc func(next rune, err error, complete bool, observer UintObserver)
type MappingRune2UintFuncFactory func(observer UintObserver) MappingRune2UintFunc

type MappingRune2UintObservable struct {
	parent RuneObservable
	mapper MappingRune2UintFuncFactory
}

func (f *MappingRune2UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2UintObservable(parent RuneObservable, mapper MappingRune2UintFuncFactory) UintObservable {
	return &MappingRune2UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2UintObserveDirect(parent RuneObservable, mapper MappingRune2UintFunc) UintObservable {
	return MapRune2UintObservable(parent, func(UintObserver) MappingRune2UintFunc {
		return mapper
	})
}

func MapRune2UintObserveNext(parent RuneObservable, mapper func(rune) uint) UintObservable {
	return MapRune2UintObservable(parent, func(UintObserver) MappingRune2UintFunc {
		return func(next rune, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Uint struct {
	parent RuneObservable
	mapper func(rune) UintObservable
}

func (f *flatMapRune2Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *RuneStream) MapUint(f func(rune) uint) *UintStream {
	return FromUintObservable(MapRune2UintObserveNext(s, f))
}

func (s *RuneStream) FlatMapUint(f func(rune) UintObservable) *UintStream {
	return &UintStream{&flatMapRune2Uint{s, f}}
}

type MappingRune2IntFunc func(next rune, err error, complete bool, observer IntObserver)
type MappingRune2IntFuncFactory func(observer IntObserver) MappingRune2IntFunc

type MappingRune2IntObservable struct {
	parent RuneObservable
	mapper MappingRune2IntFuncFactory
}

func (f *MappingRune2IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2IntObservable(parent RuneObservable, mapper MappingRune2IntFuncFactory) IntObservable {
	return &MappingRune2IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2IntObserveDirect(parent RuneObservable, mapper MappingRune2IntFunc) IntObservable {
	return MapRune2IntObservable(parent, func(IntObserver) MappingRune2IntFunc {
		return mapper
	})
}

func MapRune2IntObserveNext(parent RuneObservable, mapper func(rune) int) IntObservable {
	return MapRune2IntObservable(parent, func(IntObserver) MappingRune2IntFunc {
		return func(next rune, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Int struct {
	parent RuneObservable
	mapper func(rune) IntObservable
}

func (f *flatMapRune2Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *RuneStream) MapInt(f func(rune) int) *IntStream {
	return FromIntObservable(MapRune2IntObserveNext(s, f))
}

func (s *RuneStream) FlatMapInt(f func(rune) IntObservable) *IntStream {
	return &IntStream{&flatMapRune2Int{s, f}}
}

type MappingRune2Uint8Func func(next rune, err error, complete bool, observer Uint8Observer)
type MappingRune2Uint8FuncFactory func(observer Uint8Observer) MappingRune2Uint8Func

type MappingRune2Uint8Observable struct {
	parent RuneObservable
	mapper MappingRune2Uint8FuncFactory
}

func (f *MappingRune2Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2Uint8Observable(parent RuneObservable, mapper MappingRune2Uint8FuncFactory) Uint8Observable {
	return &MappingRune2Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2Uint8ObserveDirect(parent RuneObservable, mapper MappingRune2Uint8Func) Uint8Observable {
	return MapRune2Uint8Observable(parent, func(Uint8Observer) MappingRune2Uint8Func {
		return mapper
	})
}

func MapRune2Uint8ObserveNext(parent RuneObservable, mapper func(rune) uint8) Uint8Observable {
	return MapRune2Uint8Observable(parent, func(Uint8Observer) MappingRune2Uint8Func {
		return func(next rune, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Uint8 struct {
	parent RuneObservable
	mapper func(rune) Uint8Observable
}

func (f *flatMapRune2Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *RuneStream) MapUint8(f func(rune) uint8) *Uint8Stream {
	return FromUint8Observable(MapRune2Uint8ObserveNext(s, f))
}

func (s *RuneStream) FlatMapUint8(f func(rune) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapRune2Uint8{s, f}}
}

type MappingRune2Int8Func func(next rune, err error, complete bool, observer Int8Observer)
type MappingRune2Int8FuncFactory func(observer Int8Observer) MappingRune2Int8Func

type MappingRune2Int8Observable struct {
	parent RuneObservable
	mapper MappingRune2Int8FuncFactory
}

func (f *MappingRune2Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2Int8Observable(parent RuneObservable, mapper MappingRune2Int8FuncFactory) Int8Observable {
	return &MappingRune2Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2Int8ObserveDirect(parent RuneObservable, mapper MappingRune2Int8Func) Int8Observable {
	return MapRune2Int8Observable(parent, func(Int8Observer) MappingRune2Int8Func {
		return mapper
	})
}

func MapRune2Int8ObserveNext(parent RuneObservable, mapper func(rune) int8) Int8Observable {
	return MapRune2Int8Observable(parent, func(Int8Observer) MappingRune2Int8Func {
		return func(next rune, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Int8 struct {
	parent RuneObservable
	mapper func(rune) Int8Observable
}

func (f *flatMapRune2Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *RuneStream) MapInt8(f func(rune) int8) *Int8Stream {
	return FromInt8Observable(MapRune2Int8ObserveNext(s, f))
}

func (s *RuneStream) FlatMapInt8(f func(rune) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapRune2Int8{s, f}}
}

type MappingRune2Uint16Func func(next rune, err error, complete bool, observer Uint16Observer)
type MappingRune2Uint16FuncFactory func(observer Uint16Observer) MappingRune2Uint16Func

type MappingRune2Uint16Observable struct {
	parent RuneObservable
	mapper MappingRune2Uint16FuncFactory
}

func (f *MappingRune2Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2Uint16Observable(parent RuneObservable, mapper MappingRune2Uint16FuncFactory) Uint16Observable {
	return &MappingRune2Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2Uint16ObserveDirect(parent RuneObservable, mapper MappingRune2Uint16Func) Uint16Observable {
	return MapRune2Uint16Observable(parent, func(Uint16Observer) MappingRune2Uint16Func {
		return mapper
	})
}

func MapRune2Uint16ObserveNext(parent RuneObservable, mapper func(rune) uint16) Uint16Observable {
	return MapRune2Uint16Observable(parent, func(Uint16Observer) MappingRune2Uint16Func {
		return func(next rune, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Uint16 struct {
	parent RuneObservable
	mapper func(rune) Uint16Observable
}

func (f *flatMapRune2Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *RuneStream) MapUint16(f func(rune) uint16) *Uint16Stream {
	return FromUint16Observable(MapRune2Uint16ObserveNext(s, f))
}

func (s *RuneStream) FlatMapUint16(f func(rune) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapRune2Uint16{s, f}}
}

type MappingRune2Int16Func func(next rune, err error, complete bool, observer Int16Observer)
type MappingRune2Int16FuncFactory func(observer Int16Observer) MappingRune2Int16Func

type MappingRune2Int16Observable struct {
	parent RuneObservable
	mapper MappingRune2Int16FuncFactory
}

func (f *MappingRune2Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2Int16Observable(parent RuneObservable, mapper MappingRune2Int16FuncFactory) Int16Observable {
	return &MappingRune2Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2Int16ObserveDirect(parent RuneObservable, mapper MappingRune2Int16Func) Int16Observable {
	return MapRune2Int16Observable(parent, func(Int16Observer) MappingRune2Int16Func {
		return mapper
	})
}

func MapRune2Int16ObserveNext(parent RuneObservable, mapper func(rune) int16) Int16Observable {
	return MapRune2Int16Observable(parent, func(Int16Observer) MappingRune2Int16Func {
		return func(next rune, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Int16 struct {
	parent RuneObservable
	mapper func(rune) Int16Observable
}

func (f *flatMapRune2Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *RuneStream) MapInt16(f func(rune) int16) *Int16Stream {
	return FromInt16Observable(MapRune2Int16ObserveNext(s, f))
}

func (s *RuneStream) FlatMapInt16(f func(rune) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapRune2Int16{s, f}}
}

type MappingRune2Uint32Func func(next rune, err error, complete bool, observer Uint32Observer)
type MappingRune2Uint32FuncFactory func(observer Uint32Observer) MappingRune2Uint32Func

type MappingRune2Uint32Observable struct {
	parent RuneObservable
	mapper MappingRune2Uint32FuncFactory
}

func (f *MappingRune2Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2Uint32Observable(parent RuneObservable, mapper MappingRune2Uint32FuncFactory) Uint32Observable {
	return &MappingRune2Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2Uint32ObserveDirect(parent RuneObservable, mapper MappingRune2Uint32Func) Uint32Observable {
	return MapRune2Uint32Observable(parent, func(Uint32Observer) MappingRune2Uint32Func {
		return mapper
	})
}

func MapRune2Uint32ObserveNext(parent RuneObservable, mapper func(rune) uint32) Uint32Observable {
	return MapRune2Uint32Observable(parent, func(Uint32Observer) MappingRune2Uint32Func {
		return func(next rune, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Uint32 struct {
	parent RuneObservable
	mapper func(rune) Uint32Observable
}

func (f *flatMapRune2Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *RuneStream) MapUint32(f func(rune) uint32) *Uint32Stream {
	return FromUint32Observable(MapRune2Uint32ObserveNext(s, f))
}

func (s *RuneStream) FlatMapUint32(f func(rune) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapRune2Uint32{s, f}}
}

type MappingRune2Int32Func func(next rune, err error, complete bool, observer Int32Observer)
type MappingRune2Int32FuncFactory func(observer Int32Observer) MappingRune2Int32Func

type MappingRune2Int32Observable struct {
	parent RuneObservable
	mapper MappingRune2Int32FuncFactory
}

func (f *MappingRune2Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2Int32Observable(parent RuneObservable, mapper MappingRune2Int32FuncFactory) Int32Observable {
	return &MappingRune2Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2Int32ObserveDirect(parent RuneObservable, mapper MappingRune2Int32Func) Int32Observable {
	return MapRune2Int32Observable(parent, func(Int32Observer) MappingRune2Int32Func {
		return mapper
	})
}

func MapRune2Int32ObserveNext(parent RuneObservable, mapper func(rune) int32) Int32Observable {
	return MapRune2Int32Observable(parent, func(Int32Observer) MappingRune2Int32Func {
		return func(next rune, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Int32 struct {
	parent RuneObservable
	mapper func(rune) Int32Observable
}

func (f *flatMapRune2Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *RuneStream) MapInt32(f func(rune) int32) *Int32Stream {
	return FromInt32Observable(MapRune2Int32ObserveNext(s, f))
}

func (s *RuneStream) FlatMapInt32(f func(rune) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapRune2Int32{s, f}}
}

type MappingRune2Uint64Func func(next rune, err error, complete bool, observer Uint64Observer)
type MappingRune2Uint64FuncFactory func(observer Uint64Observer) MappingRune2Uint64Func

type MappingRune2Uint64Observable struct {
	parent RuneObservable
	mapper MappingRune2Uint64FuncFactory
}

func (f *MappingRune2Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2Uint64Observable(parent RuneObservable, mapper MappingRune2Uint64FuncFactory) Uint64Observable {
	return &MappingRune2Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2Uint64ObserveDirect(parent RuneObservable, mapper MappingRune2Uint64Func) Uint64Observable {
	return MapRune2Uint64Observable(parent, func(Uint64Observer) MappingRune2Uint64Func {
		return mapper
	})
}

func MapRune2Uint64ObserveNext(parent RuneObservable, mapper func(rune) uint64) Uint64Observable {
	return MapRune2Uint64Observable(parent, func(Uint64Observer) MappingRune2Uint64Func {
		return func(next rune, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Uint64 struct {
	parent RuneObservable
	mapper func(rune) Uint64Observable
}

func (f *flatMapRune2Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *RuneStream) MapUint64(f func(rune) uint64) *Uint64Stream {
	return FromUint64Observable(MapRune2Uint64ObserveNext(s, f))
}

func (s *RuneStream) FlatMapUint64(f func(rune) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapRune2Uint64{s, f}}
}

type MappingRune2Int64Func func(next rune, err error, complete bool, observer Int64Observer)
type MappingRune2Int64FuncFactory func(observer Int64Observer) MappingRune2Int64Func

type MappingRune2Int64Observable struct {
	parent RuneObservable
	mapper MappingRune2Int64FuncFactory
}

func (f *MappingRune2Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2Int64Observable(parent RuneObservable, mapper MappingRune2Int64FuncFactory) Int64Observable {
	return &MappingRune2Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2Int64ObserveDirect(parent RuneObservable, mapper MappingRune2Int64Func) Int64Observable {
	return MapRune2Int64Observable(parent, func(Int64Observer) MappingRune2Int64Func {
		return mapper
	})
}

func MapRune2Int64ObserveNext(parent RuneObservable, mapper func(rune) int64) Int64Observable {
	return MapRune2Int64Observable(parent, func(Int64Observer) MappingRune2Int64Func {
		return func(next rune, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Int64 struct {
	parent RuneObservable
	mapper func(rune) Int64Observable
}

func (f *flatMapRune2Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *RuneStream) MapInt64(f func(rune) int64) *Int64Stream {
	return FromInt64Observable(MapRune2Int64ObserveNext(s, f))
}

func (s *RuneStream) FlatMapInt64(f func(rune) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapRune2Int64{s, f}}
}

type MappingRune2Float32Func func(next rune, err error, complete bool, observer Float32Observer)
type MappingRune2Float32FuncFactory func(observer Float32Observer) MappingRune2Float32Func

type MappingRune2Float32Observable struct {
	parent RuneObservable
	mapper MappingRune2Float32FuncFactory
}

func (f *MappingRune2Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2Float32Observable(parent RuneObservable, mapper MappingRune2Float32FuncFactory) Float32Observable {
	return &MappingRune2Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2Float32ObserveDirect(parent RuneObservable, mapper MappingRune2Float32Func) Float32Observable {
	return MapRune2Float32Observable(parent, func(Float32Observer) MappingRune2Float32Func {
		return mapper
	})
}

func MapRune2Float32ObserveNext(parent RuneObservable, mapper func(rune) float32) Float32Observable {
	return MapRune2Float32Observable(parent, func(Float32Observer) MappingRune2Float32Func {
		return func(next rune, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Float32 struct {
	parent RuneObservable
	mapper func(rune) Float32Observable
}

func (f *flatMapRune2Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *RuneStream) MapFloat32(f func(rune) float32) *Float32Stream {
	return FromFloat32Observable(MapRune2Float32ObserveNext(s, f))
}

func (s *RuneStream) FlatMapFloat32(f func(rune) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapRune2Float32{s, f}}
}

type MappingRune2Float64Func func(next rune, err error, complete bool, observer Float64Observer)
type MappingRune2Float64FuncFactory func(observer Float64Observer) MappingRune2Float64Func

type MappingRune2Float64Observable struct {
	parent RuneObservable
	mapper MappingRune2Float64FuncFactory
}

func (f *MappingRune2Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2Float64Observable(parent RuneObservable, mapper MappingRune2Float64FuncFactory) Float64Observable {
	return &MappingRune2Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2Float64ObserveDirect(parent RuneObservable, mapper MappingRune2Float64Func) Float64Observable {
	return MapRune2Float64Observable(parent, func(Float64Observer) MappingRune2Float64Func {
		return mapper
	})
}

func MapRune2Float64ObserveNext(parent RuneObservable, mapper func(rune) float64) Float64Observable {
	return MapRune2Float64Observable(parent, func(Float64Observer) MappingRune2Float64Func {
		return func(next rune, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Float64 struct {
	parent RuneObservable
	mapper func(rune) Float64Observable
}

func (f *flatMapRune2Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *RuneStream) MapFloat64(f func(rune) float64) *Float64Stream {
	return FromFloat64Observable(MapRune2Float64ObserveNext(s, f))
}

func (s *RuneStream) FlatMapFloat64(f func(rune) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapRune2Float64{s, f}}
}

type MappingRune2Complex64Func func(next rune, err error, complete bool, observer Complex64Observer)
type MappingRune2Complex64FuncFactory func(observer Complex64Observer) MappingRune2Complex64Func

type MappingRune2Complex64Observable struct {
	parent RuneObservable
	mapper MappingRune2Complex64FuncFactory
}

func (f *MappingRune2Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2Complex64Observable(parent RuneObservable, mapper MappingRune2Complex64FuncFactory) Complex64Observable {
	return &MappingRune2Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2Complex64ObserveDirect(parent RuneObservable, mapper MappingRune2Complex64Func) Complex64Observable {
	return MapRune2Complex64Observable(parent, func(Complex64Observer) MappingRune2Complex64Func {
		return mapper
	})
}

func MapRune2Complex64ObserveNext(parent RuneObservable, mapper func(rune) complex64) Complex64Observable {
	return MapRune2Complex64Observable(parent, func(Complex64Observer) MappingRune2Complex64Func {
		return func(next rune, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Complex64 struct {
	parent RuneObservable
	mapper func(rune) Complex64Observable
}

func (f *flatMapRune2Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *RuneStream) MapComplex64(f func(rune) complex64) *Complex64Stream {
	return FromComplex64Observable(MapRune2Complex64ObserveNext(s, f))
}

func (s *RuneStream) FlatMapComplex64(f func(rune) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapRune2Complex64{s, f}}
}

type MappingRune2Complex128Func func(next rune, err error, complete bool, observer Complex128Observer)
type MappingRune2Complex128FuncFactory func(observer Complex128Observer) MappingRune2Complex128Func

type MappingRune2Complex128Observable struct {
	parent RuneObservable
	mapper MappingRune2Complex128FuncFactory
}

func (f *MappingRune2Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2Complex128Observable(parent RuneObservable, mapper MappingRune2Complex128FuncFactory) Complex128Observable {
	return &MappingRune2Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2Complex128ObserveDirect(parent RuneObservable, mapper MappingRune2Complex128Func) Complex128Observable {
	return MapRune2Complex128Observable(parent, func(Complex128Observer) MappingRune2Complex128Func {
		return mapper
	})
}

func MapRune2Complex128ObserveNext(parent RuneObservable, mapper func(rune) complex128) Complex128Observable {
	return MapRune2Complex128Observable(parent, func(Complex128Observer) MappingRune2Complex128Func {
		return func(next rune, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Complex128 struct {
	parent RuneObservable
	mapper func(rune) Complex128Observable
}

func (f *flatMapRune2Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *RuneStream) MapComplex128(f func(rune) complex128) *Complex128Stream {
	return FromComplex128Observable(MapRune2Complex128ObserveNext(s, f))
}

func (s *RuneStream) FlatMapComplex128(f func(rune) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapRune2Complex128{s, f}}
}

type MappingRune2TimeFunc func(next rune, err error, complete bool, observer TimeObserver)
type MappingRune2TimeFuncFactory func(observer TimeObserver) MappingRune2TimeFunc

type MappingRune2TimeObservable struct {
	parent RuneObservable
	mapper MappingRune2TimeFuncFactory
}

func (f *MappingRune2TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2TimeObservable(parent RuneObservable, mapper MappingRune2TimeFuncFactory) TimeObservable {
	return &MappingRune2TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2TimeObserveDirect(parent RuneObservable, mapper MappingRune2TimeFunc) TimeObservable {
	return MapRune2TimeObservable(parent, func(TimeObserver) MappingRune2TimeFunc {
		return mapper
	})
}

func MapRune2TimeObserveNext(parent RuneObservable, mapper func(rune) time.Time) TimeObservable {
	return MapRune2TimeObservable(parent, func(TimeObserver) MappingRune2TimeFunc {
		return func(next rune, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Time struct {
	parent RuneObservable
	mapper func(rune) TimeObservable
}

func (f *flatMapRune2Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *RuneStream) MapTime(f func(rune) time.Time) *TimeStream {
	return FromTimeObservable(MapRune2TimeObserveNext(s, f))
}

func (s *RuneStream) FlatMapTime(f func(rune) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapRune2Time{s, f}}
}

type MappingRune2DurationFunc func(next rune, err error, complete bool, observer DurationObserver)
type MappingRune2DurationFuncFactory func(observer DurationObserver) MappingRune2DurationFunc

type MappingRune2DurationObservable struct {
	parent RuneObservable
	mapper MappingRune2DurationFuncFactory
}

func (f *MappingRune2DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapRune2DurationObservable(parent RuneObservable, mapper MappingRune2DurationFuncFactory) DurationObservable {
	return &MappingRune2DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapRune2DurationObserveDirect(parent RuneObservable, mapper MappingRune2DurationFunc) DurationObservable {
	return MapRune2DurationObservable(parent, func(DurationObserver) MappingRune2DurationFunc {
		return mapper
	})
}

func MapRune2DurationObserveNext(parent RuneObservable, mapper func(rune) time.Duration) DurationObservable {
	return MapRune2DurationObservable(parent, func(DurationObserver) MappingRune2DurationFunc {
		return func(next rune, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapRune2Duration struct {
	parent RuneObservable
	mapper func(rune) DurationObservable
}

func (f *flatMapRune2Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(RuneObserverFunc(func(next rune, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *RuneStream) MapDuration(f func(rune) time.Duration) *DurationStream {
	return FromDurationObservable(MapRune2DurationObserveNext(s, f))
}

func (s *RuneStream) FlatMapDuration(f func(rune) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapRune2Duration{s, f}}
}

type ByteObserver interface {
	Next(byte)
	TerminationObserver
}

// A ByteSubscriber represents a subscribed ByteObserver.
type ByteSubscriber interface {
	Subscription
	ByteObserver
}

type implByteSubscriber struct {
	Subscription
	ByteObserver
}

func ByteObserverAsGenericObserver(observer ByteObserver) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(byte))
		}
	})
}

func GenericObserverAsByteObserver(observer GenericObserver) ByteObserver {
	return ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type ByteObservableFactory func(observer ByteObserver, subscription Subscription)

func (f ByteObservableFactory) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateByte calls f(observer, subscription) to produce values for a stream.
func CreateByte(f func(observer ByteObserver, subscription Subscription)) *ByteStream {
	return FromByteObservable(ByteObservableFactory(f))
}

// Repeat value count times.
func RepeatByte(value byte, count int) *ByteStream {
	return CreateByte(func(observer ByteObserver, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartByte is designed to be used with functions that return a
// (byte, error) tuple.
//
// If the error is non-nil the returned ByteStream will be that error,
// otherwise it will be a single-value stream of byte.
func StartByte(f func() (byte, error)) *ByteStream {
	return CreateByte(func(observer ByteObserver, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughByte(next byte, err error, complete bool, observer ByteObserver) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroByte = *new(byte)

type ByteObserverFunc func(byte, error, bool)

func (f ByteObserverFunc) Next(next byte)  { f(next, nil, false) }
func (f ByteObserverFunc) Error(err error) { f(zeroByte, err, false) }
func (f ByteObserverFunc) Complete()       { f(zeroByte, nil, true) }

type ByteObservable interface {
	Subscribe(ByteObserver) Subscription
}

// Convert a GenericObservableFilter to a ByteObservable
func (f GenericObservableFilterFactory) Byte(parent ByteObservable) ByteObservable {
	return MapByte2ByteObservable(parent, func(observer ByteObserver) MappingByte2ByteFunc {
		gobserver := ByteObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next byte, err error, complete bool, observer ByteObserver) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverByte() *ByteStream {
	return CreateByte(func(observer ByteObserver, subscription Subscription) {})
}

func EmptyByte() *ByteStream {
	return CreateByte(func(observer ByteObserver, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowByte(err error) *ByteStream {
	return CreateByte(func(observer ByteObserver, subscription Subscription) {
		observer.Error(err)
	})
}

func FromByteArray(array []byte) *ByteStream {
	return CreateByte(func(observer ByteObserver, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromBytes(array ...byte) *ByteStream {
	return FromByteArray(array)
}

func JustByte(element byte) *ByteStream {
	return FromByteArray([]byte{element})
}

func MergeByte(observables ...ByteObservable) *ByteStream {
	if len(observables) == 0 {
		return EmptyByte()
	}
	return (&ByteStream{observables[0]}).Merge(observables[1:]...)
}

func MergeByteDelayError(observables ...ByteObservable) *ByteStream {
	if len(observables) == 0 {
		return EmptyByte()
	}
	return (&ByteStream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromByteChannel(ch <-chan byte) *ByteStream {
	return CreateByte(func(observer ByteObserver, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type ByteStream struct {
	ByteObservable
}

func FromByteObservable(observable ByteObservable) *ByteStream {
	return &ByteStream{observable}
}

func (s *ByteStream) SubscribeFunc(f func(byte, error, bool)) Subscription {
	return s.Subscribe(ByteObserverFunc(f))
}

func (s *ByteStream) SubscribeNext(f func(v byte)) Subscription {
	return s.SubscribeFunc(func(next byte, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *ByteStream) Distinct() *ByteStream {
	return FromByteObservable(distinctFilter().Byte(s))
}

// ElementAt yields the Nth element of the stream.
func (s *ByteStream) ElementAt(n int) *ByteStream {
	return FromByteObservable(elementAtFilter(n).Byte(s))
}

// Filter elements in the stream on a function.
func (s *ByteStream) Filter(f func(byte) bool) *ByteStream {
	return FromByteObservable(filterFilter(func(v interface{}) bool { return f(v.(byte)) }).Byte(s))
}

// Last returns just the first element of the stream.
func (s *ByteStream) First() *ByteStream {
	return FromByteObservable(firstFilter().Byte(s))
}

// Last returns just the last element of the stream.
func (s *ByteStream) Last() *ByteStream {
	return FromByteObservable(lastFilter().Byte(s))
}

// SkipLast skips the first N elements of the stream.
func (s *ByteStream) Skip(n int) *ByteStream {
	return FromByteObservable(skipFilter(n).Byte(s))
}

// SkipLast skips the last N elements of the stream.
func (s *ByteStream) SkipLast(n int) *ByteStream {
	return FromByteObservable(skipLastFilter(n).Byte(s))
}

// Take returns just the first N elements of the stream.
func (s *ByteStream) Take(n int) *ByteStream {
	return FromByteObservable(takeFilter(n).Byte(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *ByteStream) TakeLast(n int) *ByteStream {
	return FromByteObservable(takeLastFilter(n).Byte(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *ByteStream) IgnoreElements() *ByteStream {
	return FromByteObservable(ignoreElementsFilter().Byte(s))
}

func (s *ByteStream) Replay(size int, duration time.Duration) *ByteStream {
	return FromByteObservable(replayFilter(size, duration).Byte(s))
}

func (s *ByteStream) Sample(duration time.Duration) *ByteStream {
	return FromByteObservable(sampleFilter(duration).Byte(s))
}

func (s *ByteStream) Debounce(duration time.Duration) *ByteStream {
	return FromByteObservable(debounceFilter(duration).Byte(s))
}

// Wait for completion of the stream and return any error.
func (s *ByteStream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeByteSubscriber(observer ByteObserver) ByteSubscriber {
	if subscriber, ok := observer.(ByteSubscriber); ok {
		return subscriber
	}
	return &implByteSubscriber{NewGenericSubscription(), observer}
}

type concatByteSubscriber struct {
	observable  int
	observer    ByteObserver
	observables []ByteObservable
	Subscription
}

func (c *concatByteSubscriber) Next(next byte) {
	c.observer.Next(next)
}

func (c *concatByteSubscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatByteSubscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatByteObservable struct {
	observables []ByteObservable
}

func (m *concatByteObservable) Subscribe(observer ByteObserver) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatByteSubscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *ByteStream) Concat(observables ...ByteObservable) *ByteStream {
	return &ByteStream{&concatByteObservable{append([]ByteObservable{s}, observables...)}}
}

type mergeByteObservable struct {
	delayError  bool
	observables []ByteObservable
}

func (m *mergeByteObservable) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next byte, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(ByteObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *ByteStream) Merge(other ...ByteObservable) *ByteStream {
	if len(other) == 0 {
		return s
	}
	return &ByteStream{&mergeByteObservable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *ByteStream) MergeDelayError(other ...ByteObservable) *ByteStream {
	if len(other) == 0 {
		return s
	}
	return &ByteStream{&mergeByteObservable{true, append(other, s)}}
}

type catchByteObservable struct {
	parent ByteObservable
	catch  ByteObservable
}

func (r *catchByteObservable) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	run := func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(ByteObserverFunc(run))
	return subscription
}

func (s *ByteStream) Catch(catch ByteObservable) *ByteStream {
	return &ByteStream{&catchByteObservable{s, catch}}
}

type retryByteObservable struct {
	observable ByteObservable
}

type retryByteObserver struct {
	observable ByteObservable
	observer   ByteObserver
}

func (r *retryByteObserver) retry(next byte, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(ByteObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryByteObservable) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryByteObserver{r.observable, observer}
	r.observable.Subscribe(ByteObserverFunc(ro.retry))
	return subscription
}

func (s *ByteStream) Retry() *ByteStream {
	return &ByteStream{&retryByteObservable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *ByteStream) Do(f func(next byte)) *ByteStream {
	return FromByteObservable(MapByte2ByteObserveNext(s, func(next byte) byte {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *ByteStream) DoOnError(f func(err error)) *ByteStream {
	return FromByteObservable(MapByte2ByteObserveDirect(s, func(next byte, err error, complete bool, observer ByteObserver) {
		if err != nil {
			f(err)
		}
		PassthroughByte(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *ByteStream) DoOnComplete(f func()) *ByteStream {
	return FromByteObservable(MapByte2ByteObserveDirect(s, func(next byte, err error, complete bool, observer ByteObserver) {
		if complete {
			f()
		}
		PassthroughByte(next, err, complete, observer)
	}))
}

func (s *ByteStream) Reduce(initial byte, reducer func(byte, byte) byte) *ByteStream {
	value := initial
	return FromByteObservable(MapByte2ByteObserveDirect(s, func(next byte, err error, complete bool, observer ByteObserver) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *ByteStream) Scan(initial byte, f func(byte, byte) byte) *ByteStream {
	value := initial
	return FromByteObservable(MapByte2ByteObserveDirect(s, func(next byte, err error, complete bool, observer ByteObserver) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutByte struct {
	parent  ByteObservable
	timeout time.Duration
}

func (t *timeoutByte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *ByteStream) Timeout(timeout time.Duration) *ByteStream {
	return &ByteStream{&timeoutByte{s, timeout}}
}

type forkedByteStream struct {
	lock      sync.Mutex
	parent    ByteObservable
	observers []ByteObserver
}

func (f *forkedByteStream) Subscribe(observer ByteObserver) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *ByteStream) Fork() *ByteStream {
	f := &forkedByteStream{parent: s}
	go s.Subscribe(ByteObserverFunc(func(n byte, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &ByteStream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *ByteStream) ToOneWithError() (byte, error) {
	valuech := make(chan byte, 1)
	errch := make(chan error, 1)
	FromByteObservable(oneFilter().Byte(s)).SubscribeFunc(func(next byte, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroByte, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *ByteStream) ToOne() byte {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *ByteStream) ToArrayWithError() ([]byte, error) {
	array := []byte{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *ByteStream) ToArray() []byte {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *ByteStream) ToChannelWithError() (<-chan byte, <-chan error) {
	ch := make(chan byte, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *ByteStream) ToChannel() <-chan byte {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *ByteStream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapByte2IntObserveDirect(s, func(next byte, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

func (s *ByteStream) Average() *ByteStream {
	var sum byte
	var count byte
	return FromByteObservable(MapByte2ByteObserveDirect(s, func(next byte, err error, complete bool, observer ByteObserver) {
		switch {
		case err != nil:
			observer.Next(sum / count)
			observer.Error(err)
		case complete:
			observer.Next(sum / count)
			observer.Complete()
		default:
			sum += next
			count++
		}
	}))
}

func (s *ByteStream) Sum() *ByteStream {
	var sum byte
	return FromByteObservable(MapByte2ByteObserveDirect(s, func(next byte, err error, complete bool, observer ByteObserver) {
		switch {
		case err != nil:
			observer.Next(sum)
			observer.Error(err)
		case complete:
			observer.Next(sum)
			observer.Complete()
		default:
			sum += next
		}
	}))
}

func (s *ByteStream) Min() *ByteStream {
	started := false
	var min byte
	return FromByteObservable(MapByte2ByteObserveDirect(s, func(next byte, err error, complete bool, observer ByteObserver) {
		switch {
		case err != nil:
			if started {
				observer.Next(min)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(min)
			}
			observer.Complete()
		default:
			if started {
				if min > next {
					min = next
				}
			} else {
				min = next
				started = true
			}
		}
	}))
}

func (s *ByteStream) Max() *ByteStream {
	started := false
	var max byte
	return FromByteObservable(MapByte2ByteObserveDirect(s, func(next byte, err error, complete bool, observer ByteObserver) {
		switch {
		case err != nil:
			if started {
				observer.Next(max)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(max)
			}
			observer.Complete()
		default:
			if started {
				if max <= next {
					max = next
				}
			} else {
				max = next
				started = true
			}
		}
	}))
}

type MappingByte2BoolFunc func(next byte, err error, complete bool, observer BoolObserver)
type MappingByte2BoolFuncFactory func(observer BoolObserver) MappingByte2BoolFunc

type MappingByte2BoolObservable struct {
	parent ByteObservable
	mapper MappingByte2BoolFuncFactory
}

func (f *MappingByte2BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2BoolObservable(parent ByteObservable, mapper MappingByte2BoolFuncFactory) BoolObservable {
	return &MappingByte2BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2BoolObserveDirect(parent ByteObservable, mapper MappingByte2BoolFunc) BoolObservable {
	return MapByte2BoolObservable(parent, func(BoolObserver) MappingByte2BoolFunc {
		return mapper
	})
}

func MapByte2BoolObserveNext(parent ByteObservable, mapper func(byte) bool) BoolObservable {
	return MapByte2BoolObservable(parent, func(BoolObserver) MappingByte2BoolFunc {
		return func(next byte, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Bool struct {
	parent ByteObservable
	mapper func(byte) BoolObservable
}

func (f *flatMapByte2Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *ByteStream) MapBool(f func(byte) bool) *BoolStream {
	return FromBoolObservable(MapByte2BoolObserveNext(s, f))
}

func (s *ByteStream) FlatMapBool(f func(byte) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapByte2Bool{s, f}}
}

type MappingByte2RuneFunc func(next byte, err error, complete bool, observer RuneObserver)
type MappingByte2RuneFuncFactory func(observer RuneObserver) MappingByte2RuneFunc

type MappingByte2RuneObservable struct {
	parent ByteObservable
	mapper MappingByte2RuneFuncFactory
}

func (f *MappingByte2RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2RuneObservable(parent ByteObservable, mapper MappingByte2RuneFuncFactory) RuneObservable {
	return &MappingByte2RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2RuneObserveDirect(parent ByteObservable, mapper MappingByte2RuneFunc) RuneObservable {
	return MapByte2RuneObservable(parent, func(RuneObserver) MappingByte2RuneFunc {
		return mapper
	})
}

func MapByte2RuneObserveNext(parent ByteObservable, mapper func(byte) rune) RuneObservable {
	return MapByte2RuneObservable(parent, func(RuneObserver) MappingByte2RuneFunc {
		return func(next byte, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Rune struct {
	parent ByteObservable
	mapper func(byte) RuneObservable
}

func (f *flatMapByte2Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *ByteStream) MapRune(f func(byte) rune) *RuneStream {
	return FromRuneObservable(MapByte2RuneObserveNext(s, f))
}

func (s *ByteStream) FlatMapRune(f func(byte) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapByte2Rune{s, f}}
}

type MappingByte2ByteFunc func(next byte, err error, complete bool, observer ByteObserver)
type MappingByte2ByteFuncFactory func(observer ByteObserver) MappingByte2ByteFunc

type MappingByte2ByteObservable struct {
	parent ByteObservable
	mapper MappingByte2ByteFuncFactory
}

func (f *MappingByte2ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2ByteObservable(parent ByteObservable, mapper MappingByte2ByteFuncFactory) ByteObservable {
	return &MappingByte2ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2ByteObserveDirect(parent ByteObservable, mapper MappingByte2ByteFunc) ByteObservable {
	return MapByte2ByteObservable(parent, func(ByteObserver) MappingByte2ByteFunc {
		return mapper
	})
}

func MapByte2ByteObserveNext(parent ByteObservable, mapper func(byte) byte) ByteObservable {
	return MapByte2ByteObservable(parent, func(ByteObserver) MappingByte2ByteFunc {
		return func(next byte, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Byte struct {
	parent ByteObservable
	mapper func(byte) ByteObservable
}

func (f *flatMapByte2Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *ByteStream) Map(f func(byte) byte) *ByteStream {
	return FromByteObservable(MapByte2ByteObserveNext(s, f))
}

func (s *ByteStream) FlatMap(f func(byte) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapByte2Byte{s, f}}
}

type MappingByte2StringFunc func(next byte, err error, complete bool, observer StringObserver)
type MappingByte2StringFuncFactory func(observer StringObserver) MappingByte2StringFunc

type MappingByte2StringObservable struct {
	parent ByteObservable
	mapper MappingByte2StringFuncFactory
}

func (f *MappingByte2StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2StringObservable(parent ByteObservable, mapper MappingByte2StringFuncFactory) StringObservable {
	return &MappingByte2StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2StringObserveDirect(parent ByteObservable, mapper MappingByte2StringFunc) StringObservable {
	return MapByte2StringObservable(parent, func(StringObserver) MappingByte2StringFunc {
		return mapper
	})
}

func MapByte2StringObserveNext(parent ByteObservable, mapper func(byte) string) StringObservable {
	return MapByte2StringObservable(parent, func(StringObserver) MappingByte2StringFunc {
		return func(next byte, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2String struct {
	parent ByteObservable
	mapper func(byte) StringObservable
}

func (f *flatMapByte2String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *ByteStream) MapString(f func(byte) string) *StringStream {
	return FromStringObservable(MapByte2StringObserveNext(s, f))
}

func (s *ByteStream) FlatMapString(f func(byte) StringObservable) *StringStream {
	return &StringStream{&flatMapByte2String{s, f}}
}

type MappingByte2UintFunc func(next byte, err error, complete bool, observer UintObserver)
type MappingByte2UintFuncFactory func(observer UintObserver) MappingByte2UintFunc

type MappingByte2UintObservable struct {
	parent ByteObservable
	mapper MappingByte2UintFuncFactory
}

func (f *MappingByte2UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2UintObservable(parent ByteObservable, mapper MappingByte2UintFuncFactory) UintObservable {
	return &MappingByte2UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2UintObserveDirect(parent ByteObservable, mapper MappingByte2UintFunc) UintObservable {
	return MapByte2UintObservable(parent, func(UintObserver) MappingByte2UintFunc {
		return mapper
	})
}

func MapByte2UintObserveNext(parent ByteObservable, mapper func(byte) uint) UintObservable {
	return MapByte2UintObservable(parent, func(UintObserver) MappingByte2UintFunc {
		return func(next byte, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Uint struct {
	parent ByteObservable
	mapper func(byte) UintObservable
}

func (f *flatMapByte2Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *ByteStream) MapUint(f func(byte) uint) *UintStream {
	return FromUintObservable(MapByte2UintObserveNext(s, f))
}

func (s *ByteStream) FlatMapUint(f func(byte) UintObservable) *UintStream {
	return &UintStream{&flatMapByte2Uint{s, f}}
}

type MappingByte2IntFunc func(next byte, err error, complete bool, observer IntObserver)
type MappingByte2IntFuncFactory func(observer IntObserver) MappingByte2IntFunc

type MappingByte2IntObservable struct {
	parent ByteObservable
	mapper MappingByte2IntFuncFactory
}

func (f *MappingByte2IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2IntObservable(parent ByteObservable, mapper MappingByte2IntFuncFactory) IntObservable {
	return &MappingByte2IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2IntObserveDirect(parent ByteObservable, mapper MappingByte2IntFunc) IntObservable {
	return MapByte2IntObservable(parent, func(IntObserver) MappingByte2IntFunc {
		return mapper
	})
}

func MapByte2IntObserveNext(parent ByteObservable, mapper func(byte) int) IntObservable {
	return MapByte2IntObservable(parent, func(IntObserver) MappingByte2IntFunc {
		return func(next byte, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Int struct {
	parent ByteObservable
	mapper func(byte) IntObservable
}

func (f *flatMapByte2Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *ByteStream) MapInt(f func(byte) int) *IntStream {
	return FromIntObservable(MapByte2IntObserveNext(s, f))
}

func (s *ByteStream) FlatMapInt(f func(byte) IntObservable) *IntStream {
	return &IntStream{&flatMapByte2Int{s, f}}
}

type MappingByte2Uint8Func func(next byte, err error, complete bool, observer Uint8Observer)
type MappingByte2Uint8FuncFactory func(observer Uint8Observer) MappingByte2Uint8Func

type MappingByte2Uint8Observable struct {
	parent ByteObservable
	mapper MappingByte2Uint8FuncFactory
}

func (f *MappingByte2Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2Uint8Observable(parent ByteObservable, mapper MappingByte2Uint8FuncFactory) Uint8Observable {
	return &MappingByte2Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2Uint8ObserveDirect(parent ByteObservable, mapper MappingByte2Uint8Func) Uint8Observable {
	return MapByte2Uint8Observable(parent, func(Uint8Observer) MappingByte2Uint8Func {
		return mapper
	})
}

func MapByte2Uint8ObserveNext(parent ByteObservable, mapper func(byte) uint8) Uint8Observable {
	return MapByte2Uint8Observable(parent, func(Uint8Observer) MappingByte2Uint8Func {
		return func(next byte, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Uint8 struct {
	parent ByteObservable
	mapper func(byte) Uint8Observable
}

func (f *flatMapByte2Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *ByteStream) MapUint8(f func(byte) uint8) *Uint8Stream {
	return FromUint8Observable(MapByte2Uint8ObserveNext(s, f))
}

func (s *ByteStream) FlatMapUint8(f func(byte) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapByte2Uint8{s, f}}
}

type MappingByte2Int8Func func(next byte, err error, complete bool, observer Int8Observer)
type MappingByte2Int8FuncFactory func(observer Int8Observer) MappingByte2Int8Func

type MappingByte2Int8Observable struct {
	parent ByteObservable
	mapper MappingByte2Int8FuncFactory
}

func (f *MappingByte2Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2Int8Observable(parent ByteObservable, mapper MappingByte2Int8FuncFactory) Int8Observable {
	return &MappingByte2Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2Int8ObserveDirect(parent ByteObservable, mapper MappingByte2Int8Func) Int8Observable {
	return MapByte2Int8Observable(parent, func(Int8Observer) MappingByte2Int8Func {
		return mapper
	})
}

func MapByte2Int8ObserveNext(parent ByteObservable, mapper func(byte) int8) Int8Observable {
	return MapByte2Int8Observable(parent, func(Int8Observer) MappingByte2Int8Func {
		return func(next byte, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Int8 struct {
	parent ByteObservable
	mapper func(byte) Int8Observable
}

func (f *flatMapByte2Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *ByteStream) MapInt8(f func(byte) int8) *Int8Stream {
	return FromInt8Observable(MapByte2Int8ObserveNext(s, f))
}

func (s *ByteStream) FlatMapInt8(f func(byte) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapByte2Int8{s, f}}
}

type MappingByte2Uint16Func func(next byte, err error, complete bool, observer Uint16Observer)
type MappingByte2Uint16FuncFactory func(observer Uint16Observer) MappingByte2Uint16Func

type MappingByte2Uint16Observable struct {
	parent ByteObservable
	mapper MappingByte2Uint16FuncFactory
}

func (f *MappingByte2Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2Uint16Observable(parent ByteObservable, mapper MappingByte2Uint16FuncFactory) Uint16Observable {
	return &MappingByte2Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2Uint16ObserveDirect(parent ByteObservable, mapper MappingByte2Uint16Func) Uint16Observable {
	return MapByte2Uint16Observable(parent, func(Uint16Observer) MappingByte2Uint16Func {
		return mapper
	})
}

func MapByte2Uint16ObserveNext(parent ByteObservable, mapper func(byte) uint16) Uint16Observable {
	return MapByte2Uint16Observable(parent, func(Uint16Observer) MappingByte2Uint16Func {
		return func(next byte, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Uint16 struct {
	parent ByteObservable
	mapper func(byte) Uint16Observable
}

func (f *flatMapByte2Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *ByteStream) MapUint16(f func(byte) uint16) *Uint16Stream {
	return FromUint16Observable(MapByte2Uint16ObserveNext(s, f))
}

func (s *ByteStream) FlatMapUint16(f func(byte) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapByte2Uint16{s, f}}
}

type MappingByte2Int16Func func(next byte, err error, complete bool, observer Int16Observer)
type MappingByte2Int16FuncFactory func(observer Int16Observer) MappingByte2Int16Func

type MappingByte2Int16Observable struct {
	parent ByteObservable
	mapper MappingByte2Int16FuncFactory
}

func (f *MappingByte2Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2Int16Observable(parent ByteObservable, mapper MappingByte2Int16FuncFactory) Int16Observable {
	return &MappingByte2Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2Int16ObserveDirect(parent ByteObservable, mapper MappingByte2Int16Func) Int16Observable {
	return MapByte2Int16Observable(parent, func(Int16Observer) MappingByte2Int16Func {
		return mapper
	})
}

func MapByte2Int16ObserveNext(parent ByteObservable, mapper func(byte) int16) Int16Observable {
	return MapByte2Int16Observable(parent, func(Int16Observer) MappingByte2Int16Func {
		return func(next byte, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Int16 struct {
	parent ByteObservable
	mapper func(byte) Int16Observable
}

func (f *flatMapByte2Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *ByteStream) MapInt16(f func(byte) int16) *Int16Stream {
	return FromInt16Observable(MapByte2Int16ObserveNext(s, f))
}

func (s *ByteStream) FlatMapInt16(f func(byte) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapByte2Int16{s, f}}
}

type MappingByte2Uint32Func func(next byte, err error, complete bool, observer Uint32Observer)
type MappingByte2Uint32FuncFactory func(observer Uint32Observer) MappingByte2Uint32Func

type MappingByte2Uint32Observable struct {
	parent ByteObservable
	mapper MappingByte2Uint32FuncFactory
}

func (f *MappingByte2Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2Uint32Observable(parent ByteObservable, mapper MappingByte2Uint32FuncFactory) Uint32Observable {
	return &MappingByte2Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2Uint32ObserveDirect(parent ByteObservable, mapper MappingByte2Uint32Func) Uint32Observable {
	return MapByte2Uint32Observable(parent, func(Uint32Observer) MappingByte2Uint32Func {
		return mapper
	})
}

func MapByte2Uint32ObserveNext(parent ByteObservable, mapper func(byte) uint32) Uint32Observable {
	return MapByte2Uint32Observable(parent, func(Uint32Observer) MappingByte2Uint32Func {
		return func(next byte, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Uint32 struct {
	parent ByteObservable
	mapper func(byte) Uint32Observable
}

func (f *flatMapByte2Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *ByteStream) MapUint32(f func(byte) uint32) *Uint32Stream {
	return FromUint32Observable(MapByte2Uint32ObserveNext(s, f))
}

func (s *ByteStream) FlatMapUint32(f func(byte) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapByte2Uint32{s, f}}
}

type MappingByte2Int32Func func(next byte, err error, complete bool, observer Int32Observer)
type MappingByte2Int32FuncFactory func(observer Int32Observer) MappingByte2Int32Func

type MappingByte2Int32Observable struct {
	parent ByteObservable
	mapper MappingByte2Int32FuncFactory
}

func (f *MappingByte2Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2Int32Observable(parent ByteObservable, mapper MappingByte2Int32FuncFactory) Int32Observable {
	return &MappingByte2Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2Int32ObserveDirect(parent ByteObservable, mapper MappingByte2Int32Func) Int32Observable {
	return MapByte2Int32Observable(parent, func(Int32Observer) MappingByte2Int32Func {
		return mapper
	})
}

func MapByte2Int32ObserveNext(parent ByteObservable, mapper func(byte) int32) Int32Observable {
	return MapByte2Int32Observable(parent, func(Int32Observer) MappingByte2Int32Func {
		return func(next byte, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Int32 struct {
	parent ByteObservable
	mapper func(byte) Int32Observable
}

func (f *flatMapByte2Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *ByteStream) MapInt32(f func(byte) int32) *Int32Stream {
	return FromInt32Observable(MapByte2Int32ObserveNext(s, f))
}

func (s *ByteStream) FlatMapInt32(f func(byte) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapByte2Int32{s, f}}
}

type MappingByte2Uint64Func func(next byte, err error, complete bool, observer Uint64Observer)
type MappingByte2Uint64FuncFactory func(observer Uint64Observer) MappingByte2Uint64Func

type MappingByte2Uint64Observable struct {
	parent ByteObservable
	mapper MappingByte2Uint64FuncFactory
}

func (f *MappingByte2Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2Uint64Observable(parent ByteObservable, mapper MappingByte2Uint64FuncFactory) Uint64Observable {
	return &MappingByte2Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2Uint64ObserveDirect(parent ByteObservable, mapper MappingByte2Uint64Func) Uint64Observable {
	return MapByte2Uint64Observable(parent, func(Uint64Observer) MappingByte2Uint64Func {
		return mapper
	})
}

func MapByte2Uint64ObserveNext(parent ByteObservable, mapper func(byte) uint64) Uint64Observable {
	return MapByte2Uint64Observable(parent, func(Uint64Observer) MappingByte2Uint64Func {
		return func(next byte, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Uint64 struct {
	parent ByteObservable
	mapper func(byte) Uint64Observable
}

func (f *flatMapByte2Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *ByteStream) MapUint64(f func(byte) uint64) *Uint64Stream {
	return FromUint64Observable(MapByte2Uint64ObserveNext(s, f))
}

func (s *ByteStream) FlatMapUint64(f func(byte) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapByte2Uint64{s, f}}
}

type MappingByte2Int64Func func(next byte, err error, complete bool, observer Int64Observer)
type MappingByte2Int64FuncFactory func(observer Int64Observer) MappingByte2Int64Func

type MappingByte2Int64Observable struct {
	parent ByteObservable
	mapper MappingByte2Int64FuncFactory
}

func (f *MappingByte2Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2Int64Observable(parent ByteObservable, mapper MappingByte2Int64FuncFactory) Int64Observable {
	return &MappingByte2Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2Int64ObserveDirect(parent ByteObservable, mapper MappingByte2Int64Func) Int64Observable {
	return MapByte2Int64Observable(parent, func(Int64Observer) MappingByte2Int64Func {
		return mapper
	})
}

func MapByte2Int64ObserveNext(parent ByteObservable, mapper func(byte) int64) Int64Observable {
	return MapByte2Int64Observable(parent, func(Int64Observer) MappingByte2Int64Func {
		return func(next byte, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Int64 struct {
	parent ByteObservable
	mapper func(byte) Int64Observable
}

func (f *flatMapByte2Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *ByteStream) MapInt64(f func(byte) int64) *Int64Stream {
	return FromInt64Observable(MapByte2Int64ObserveNext(s, f))
}

func (s *ByteStream) FlatMapInt64(f func(byte) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapByte2Int64{s, f}}
}

type MappingByte2Float32Func func(next byte, err error, complete bool, observer Float32Observer)
type MappingByte2Float32FuncFactory func(observer Float32Observer) MappingByte2Float32Func

type MappingByte2Float32Observable struct {
	parent ByteObservable
	mapper MappingByte2Float32FuncFactory
}

func (f *MappingByte2Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2Float32Observable(parent ByteObservable, mapper MappingByte2Float32FuncFactory) Float32Observable {
	return &MappingByte2Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2Float32ObserveDirect(parent ByteObservable, mapper MappingByte2Float32Func) Float32Observable {
	return MapByte2Float32Observable(parent, func(Float32Observer) MappingByte2Float32Func {
		return mapper
	})
}

func MapByte2Float32ObserveNext(parent ByteObservable, mapper func(byte) float32) Float32Observable {
	return MapByte2Float32Observable(parent, func(Float32Observer) MappingByte2Float32Func {
		return func(next byte, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Float32 struct {
	parent ByteObservable
	mapper func(byte) Float32Observable
}

func (f *flatMapByte2Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *ByteStream) MapFloat32(f func(byte) float32) *Float32Stream {
	return FromFloat32Observable(MapByte2Float32ObserveNext(s, f))
}

func (s *ByteStream) FlatMapFloat32(f func(byte) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapByte2Float32{s, f}}
}

type MappingByte2Float64Func func(next byte, err error, complete bool, observer Float64Observer)
type MappingByte2Float64FuncFactory func(observer Float64Observer) MappingByte2Float64Func

type MappingByte2Float64Observable struct {
	parent ByteObservable
	mapper MappingByte2Float64FuncFactory
}

func (f *MappingByte2Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2Float64Observable(parent ByteObservable, mapper MappingByte2Float64FuncFactory) Float64Observable {
	return &MappingByte2Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2Float64ObserveDirect(parent ByteObservable, mapper MappingByte2Float64Func) Float64Observable {
	return MapByte2Float64Observable(parent, func(Float64Observer) MappingByte2Float64Func {
		return mapper
	})
}

func MapByte2Float64ObserveNext(parent ByteObservable, mapper func(byte) float64) Float64Observable {
	return MapByte2Float64Observable(parent, func(Float64Observer) MappingByte2Float64Func {
		return func(next byte, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Float64 struct {
	parent ByteObservable
	mapper func(byte) Float64Observable
}

func (f *flatMapByte2Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *ByteStream) MapFloat64(f func(byte) float64) *Float64Stream {
	return FromFloat64Observable(MapByte2Float64ObserveNext(s, f))
}

func (s *ByteStream) FlatMapFloat64(f func(byte) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapByte2Float64{s, f}}
}

type MappingByte2Complex64Func func(next byte, err error, complete bool, observer Complex64Observer)
type MappingByte2Complex64FuncFactory func(observer Complex64Observer) MappingByte2Complex64Func

type MappingByte2Complex64Observable struct {
	parent ByteObservable
	mapper MappingByte2Complex64FuncFactory
}

func (f *MappingByte2Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2Complex64Observable(parent ByteObservable, mapper MappingByte2Complex64FuncFactory) Complex64Observable {
	return &MappingByte2Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2Complex64ObserveDirect(parent ByteObservable, mapper MappingByte2Complex64Func) Complex64Observable {
	return MapByte2Complex64Observable(parent, func(Complex64Observer) MappingByte2Complex64Func {
		return mapper
	})
}

func MapByte2Complex64ObserveNext(parent ByteObservable, mapper func(byte) complex64) Complex64Observable {
	return MapByte2Complex64Observable(parent, func(Complex64Observer) MappingByte2Complex64Func {
		return func(next byte, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Complex64 struct {
	parent ByteObservable
	mapper func(byte) Complex64Observable
}

func (f *flatMapByte2Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *ByteStream) MapComplex64(f func(byte) complex64) *Complex64Stream {
	return FromComplex64Observable(MapByte2Complex64ObserveNext(s, f))
}

func (s *ByteStream) FlatMapComplex64(f func(byte) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapByte2Complex64{s, f}}
}

type MappingByte2Complex128Func func(next byte, err error, complete bool, observer Complex128Observer)
type MappingByte2Complex128FuncFactory func(observer Complex128Observer) MappingByte2Complex128Func

type MappingByte2Complex128Observable struct {
	parent ByteObservable
	mapper MappingByte2Complex128FuncFactory
}

func (f *MappingByte2Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2Complex128Observable(parent ByteObservable, mapper MappingByte2Complex128FuncFactory) Complex128Observable {
	return &MappingByte2Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2Complex128ObserveDirect(parent ByteObservable, mapper MappingByte2Complex128Func) Complex128Observable {
	return MapByte2Complex128Observable(parent, func(Complex128Observer) MappingByte2Complex128Func {
		return mapper
	})
}

func MapByte2Complex128ObserveNext(parent ByteObservable, mapper func(byte) complex128) Complex128Observable {
	return MapByte2Complex128Observable(parent, func(Complex128Observer) MappingByte2Complex128Func {
		return func(next byte, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Complex128 struct {
	parent ByteObservable
	mapper func(byte) Complex128Observable
}

func (f *flatMapByte2Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *ByteStream) MapComplex128(f func(byte) complex128) *Complex128Stream {
	return FromComplex128Observable(MapByte2Complex128ObserveNext(s, f))
}

func (s *ByteStream) FlatMapComplex128(f func(byte) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapByte2Complex128{s, f}}
}

type MappingByte2TimeFunc func(next byte, err error, complete bool, observer TimeObserver)
type MappingByte2TimeFuncFactory func(observer TimeObserver) MappingByte2TimeFunc

type MappingByte2TimeObservable struct {
	parent ByteObservable
	mapper MappingByte2TimeFuncFactory
}

func (f *MappingByte2TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2TimeObservable(parent ByteObservable, mapper MappingByte2TimeFuncFactory) TimeObservable {
	return &MappingByte2TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2TimeObserveDirect(parent ByteObservable, mapper MappingByte2TimeFunc) TimeObservable {
	return MapByte2TimeObservable(parent, func(TimeObserver) MappingByte2TimeFunc {
		return mapper
	})
}

func MapByte2TimeObserveNext(parent ByteObservable, mapper func(byte) time.Time) TimeObservable {
	return MapByte2TimeObservable(parent, func(TimeObserver) MappingByte2TimeFunc {
		return func(next byte, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Time struct {
	parent ByteObservable
	mapper func(byte) TimeObservable
}

func (f *flatMapByte2Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *ByteStream) MapTime(f func(byte) time.Time) *TimeStream {
	return FromTimeObservable(MapByte2TimeObserveNext(s, f))
}

func (s *ByteStream) FlatMapTime(f func(byte) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapByte2Time{s, f}}
}

type MappingByte2DurationFunc func(next byte, err error, complete bool, observer DurationObserver)
type MappingByte2DurationFuncFactory func(observer DurationObserver) MappingByte2DurationFunc

type MappingByte2DurationObservable struct {
	parent ByteObservable
	mapper MappingByte2DurationFuncFactory
}

func (f *MappingByte2DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapByte2DurationObservable(parent ByteObservable, mapper MappingByte2DurationFuncFactory) DurationObservable {
	return &MappingByte2DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapByte2DurationObserveDirect(parent ByteObservable, mapper MappingByte2DurationFunc) DurationObservable {
	return MapByte2DurationObservable(parent, func(DurationObserver) MappingByte2DurationFunc {
		return mapper
	})
}

func MapByte2DurationObserveNext(parent ByteObservable, mapper func(byte) time.Duration) DurationObservable {
	return MapByte2DurationObservable(parent, func(DurationObserver) MappingByte2DurationFunc {
		return func(next byte, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapByte2Duration struct {
	parent ByteObservable
	mapper func(byte) DurationObservable
}

func (f *flatMapByte2Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(ByteObserverFunc(func(next byte, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *ByteStream) MapDuration(f func(byte) time.Duration) *DurationStream {
	return FromDurationObservable(MapByte2DurationObserveNext(s, f))
}

func (s *ByteStream) FlatMapDuration(f func(byte) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapByte2Duration{s, f}}
}

type StringObserver interface {
	Next(string)
	TerminationObserver
}

// A StringSubscriber represents a subscribed StringObserver.
type StringSubscriber interface {
	Subscription
	StringObserver
}

type implStringSubscriber struct {
	Subscription
	StringObserver
}

func StringObserverAsGenericObserver(observer StringObserver) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(string))
		}
	})
}

func GenericObserverAsStringObserver(observer GenericObserver) StringObserver {
	return StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type StringObservableFactory func(observer StringObserver, subscription Subscription)

func (f StringObservableFactory) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateString calls f(observer, subscription) to produce values for a stream.
func CreateString(f func(observer StringObserver, subscription Subscription)) *StringStream {
	return FromStringObservable(StringObservableFactory(f))
}

// Repeat value count times.
func RepeatString(value string, count int) *StringStream {
	return CreateString(func(observer StringObserver, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartString is designed to be used with functions that return a
// (string, error) tuple.
//
// If the error is non-nil the returned StringStream will be that error,
// otherwise it will be a single-value stream of string.
func StartString(f func() (string, error)) *StringStream {
	return CreateString(func(observer StringObserver, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughString(next string, err error, complete bool, observer StringObserver) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroString = *new(string)

type StringObserverFunc func(string, error, bool)

func (f StringObserverFunc) Next(next string) { f(next, nil, false) }
func (f StringObserverFunc) Error(err error)  { f(zeroString, err, false) }
func (f StringObserverFunc) Complete()        { f(zeroString, nil, true) }

type StringObservable interface {
	Subscribe(StringObserver) Subscription
}

// Convert a GenericObservableFilter to a StringObservable
func (f GenericObservableFilterFactory) String(parent StringObservable) StringObservable {
	return MapString2StringObservable(parent, func(observer StringObserver) MappingString2StringFunc {
		gobserver := StringObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next string, err error, complete bool, observer StringObserver) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverString() *StringStream {
	return CreateString(func(observer StringObserver, subscription Subscription) {})
}

func EmptyString() *StringStream {
	return CreateString(func(observer StringObserver, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowString(err error) *StringStream {
	return CreateString(func(observer StringObserver, subscription Subscription) {
		observer.Error(err)
	})
}

func FromStringArray(array []string) *StringStream {
	return CreateString(func(observer StringObserver, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromStrings(array ...string) *StringStream {
	return FromStringArray(array)
}

func JustString(element string) *StringStream {
	return FromStringArray([]string{element})
}

func MergeString(observables ...StringObservable) *StringStream {
	if len(observables) == 0 {
		return EmptyString()
	}
	return (&StringStream{observables[0]}).Merge(observables[1:]...)
}

func MergeStringDelayError(observables ...StringObservable) *StringStream {
	if len(observables) == 0 {
		return EmptyString()
	}
	return (&StringStream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromStringChannel(ch <-chan string) *StringStream {
	return CreateString(func(observer StringObserver, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type StringStream struct {
	StringObservable
}

func FromStringObservable(observable StringObservable) *StringStream {
	return &StringStream{observable}
}

func (s *StringStream) SubscribeFunc(f func(string, error, bool)) Subscription {
	return s.Subscribe(StringObserverFunc(f))
}

func (s *StringStream) SubscribeNext(f func(v string)) Subscription {
	return s.SubscribeFunc(func(next string, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *StringStream) Distinct() *StringStream {
	return FromStringObservable(distinctFilter().String(s))
}

// ElementAt yields the Nth element of the stream.
func (s *StringStream) ElementAt(n int) *StringStream {
	return FromStringObservable(elementAtFilter(n).String(s))
}

// Filter elements in the stream on a function.
func (s *StringStream) Filter(f func(string) bool) *StringStream {
	return FromStringObservable(filterFilter(func(v interface{}) bool { return f(v.(string)) }).String(s))
}

// Last returns just the first element of the stream.
func (s *StringStream) First() *StringStream {
	return FromStringObservable(firstFilter().String(s))
}

// Last returns just the last element of the stream.
func (s *StringStream) Last() *StringStream {
	return FromStringObservable(lastFilter().String(s))
}

// SkipLast skips the first N elements of the stream.
func (s *StringStream) Skip(n int) *StringStream {
	return FromStringObservable(skipFilter(n).String(s))
}

// SkipLast skips the last N elements of the stream.
func (s *StringStream) SkipLast(n int) *StringStream {
	return FromStringObservable(skipLastFilter(n).String(s))
}

// Take returns just the first N elements of the stream.
func (s *StringStream) Take(n int) *StringStream {
	return FromStringObservable(takeFilter(n).String(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *StringStream) TakeLast(n int) *StringStream {
	return FromStringObservable(takeLastFilter(n).String(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *StringStream) IgnoreElements() *StringStream {
	return FromStringObservable(ignoreElementsFilter().String(s))
}

func (s *StringStream) Replay(size int, duration time.Duration) *StringStream {
	return FromStringObservable(replayFilter(size, duration).String(s))
}

func (s *StringStream) Sample(duration time.Duration) *StringStream {
	return FromStringObservable(sampleFilter(duration).String(s))
}

func (s *StringStream) Debounce(duration time.Duration) *StringStream {
	return FromStringObservable(debounceFilter(duration).String(s))
}

// Wait for completion of the stream and return any error.
func (s *StringStream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeStringSubscriber(observer StringObserver) StringSubscriber {
	if subscriber, ok := observer.(StringSubscriber); ok {
		return subscriber
	}
	return &implStringSubscriber{NewGenericSubscription(), observer}
}

type concatStringSubscriber struct {
	observable  int
	observer    StringObserver
	observables []StringObservable
	Subscription
}

func (c *concatStringSubscriber) Next(next string) {
	c.observer.Next(next)
}

func (c *concatStringSubscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatStringSubscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatStringObservable struct {
	observables []StringObservable
}

func (m *concatStringObservable) Subscribe(observer StringObserver) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatStringSubscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *StringStream) Concat(observables ...StringObservable) *StringStream {
	return &StringStream{&concatStringObservable{append([]StringObservable{s}, observables...)}}
}

type mergeStringObservable struct {
	delayError  bool
	observables []StringObservable
}

func (m *mergeStringObservable) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next string, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(StringObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *StringStream) Merge(other ...StringObservable) *StringStream {
	if len(other) == 0 {
		return s
	}
	return &StringStream{&mergeStringObservable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *StringStream) MergeDelayError(other ...StringObservable) *StringStream {
	if len(other) == 0 {
		return s
	}
	return &StringStream{&mergeStringObservable{true, append(other, s)}}
}

type catchStringObservable struct {
	parent StringObservable
	catch  StringObservable
}

func (r *catchStringObservable) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	run := func(next string, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(StringObserverFunc(run))
	return subscription
}

func (s *StringStream) Catch(catch StringObservable) *StringStream {
	return &StringStream{&catchStringObservable{s, catch}}
}

type retryStringObservable struct {
	observable StringObservable
}

type retryStringObserver struct {
	observable StringObservable
	observer   StringObserver
}

func (r *retryStringObserver) retry(next string, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(StringObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryStringObservable) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryStringObserver{r.observable, observer}
	r.observable.Subscribe(StringObserverFunc(ro.retry))
	return subscription
}

func (s *StringStream) Retry() *StringStream {
	return &StringStream{&retryStringObservable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *StringStream) Do(f func(next string)) *StringStream {
	return FromStringObservable(MapString2StringObserveNext(s, func(next string) string {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *StringStream) DoOnError(f func(err error)) *StringStream {
	return FromStringObservable(MapString2StringObserveDirect(s, func(next string, err error, complete bool, observer StringObserver) {
		if err != nil {
			f(err)
		}
		PassthroughString(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *StringStream) DoOnComplete(f func()) *StringStream {
	return FromStringObservable(MapString2StringObserveDirect(s, func(next string, err error, complete bool, observer StringObserver) {
		if complete {
			f()
		}
		PassthroughString(next, err, complete, observer)
	}))
}

func (s *StringStream) Reduce(initial string, reducer func(string, string) string) *StringStream {
	value := initial
	return FromStringObservable(MapString2StringObserveDirect(s, func(next string, err error, complete bool, observer StringObserver) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *StringStream) Scan(initial string, f func(string, string) string) *StringStream {
	value := initial
	return FromStringObservable(MapString2StringObserveDirect(s, func(next string, err error, complete bool, observer StringObserver) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutString struct {
	parent  StringObservable
	timeout time.Duration
}

func (t *timeoutString) Subscribe(observer StringObserver) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *StringStream) Timeout(timeout time.Duration) *StringStream {
	return &StringStream{&timeoutString{s, timeout}}
}

type forkedStringStream struct {
	lock      sync.Mutex
	parent    StringObservable
	observers []StringObserver
}

func (f *forkedStringStream) Subscribe(observer StringObserver) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *StringStream) Fork() *StringStream {
	f := &forkedStringStream{parent: s}
	go s.Subscribe(StringObserverFunc(func(n string, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &StringStream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *StringStream) ToOneWithError() (string, error) {
	valuech := make(chan string, 1)
	errch := make(chan error, 1)
	FromStringObservable(oneFilter().String(s)).SubscribeFunc(func(next string, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroString, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *StringStream) ToOne() string {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *StringStream) ToArrayWithError() ([]string, error) {
	array := []string{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *StringStream) ToArray() []string {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *StringStream) ToChannelWithError() (<-chan string, <-chan error) {
	ch := make(chan string, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *StringStream) ToChannel() <-chan string {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *StringStream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapString2IntObserveDirect(s, func(next string, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

type MappingString2BoolFunc func(next string, err error, complete bool, observer BoolObserver)
type MappingString2BoolFuncFactory func(observer BoolObserver) MappingString2BoolFunc

type MappingString2BoolObservable struct {
	parent StringObservable
	mapper MappingString2BoolFuncFactory
}

func (f *MappingString2BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2BoolObservable(parent StringObservable, mapper MappingString2BoolFuncFactory) BoolObservable {
	return &MappingString2BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2BoolObserveDirect(parent StringObservable, mapper MappingString2BoolFunc) BoolObservable {
	return MapString2BoolObservable(parent, func(BoolObserver) MappingString2BoolFunc {
		return mapper
	})
}

func MapString2BoolObserveNext(parent StringObservable, mapper func(string) bool) BoolObservable {
	return MapString2BoolObservable(parent, func(BoolObserver) MappingString2BoolFunc {
		return func(next string, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Bool struct {
	parent StringObservable
	mapper func(string) BoolObservable
}

func (f *flatMapString2Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *StringStream) MapBool(f func(string) bool) *BoolStream {
	return FromBoolObservable(MapString2BoolObserveNext(s, f))
}

func (s *StringStream) FlatMapBool(f func(string) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapString2Bool{s, f}}
}

type MappingString2RuneFunc func(next string, err error, complete bool, observer RuneObserver)
type MappingString2RuneFuncFactory func(observer RuneObserver) MappingString2RuneFunc

type MappingString2RuneObservable struct {
	parent StringObservable
	mapper MappingString2RuneFuncFactory
}

func (f *MappingString2RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2RuneObservable(parent StringObservable, mapper MappingString2RuneFuncFactory) RuneObservable {
	return &MappingString2RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2RuneObserveDirect(parent StringObservable, mapper MappingString2RuneFunc) RuneObservable {
	return MapString2RuneObservable(parent, func(RuneObserver) MappingString2RuneFunc {
		return mapper
	})
}

func MapString2RuneObserveNext(parent StringObservable, mapper func(string) rune) RuneObservable {
	return MapString2RuneObservable(parent, func(RuneObserver) MappingString2RuneFunc {
		return func(next string, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Rune struct {
	parent StringObservable
	mapper func(string) RuneObservable
}

func (f *flatMapString2Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *StringStream) MapRune(f func(string) rune) *RuneStream {
	return FromRuneObservable(MapString2RuneObserveNext(s, f))
}

func (s *StringStream) FlatMapRune(f func(string) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapString2Rune{s, f}}
}

type MappingString2ByteFunc func(next string, err error, complete bool, observer ByteObserver)
type MappingString2ByteFuncFactory func(observer ByteObserver) MappingString2ByteFunc

type MappingString2ByteObservable struct {
	parent StringObservable
	mapper MappingString2ByteFuncFactory
}

func (f *MappingString2ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2ByteObservable(parent StringObservable, mapper MappingString2ByteFuncFactory) ByteObservable {
	return &MappingString2ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2ByteObserveDirect(parent StringObservable, mapper MappingString2ByteFunc) ByteObservable {
	return MapString2ByteObservable(parent, func(ByteObserver) MappingString2ByteFunc {
		return mapper
	})
}

func MapString2ByteObserveNext(parent StringObservable, mapper func(string) byte) ByteObservable {
	return MapString2ByteObservable(parent, func(ByteObserver) MappingString2ByteFunc {
		return func(next string, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Byte struct {
	parent StringObservable
	mapper func(string) ByteObservable
}

func (f *flatMapString2Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *StringStream) MapByte(f func(string) byte) *ByteStream {
	return FromByteObservable(MapString2ByteObserveNext(s, f))
}

func (s *StringStream) FlatMapByte(f func(string) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapString2Byte{s, f}}
}

type MappingString2StringFunc func(next string, err error, complete bool, observer StringObserver)
type MappingString2StringFuncFactory func(observer StringObserver) MappingString2StringFunc

type MappingString2StringObservable struct {
	parent StringObservable
	mapper MappingString2StringFuncFactory
}

func (f *MappingString2StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2StringObservable(parent StringObservable, mapper MappingString2StringFuncFactory) StringObservable {
	return &MappingString2StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2StringObserveDirect(parent StringObservable, mapper MappingString2StringFunc) StringObservable {
	return MapString2StringObservable(parent, func(StringObserver) MappingString2StringFunc {
		return mapper
	})
}

func MapString2StringObserveNext(parent StringObservable, mapper func(string) string) StringObservable {
	return MapString2StringObservable(parent, func(StringObserver) MappingString2StringFunc {
		return func(next string, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2String struct {
	parent StringObservable
	mapper func(string) StringObservable
}

func (f *flatMapString2String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *StringStream) Map(f func(string) string) *StringStream {
	return FromStringObservable(MapString2StringObserveNext(s, f))
}

func (s *StringStream) FlatMap(f func(string) StringObservable) *StringStream {
	return &StringStream{&flatMapString2String{s, f}}
}

type MappingString2UintFunc func(next string, err error, complete bool, observer UintObserver)
type MappingString2UintFuncFactory func(observer UintObserver) MappingString2UintFunc

type MappingString2UintObservable struct {
	parent StringObservable
	mapper MappingString2UintFuncFactory
}

func (f *MappingString2UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2UintObservable(parent StringObservable, mapper MappingString2UintFuncFactory) UintObservable {
	return &MappingString2UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2UintObserveDirect(parent StringObservable, mapper MappingString2UintFunc) UintObservable {
	return MapString2UintObservable(parent, func(UintObserver) MappingString2UintFunc {
		return mapper
	})
}

func MapString2UintObserveNext(parent StringObservable, mapper func(string) uint) UintObservable {
	return MapString2UintObservable(parent, func(UintObserver) MappingString2UintFunc {
		return func(next string, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Uint struct {
	parent StringObservable
	mapper func(string) UintObservable
}

func (f *flatMapString2Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *StringStream) MapUint(f func(string) uint) *UintStream {
	return FromUintObservable(MapString2UintObserveNext(s, f))
}

func (s *StringStream) FlatMapUint(f func(string) UintObservable) *UintStream {
	return &UintStream{&flatMapString2Uint{s, f}}
}

type MappingString2IntFunc func(next string, err error, complete bool, observer IntObserver)
type MappingString2IntFuncFactory func(observer IntObserver) MappingString2IntFunc

type MappingString2IntObservable struct {
	parent StringObservable
	mapper MappingString2IntFuncFactory
}

func (f *MappingString2IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2IntObservable(parent StringObservable, mapper MappingString2IntFuncFactory) IntObservable {
	return &MappingString2IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2IntObserveDirect(parent StringObservable, mapper MappingString2IntFunc) IntObservable {
	return MapString2IntObservable(parent, func(IntObserver) MappingString2IntFunc {
		return mapper
	})
}

func MapString2IntObserveNext(parent StringObservable, mapper func(string) int) IntObservable {
	return MapString2IntObservable(parent, func(IntObserver) MappingString2IntFunc {
		return func(next string, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Int struct {
	parent StringObservable
	mapper func(string) IntObservable
}

func (f *flatMapString2Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *StringStream) MapInt(f func(string) int) *IntStream {
	return FromIntObservable(MapString2IntObserveNext(s, f))
}

func (s *StringStream) FlatMapInt(f func(string) IntObservable) *IntStream {
	return &IntStream{&flatMapString2Int{s, f}}
}

type MappingString2Uint8Func func(next string, err error, complete bool, observer Uint8Observer)
type MappingString2Uint8FuncFactory func(observer Uint8Observer) MappingString2Uint8Func

type MappingString2Uint8Observable struct {
	parent StringObservable
	mapper MappingString2Uint8FuncFactory
}

func (f *MappingString2Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2Uint8Observable(parent StringObservable, mapper MappingString2Uint8FuncFactory) Uint8Observable {
	return &MappingString2Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2Uint8ObserveDirect(parent StringObservable, mapper MappingString2Uint8Func) Uint8Observable {
	return MapString2Uint8Observable(parent, func(Uint8Observer) MappingString2Uint8Func {
		return mapper
	})
}

func MapString2Uint8ObserveNext(parent StringObservable, mapper func(string) uint8) Uint8Observable {
	return MapString2Uint8Observable(parent, func(Uint8Observer) MappingString2Uint8Func {
		return func(next string, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Uint8 struct {
	parent StringObservable
	mapper func(string) Uint8Observable
}

func (f *flatMapString2Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *StringStream) MapUint8(f func(string) uint8) *Uint8Stream {
	return FromUint8Observable(MapString2Uint8ObserveNext(s, f))
}

func (s *StringStream) FlatMapUint8(f func(string) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapString2Uint8{s, f}}
}

type MappingString2Int8Func func(next string, err error, complete bool, observer Int8Observer)
type MappingString2Int8FuncFactory func(observer Int8Observer) MappingString2Int8Func

type MappingString2Int8Observable struct {
	parent StringObservable
	mapper MappingString2Int8FuncFactory
}

func (f *MappingString2Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2Int8Observable(parent StringObservable, mapper MappingString2Int8FuncFactory) Int8Observable {
	return &MappingString2Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2Int8ObserveDirect(parent StringObservable, mapper MappingString2Int8Func) Int8Observable {
	return MapString2Int8Observable(parent, func(Int8Observer) MappingString2Int8Func {
		return mapper
	})
}

func MapString2Int8ObserveNext(parent StringObservable, mapper func(string) int8) Int8Observable {
	return MapString2Int8Observable(parent, func(Int8Observer) MappingString2Int8Func {
		return func(next string, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Int8 struct {
	parent StringObservable
	mapper func(string) Int8Observable
}

func (f *flatMapString2Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *StringStream) MapInt8(f func(string) int8) *Int8Stream {
	return FromInt8Observable(MapString2Int8ObserveNext(s, f))
}

func (s *StringStream) FlatMapInt8(f func(string) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapString2Int8{s, f}}
}

type MappingString2Uint16Func func(next string, err error, complete bool, observer Uint16Observer)
type MappingString2Uint16FuncFactory func(observer Uint16Observer) MappingString2Uint16Func

type MappingString2Uint16Observable struct {
	parent StringObservable
	mapper MappingString2Uint16FuncFactory
}

func (f *MappingString2Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2Uint16Observable(parent StringObservable, mapper MappingString2Uint16FuncFactory) Uint16Observable {
	return &MappingString2Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2Uint16ObserveDirect(parent StringObservable, mapper MappingString2Uint16Func) Uint16Observable {
	return MapString2Uint16Observable(parent, func(Uint16Observer) MappingString2Uint16Func {
		return mapper
	})
}

func MapString2Uint16ObserveNext(parent StringObservable, mapper func(string) uint16) Uint16Observable {
	return MapString2Uint16Observable(parent, func(Uint16Observer) MappingString2Uint16Func {
		return func(next string, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Uint16 struct {
	parent StringObservable
	mapper func(string) Uint16Observable
}

func (f *flatMapString2Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *StringStream) MapUint16(f func(string) uint16) *Uint16Stream {
	return FromUint16Observable(MapString2Uint16ObserveNext(s, f))
}

func (s *StringStream) FlatMapUint16(f func(string) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapString2Uint16{s, f}}
}

type MappingString2Int16Func func(next string, err error, complete bool, observer Int16Observer)
type MappingString2Int16FuncFactory func(observer Int16Observer) MappingString2Int16Func

type MappingString2Int16Observable struct {
	parent StringObservable
	mapper MappingString2Int16FuncFactory
}

func (f *MappingString2Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2Int16Observable(parent StringObservable, mapper MappingString2Int16FuncFactory) Int16Observable {
	return &MappingString2Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2Int16ObserveDirect(parent StringObservable, mapper MappingString2Int16Func) Int16Observable {
	return MapString2Int16Observable(parent, func(Int16Observer) MappingString2Int16Func {
		return mapper
	})
}

func MapString2Int16ObserveNext(parent StringObservable, mapper func(string) int16) Int16Observable {
	return MapString2Int16Observable(parent, func(Int16Observer) MappingString2Int16Func {
		return func(next string, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Int16 struct {
	parent StringObservable
	mapper func(string) Int16Observable
}

func (f *flatMapString2Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *StringStream) MapInt16(f func(string) int16) *Int16Stream {
	return FromInt16Observable(MapString2Int16ObserveNext(s, f))
}

func (s *StringStream) FlatMapInt16(f func(string) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapString2Int16{s, f}}
}

type MappingString2Uint32Func func(next string, err error, complete bool, observer Uint32Observer)
type MappingString2Uint32FuncFactory func(observer Uint32Observer) MappingString2Uint32Func

type MappingString2Uint32Observable struct {
	parent StringObservable
	mapper MappingString2Uint32FuncFactory
}

func (f *MappingString2Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2Uint32Observable(parent StringObservable, mapper MappingString2Uint32FuncFactory) Uint32Observable {
	return &MappingString2Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2Uint32ObserveDirect(parent StringObservable, mapper MappingString2Uint32Func) Uint32Observable {
	return MapString2Uint32Observable(parent, func(Uint32Observer) MappingString2Uint32Func {
		return mapper
	})
}

func MapString2Uint32ObserveNext(parent StringObservable, mapper func(string) uint32) Uint32Observable {
	return MapString2Uint32Observable(parent, func(Uint32Observer) MappingString2Uint32Func {
		return func(next string, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Uint32 struct {
	parent StringObservable
	mapper func(string) Uint32Observable
}

func (f *flatMapString2Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *StringStream) MapUint32(f func(string) uint32) *Uint32Stream {
	return FromUint32Observable(MapString2Uint32ObserveNext(s, f))
}

func (s *StringStream) FlatMapUint32(f func(string) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapString2Uint32{s, f}}
}

type MappingString2Int32Func func(next string, err error, complete bool, observer Int32Observer)
type MappingString2Int32FuncFactory func(observer Int32Observer) MappingString2Int32Func

type MappingString2Int32Observable struct {
	parent StringObservable
	mapper MappingString2Int32FuncFactory
}

func (f *MappingString2Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2Int32Observable(parent StringObservable, mapper MappingString2Int32FuncFactory) Int32Observable {
	return &MappingString2Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2Int32ObserveDirect(parent StringObservable, mapper MappingString2Int32Func) Int32Observable {
	return MapString2Int32Observable(parent, func(Int32Observer) MappingString2Int32Func {
		return mapper
	})
}

func MapString2Int32ObserveNext(parent StringObservable, mapper func(string) int32) Int32Observable {
	return MapString2Int32Observable(parent, func(Int32Observer) MappingString2Int32Func {
		return func(next string, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Int32 struct {
	parent StringObservable
	mapper func(string) Int32Observable
}

func (f *flatMapString2Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *StringStream) MapInt32(f func(string) int32) *Int32Stream {
	return FromInt32Observable(MapString2Int32ObserveNext(s, f))
}

func (s *StringStream) FlatMapInt32(f func(string) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapString2Int32{s, f}}
}

type MappingString2Uint64Func func(next string, err error, complete bool, observer Uint64Observer)
type MappingString2Uint64FuncFactory func(observer Uint64Observer) MappingString2Uint64Func

type MappingString2Uint64Observable struct {
	parent StringObservable
	mapper MappingString2Uint64FuncFactory
}

func (f *MappingString2Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2Uint64Observable(parent StringObservable, mapper MappingString2Uint64FuncFactory) Uint64Observable {
	return &MappingString2Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2Uint64ObserveDirect(parent StringObservable, mapper MappingString2Uint64Func) Uint64Observable {
	return MapString2Uint64Observable(parent, func(Uint64Observer) MappingString2Uint64Func {
		return mapper
	})
}

func MapString2Uint64ObserveNext(parent StringObservable, mapper func(string) uint64) Uint64Observable {
	return MapString2Uint64Observable(parent, func(Uint64Observer) MappingString2Uint64Func {
		return func(next string, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Uint64 struct {
	parent StringObservable
	mapper func(string) Uint64Observable
}

func (f *flatMapString2Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *StringStream) MapUint64(f func(string) uint64) *Uint64Stream {
	return FromUint64Observable(MapString2Uint64ObserveNext(s, f))
}

func (s *StringStream) FlatMapUint64(f func(string) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapString2Uint64{s, f}}
}

type MappingString2Int64Func func(next string, err error, complete bool, observer Int64Observer)
type MappingString2Int64FuncFactory func(observer Int64Observer) MappingString2Int64Func

type MappingString2Int64Observable struct {
	parent StringObservable
	mapper MappingString2Int64FuncFactory
}

func (f *MappingString2Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2Int64Observable(parent StringObservable, mapper MappingString2Int64FuncFactory) Int64Observable {
	return &MappingString2Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2Int64ObserveDirect(parent StringObservable, mapper MappingString2Int64Func) Int64Observable {
	return MapString2Int64Observable(parent, func(Int64Observer) MappingString2Int64Func {
		return mapper
	})
}

func MapString2Int64ObserveNext(parent StringObservable, mapper func(string) int64) Int64Observable {
	return MapString2Int64Observable(parent, func(Int64Observer) MappingString2Int64Func {
		return func(next string, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Int64 struct {
	parent StringObservable
	mapper func(string) Int64Observable
}

func (f *flatMapString2Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *StringStream) MapInt64(f func(string) int64) *Int64Stream {
	return FromInt64Observable(MapString2Int64ObserveNext(s, f))
}

func (s *StringStream) FlatMapInt64(f func(string) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapString2Int64{s, f}}
}

type MappingString2Float32Func func(next string, err error, complete bool, observer Float32Observer)
type MappingString2Float32FuncFactory func(observer Float32Observer) MappingString2Float32Func

type MappingString2Float32Observable struct {
	parent StringObservable
	mapper MappingString2Float32FuncFactory
}

func (f *MappingString2Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2Float32Observable(parent StringObservable, mapper MappingString2Float32FuncFactory) Float32Observable {
	return &MappingString2Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2Float32ObserveDirect(parent StringObservable, mapper MappingString2Float32Func) Float32Observable {
	return MapString2Float32Observable(parent, func(Float32Observer) MappingString2Float32Func {
		return mapper
	})
}

func MapString2Float32ObserveNext(parent StringObservable, mapper func(string) float32) Float32Observable {
	return MapString2Float32Observable(parent, func(Float32Observer) MappingString2Float32Func {
		return func(next string, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Float32 struct {
	parent StringObservable
	mapper func(string) Float32Observable
}

func (f *flatMapString2Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *StringStream) MapFloat32(f func(string) float32) *Float32Stream {
	return FromFloat32Observable(MapString2Float32ObserveNext(s, f))
}

func (s *StringStream) FlatMapFloat32(f func(string) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapString2Float32{s, f}}
}

type MappingString2Float64Func func(next string, err error, complete bool, observer Float64Observer)
type MappingString2Float64FuncFactory func(observer Float64Observer) MappingString2Float64Func

type MappingString2Float64Observable struct {
	parent StringObservable
	mapper MappingString2Float64FuncFactory
}

func (f *MappingString2Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2Float64Observable(parent StringObservable, mapper MappingString2Float64FuncFactory) Float64Observable {
	return &MappingString2Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2Float64ObserveDirect(parent StringObservable, mapper MappingString2Float64Func) Float64Observable {
	return MapString2Float64Observable(parent, func(Float64Observer) MappingString2Float64Func {
		return mapper
	})
}

func MapString2Float64ObserveNext(parent StringObservable, mapper func(string) float64) Float64Observable {
	return MapString2Float64Observable(parent, func(Float64Observer) MappingString2Float64Func {
		return func(next string, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Float64 struct {
	parent StringObservable
	mapper func(string) Float64Observable
}

func (f *flatMapString2Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *StringStream) MapFloat64(f func(string) float64) *Float64Stream {
	return FromFloat64Observable(MapString2Float64ObserveNext(s, f))
}

func (s *StringStream) FlatMapFloat64(f func(string) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapString2Float64{s, f}}
}

type MappingString2Complex64Func func(next string, err error, complete bool, observer Complex64Observer)
type MappingString2Complex64FuncFactory func(observer Complex64Observer) MappingString2Complex64Func

type MappingString2Complex64Observable struct {
	parent StringObservable
	mapper MappingString2Complex64FuncFactory
}

func (f *MappingString2Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2Complex64Observable(parent StringObservable, mapper MappingString2Complex64FuncFactory) Complex64Observable {
	return &MappingString2Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2Complex64ObserveDirect(parent StringObservable, mapper MappingString2Complex64Func) Complex64Observable {
	return MapString2Complex64Observable(parent, func(Complex64Observer) MappingString2Complex64Func {
		return mapper
	})
}

func MapString2Complex64ObserveNext(parent StringObservable, mapper func(string) complex64) Complex64Observable {
	return MapString2Complex64Observable(parent, func(Complex64Observer) MappingString2Complex64Func {
		return func(next string, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Complex64 struct {
	parent StringObservable
	mapper func(string) Complex64Observable
}

func (f *flatMapString2Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *StringStream) MapComplex64(f func(string) complex64) *Complex64Stream {
	return FromComplex64Observable(MapString2Complex64ObserveNext(s, f))
}

func (s *StringStream) FlatMapComplex64(f func(string) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapString2Complex64{s, f}}
}

type MappingString2Complex128Func func(next string, err error, complete bool, observer Complex128Observer)
type MappingString2Complex128FuncFactory func(observer Complex128Observer) MappingString2Complex128Func

type MappingString2Complex128Observable struct {
	parent StringObservable
	mapper MappingString2Complex128FuncFactory
}

func (f *MappingString2Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2Complex128Observable(parent StringObservable, mapper MappingString2Complex128FuncFactory) Complex128Observable {
	return &MappingString2Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2Complex128ObserveDirect(parent StringObservable, mapper MappingString2Complex128Func) Complex128Observable {
	return MapString2Complex128Observable(parent, func(Complex128Observer) MappingString2Complex128Func {
		return mapper
	})
}

func MapString2Complex128ObserveNext(parent StringObservable, mapper func(string) complex128) Complex128Observable {
	return MapString2Complex128Observable(parent, func(Complex128Observer) MappingString2Complex128Func {
		return func(next string, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Complex128 struct {
	parent StringObservable
	mapper func(string) Complex128Observable
}

func (f *flatMapString2Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *StringStream) MapComplex128(f func(string) complex128) *Complex128Stream {
	return FromComplex128Observable(MapString2Complex128ObserveNext(s, f))
}

func (s *StringStream) FlatMapComplex128(f func(string) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapString2Complex128{s, f}}
}

type MappingString2TimeFunc func(next string, err error, complete bool, observer TimeObserver)
type MappingString2TimeFuncFactory func(observer TimeObserver) MappingString2TimeFunc

type MappingString2TimeObservable struct {
	parent StringObservable
	mapper MappingString2TimeFuncFactory
}

func (f *MappingString2TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2TimeObservable(parent StringObservable, mapper MappingString2TimeFuncFactory) TimeObservable {
	return &MappingString2TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2TimeObserveDirect(parent StringObservable, mapper MappingString2TimeFunc) TimeObservable {
	return MapString2TimeObservable(parent, func(TimeObserver) MappingString2TimeFunc {
		return mapper
	})
}

func MapString2TimeObserveNext(parent StringObservable, mapper func(string) time.Time) TimeObservable {
	return MapString2TimeObservable(parent, func(TimeObserver) MappingString2TimeFunc {
		return func(next string, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Time struct {
	parent StringObservable
	mapper func(string) TimeObservable
}

func (f *flatMapString2Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *StringStream) MapTime(f func(string) time.Time) *TimeStream {
	return FromTimeObservable(MapString2TimeObserveNext(s, f))
}

func (s *StringStream) FlatMapTime(f func(string) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapString2Time{s, f}}
}

type MappingString2DurationFunc func(next string, err error, complete bool, observer DurationObserver)
type MappingString2DurationFuncFactory func(observer DurationObserver) MappingString2DurationFunc

type MappingString2DurationObservable struct {
	parent StringObservable
	mapper MappingString2DurationFuncFactory
}

func (f *MappingString2DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapString2DurationObservable(parent StringObservable, mapper MappingString2DurationFuncFactory) DurationObservable {
	return &MappingString2DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2DurationObserveDirect(parent StringObservable, mapper MappingString2DurationFunc) DurationObservable {
	return MapString2DurationObservable(parent, func(DurationObserver) MappingString2DurationFunc {
		return mapper
	})
}

func MapString2DurationObserveNext(parent StringObservable, mapper func(string) time.Duration) DurationObservable {
	return MapString2DurationObservable(parent, func(DurationObserver) MappingString2DurationFunc {
		return func(next string, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapString2Duration struct {
	parent StringObservable
	mapper func(string) DurationObservable
}

func (f *flatMapString2Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(StringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *StringStream) MapDuration(f func(string) time.Duration) *DurationStream {
	return FromDurationObservable(MapString2DurationObserveNext(s, f))
}

func (s *StringStream) FlatMapDuration(f func(string) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapString2Duration{s, f}}
}

type UintObserver interface {
	Next(uint)
	TerminationObserver
}

// A UintSubscriber represents a subscribed UintObserver.
type UintSubscriber interface {
	Subscription
	UintObserver
}

type implUintSubscriber struct {
	Subscription
	UintObserver
}

func UintObserverAsGenericObserver(observer UintObserver) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(uint))
		}
	})
}

func GenericObserverAsUintObserver(observer GenericObserver) UintObserver {
	return UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type UintObservableFactory func(observer UintObserver, subscription Subscription)

func (f UintObservableFactory) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateUint calls f(observer, subscription) to produce values for a stream.
func CreateUint(f func(observer UintObserver, subscription Subscription)) *UintStream {
	return FromUintObservable(UintObservableFactory(f))
}

// Repeat value count times.
func RepeatUint(value uint, count int) *UintStream {
	return CreateUint(func(observer UintObserver, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartUint is designed to be used with functions that return a
// (uint, error) tuple.
//
// If the error is non-nil the returned UintStream will be that error,
// otherwise it will be a single-value stream of uint.
func StartUint(f func() (uint, error)) *UintStream {
	return CreateUint(func(observer UintObserver, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughUint(next uint, err error, complete bool, observer UintObserver) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroUint = *new(uint)

type UintObserverFunc func(uint, error, bool)

func (f UintObserverFunc) Next(next uint)  { f(next, nil, false) }
func (f UintObserverFunc) Error(err error) { f(zeroUint, err, false) }
func (f UintObserverFunc) Complete()       { f(zeroUint, nil, true) }

type UintObservable interface {
	Subscribe(UintObserver) Subscription
}

// Convert a GenericObservableFilter to a UintObservable
func (f GenericObservableFilterFactory) Uint(parent UintObservable) UintObservable {
	return MapUint2UintObservable(parent, func(observer UintObserver) MappingUint2UintFunc {
		gobserver := UintObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next uint, err error, complete bool, observer UintObserver) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverUint() *UintStream {
	return CreateUint(func(observer UintObserver, subscription Subscription) {})
}

func EmptyUint() *UintStream {
	return CreateUint(func(observer UintObserver, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowUint(err error) *UintStream {
	return CreateUint(func(observer UintObserver, subscription Subscription) {
		observer.Error(err)
	})
}

func FromUintArray(array []uint) *UintStream {
	return CreateUint(func(observer UintObserver, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromUints(array ...uint) *UintStream {
	return FromUintArray(array)
}

func JustUint(element uint) *UintStream {
	return FromUintArray([]uint{element})
}

func MergeUint(observables ...UintObservable) *UintStream {
	if len(observables) == 0 {
		return EmptyUint()
	}
	return (&UintStream{observables[0]}).Merge(observables[1:]...)
}

func MergeUintDelayError(observables ...UintObservable) *UintStream {
	if len(observables) == 0 {
		return EmptyUint()
	}
	return (&UintStream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromUintChannel(ch <-chan uint) *UintStream {
	return CreateUint(func(observer UintObserver, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type UintStream struct {
	UintObservable
}

func FromUintObservable(observable UintObservable) *UintStream {
	return &UintStream{observable}
}

func (s *UintStream) SubscribeFunc(f func(uint, error, bool)) Subscription {
	return s.Subscribe(UintObserverFunc(f))
}

func (s *UintStream) SubscribeNext(f func(v uint)) Subscription {
	return s.SubscribeFunc(func(next uint, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *UintStream) Distinct() *UintStream {
	return FromUintObservable(distinctFilter().Uint(s))
}

// ElementAt yields the Nth element of the stream.
func (s *UintStream) ElementAt(n int) *UintStream {
	return FromUintObservable(elementAtFilter(n).Uint(s))
}

// Filter elements in the stream on a function.
func (s *UintStream) Filter(f func(uint) bool) *UintStream {
	return FromUintObservable(filterFilter(func(v interface{}) bool { return f(v.(uint)) }).Uint(s))
}

// Last returns just the first element of the stream.
func (s *UintStream) First() *UintStream {
	return FromUintObservable(firstFilter().Uint(s))
}

// Last returns just the last element of the stream.
func (s *UintStream) Last() *UintStream {
	return FromUintObservable(lastFilter().Uint(s))
}

// SkipLast skips the first N elements of the stream.
func (s *UintStream) Skip(n int) *UintStream {
	return FromUintObservable(skipFilter(n).Uint(s))
}

// SkipLast skips the last N elements of the stream.
func (s *UintStream) SkipLast(n int) *UintStream {
	return FromUintObservable(skipLastFilter(n).Uint(s))
}

// Take returns just the first N elements of the stream.
func (s *UintStream) Take(n int) *UintStream {
	return FromUintObservable(takeFilter(n).Uint(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *UintStream) TakeLast(n int) *UintStream {
	return FromUintObservable(takeLastFilter(n).Uint(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *UintStream) IgnoreElements() *UintStream {
	return FromUintObservable(ignoreElementsFilter().Uint(s))
}

func (s *UintStream) Replay(size int, duration time.Duration) *UintStream {
	return FromUintObservable(replayFilter(size, duration).Uint(s))
}

func (s *UintStream) Sample(duration time.Duration) *UintStream {
	return FromUintObservable(sampleFilter(duration).Uint(s))
}

func (s *UintStream) Debounce(duration time.Duration) *UintStream {
	return FromUintObservable(debounceFilter(duration).Uint(s))
}

// Wait for completion of the stream and return any error.
func (s *UintStream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeUintSubscriber(observer UintObserver) UintSubscriber {
	if subscriber, ok := observer.(UintSubscriber); ok {
		return subscriber
	}
	return &implUintSubscriber{NewGenericSubscription(), observer}
}

type concatUintSubscriber struct {
	observable  int
	observer    UintObserver
	observables []UintObservable
	Subscription
}

func (c *concatUintSubscriber) Next(next uint) {
	c.observer.Next(next)
}

func (c *concatUintSubscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatUintSubscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatUintObservable struct {
	observables []UintObservable
}

func (m *concatUintObservable) Subscribe(observer UintObserver) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatUintSubscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *UintStream) Concat(observables ...UintObservable) *UintStream {
	return &UintStream{&concatUintObservable{append([]UintObservable{s}, observables...)}}
}

type mergeUintObservable struct {
	delayError  bool
	observables []UintObservable
}

func (m *mergeUintObservable) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next uint, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(UintObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *UintStream) Merge(other ...UintObservable) *UintStream {
	if len(other) == 0 {
		return s
	}
	return &UintStream{&mergeUintObservable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *UintStream) MergeDelayError(other ...UintObservable) *UintStream {
	if len(other) == 0 {
		return s
	}
	return &UintStream{&mergeUintObservable{true, append(other, s)}}
}

type catchUintObservable struct {
	parent UintObservable
	catch  UintObservable
}

func (r *catchUintObservable) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	run := func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(UintObserverFunc(run))
	return subscription
}

func (s *UintStream) Catch(catch UintObservable) *UintStream {
	return &UintStream{&catchUintObservable{s, catch}}
}

type retryUintObservable struct {
	observable UintObservable
}

type retryUintObserver struct {
	observable UintObservable
	observer   UintObserver
}

func (r *retryUintObserver) retry(next uint, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(UintObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryUintObservable) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryUintObserver{r.observable, observer}
	r.observable.Subscribe(UintObserverFunc(ro.retry))
	return subscription
}

func (s *UintStream) Retry() *UintStream {
	return &UintStream{&retryUintObservable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *UintStream) Do(f func(next uint)) *UintStream {
	return FromUintObservable(MapUint2UintObserveNext(s, func(next uint) uint {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *UintStream) DoOnError(f func(err error)) *UintStream {
	return FromUintObservable(MapUint2UintObserveDirect(s, func(next uint, err error, complete bool, observer UintObserver) {
		if err != nil {
			f(err)
		}
		PassthroughUint(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *UintStream) DoOnComplete(f func()) *UintStream {
	return FromUintObservable(MapUint2UintObserveDirect(s, func(next uint, err error, complete bool, observer UintObserver) {
		if complete {
			f()
		}
		PassthroughUint(next, err, complete, observer)
	}))
}

func (s *UintStream) Reduce(initial uint, reducer func(uint, uint) uint) *UintStream {
	value := initial
	return FromUintObservable(MapUint2UintObserveDirect(s, func(next uint, err error, complete bool, observer UintObserver) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *UintStream) Scan(initial uint, f func(uint, uint) uint) *UintStream {
	value := initial
	return FromUintObservable(MapUint2UintObserveDirect(s, func(next uint, err error, complete bool, observer UintObserver) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutUint struct {
	parent  UintObservable
	timeout time.Duration
}

func (t *timeoutUint) Subscribe(observer UintObserver) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *UintStream) Timeout(timeout time.Duration) *UintStream {
	return &UintStream{&timeoutUint{s, timeout}}
}

type forkedUintStream struct {
	lock      sync.Mutex
	parent    UintObservable
	observers []UintObserver
}

func (f *forkedUintStream) Subscribe(observer UintObserver) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *UintStream) Fork() *UintStream {
	f := &forkedUintStream{parent: s}
	go s.Subscribe(UintObserverFunc(func(n uint, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &UintStream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *UintStream) ToOneWithError() (uint, error) {
	valuech := make(chan uint, 1)
	errch := make(chan error, 1)
	FromUintObservable(oneFilter().Uint(s)).SubscribeFunc(func(next uint, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroUint, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *UintStream) ToOne() uint {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *UintStream) ToArrayWithError() ([]uint, error) {
	array := []uint{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *UintStream) ToArray() []uint {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *UintStream) ToChannelWithError() (<-chan uint, <-chan error) {
	ch := make(chan uint, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *UintStream) ToChannel() <-chan uint {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *UintStream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapUint2IntObserveDirect(s, func(next uint, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

func (s *UintStream) Average() *UintStream {
	var sum uint
	var count uint
	return FromUintObservable(MapUint2UintObserveDirect(s, func(next uint, err error, complete bool, observer UintObserver) {
		switch {
		case err != nil:
			observer.Next(sum / count)
			observer.Error(err)
		case complete:
			observer.Next(sum / count)
			observer.Complete()
		default:
			sum += next
			count++
		}
	}))
}

func (s *UintStream) Sum() *UintStream {
	var sum uint
	return FromUintObservable(MapUint2UintObserveDirect(s, func(next uint, err error, complete bool, observer UintObserver) {
		switch {
		case err != nil:
			observer.Next(sum)
			observer.Error(err)
		case complete:
			observer.Next(sum)
			observer.Complete()
		default:
			sum += next
		}
	}))
}

func (s *UintStream) Min() *UintStream {
	started := false
	var min uint
	return FromUintObservable(MapUint2UintObserveDirect(s, func(next uint, err error, complete bool, observer UintObserver) {
		switch {
		case err != nil:
			if started {
				observer.Next(min)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(min)
			}
			observer.Complete()
		default:
			if started {
				if min > next {
					min = next
				}
			} else {
				min = next
				started = true
			}
		}
	}))
}

func (s *UintStream) Max() *UintStream {
	started := false
	var max uint
	return FromUintObservable(MapUint2UintObserveDirect(s, func(next uint, err error, complete bool, observer UintObserver) {
		switch {
		case err != nil:
			if started {
				observer.Next(max)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(max)
			}
			observer.Complete()
		default:
			if started {
				if max <= next {
					max = next
				}
			} else {
				max = next
				started = true
			}
		}
	}))
}

type MappingUint2BoolFunc func(next uint, err error, complete bool, observer BoolObserver)
type MappingUint2BoolFuncFactory func(observer BoolObserver) MappingUint2BoolFunc

type MappingUint2BoolObservable struct {
	parent UintObservable
	mapper MappingUint2BoolFuncFactory
}

func (f *MappingUint2BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2BoolObservable(parent UintObservable, mapper MappingUint2BoolFuncFactory) BoolObservable {
	return &MappingUint2BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2BoolObserveDirect(parent UintObservable, mapper MappingUint2BoolFunc) BoolObservable {
	return MapUint2BoolObservable(parent, func(BoolObserver) MappingUint2BoolFunc {
		return mapper
	})
}

func MapUint2BoolObserveNext(parent UintObservable, mapper func(uint) bool) BoolObservable {
	return MapUint2BoolObservable(parent, func(BoolObserver) MappingUint2BoolFunc {
		return func(next uint, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Bool struct {
	parent UintObservable
	mapper func(uint) BoolObservable
}

func (f *flatMapUint2Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *UintStream) MapBool(f func(uint) bool) *BoolStream {
	return FromBoolObservable(MapUint2BoolObserveNext(s, f))
}

func (s *UintStream) FlatMapBool(f func(uint) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapUint2Bool{s, f}}
}

type MappingUint2RuneFunc func(next uint, err error, complete bool, observer RuneObserver)
type MappingUint2RuneFuncFactory func(observer RuneObserver) MappingUint2RuneFunc

type MappingUint2RuneObservable struct {
	parent UintObservable
	mapper MappingUint2RuneFuncFactory
}

func (f *MappingUint2RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2RuneObservable(parent UintObservable, mapper MappingUint2RuneFuncFactory) RuneObservable {
	return &MappingUint2RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2RuneObserveDirect(parent UintObservable, mapper MappingUint2RuneFunc) RuneObservable {
	return MapUint2RuneObservable(parent, func(RuneObserver) MappingUint2RuneFunc {
		return mapper
	})
}

func MapUint2RuneObserveNext(parent UintObservable, mapper func(uint) rune) RuneObservable {
	return MapUint2RuneObservable(parent, func(RuneObserver) MappingUint2RuneFunc {
		return func(next uint, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Rune struct {
	parent UintObservable
	mapper func(uint) RuneObservable
}

func (f *flatMapUint2Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *UintStream) MapRune(f func(uint) rune) *RuneStream {
	return FromRuneObservable(MapUint2RuneObserveNext(s, f))
}

func (s *UintStream) FlatMapRune(f func(uint) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapUint2Rune{s, f}}
}

type MappingUint2ByteFunc func(next uint, err error, complete bool, observer ByteObserver)
type MappingUint2ByteFuncFactory func(observer ByteObserver) MappingUint2ByteFunc

type MappingUint2ByteObservable struct {
	parent UintObservable
	mapper MappingUint2ByteFuncFactory
}

func (f *MappingUint2ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2ByteObservable(parent UintObservable, mapper MappingUint2ByteFuncFactory) ByteObservable {
	return &MappingUint2ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2ByteObserveDirect(parent UintObservable, mapper MappingUint2ByteFunc) ByteObservable {
	return MapUint2ByteObservable(parent, func(ByteObserver) MappingUint2ByteFunc {
		return mapper
	})
}

func MapUint2ByteObserveNext(parent UintObservable, mapper func(uint) byte) ByteObservable {
	return MapUint2ByteObservable(parent, func(ByteObserver) MappingUint2ByteFunc {
		return func(next uint, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Byte struct {
	parent UintObservable
	mapper func(uint) ByteObservable
}

func (f *flatMapUint2Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *UintStream) MapByte(f func(uint) byte) *ByteStream {
	return FromByteObservable(MapUint2ByteObserveNext(s, f))
}

func (s *UintStream) FlatMapByte(f func(uint) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapUint2Byte{s, f}}
}

type MappingUint2StringFunc func(next uint, err error, complete bool, observer StringObserver)
type MappingUint2StringFuncFactory func(observer StringObserver) MappingUint2StringFunc

type MappingUint2StringObservable struct {
	parent UintObservable
	mapper MappingUint2StringFuncFactory
}

func (f *MappingUint2StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2StringObservable(parent UintObservable, mapper MappingUint2StringFuncFactory) StringObservable {
	return &MappingUint2StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2StringObserveDirect(parent UintObservable, mapper MappingUint2StringFunc) StringObservable {
	return MapUint2StringObservable(parent, func(StringObserver) MappingUint2StringFunc {
		return mapper
	})
}

func MapUint2StringObserveNext(parent UintObservable, mapper func(uint) string) StringObservable {
	return MapUint2StringObservable(parent, func(StringObserver) MappingUint2StringFunc {
		return func(next uint, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2String struct {
	parent UintObservable
	mapper func(uint) StringObservable
}

func (f *flatMapUint2String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *UintStream) MapString(f func(uint) string) *StringStream {
	return FromStringObservable(MapUint2StringObserveNext(s, f))
}

func (s *UintStream) FlatMapString(f func(uint) StringObservable) *StringStream {
	return &StringStream{&flatMapUint2String{s, f}}
}

type MappingUint2UintFunc func(next uint, err error, complete bool, observer UintObserver)
type MappingUint2UintFuncFactory func(observer UintObserver) MappingUint2UintFunc

type MappingUint2UintObservable struct {
	parent UintObservable
	mapper MappingUint2UintFuncFactory
}

func (f *MappingUint2UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2UintObservable(parent UintObservable, mapper MappingUint2UintFuncFactory) UintObservable {
	return &MappingUint2UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2UintObserveDirect(parent UintObservable, mapper MappingUint2UintFunc) UintObservable {
	return MapUint2UintObservable(parent, func(UintObserver) MappingUint2UintFunc {
		return mapper
	})
}

func MapUint2UintObserveNext(parent UintObservable, mapper func(uint) uint) UintObservable {
	return MapUint2UintObservable(parent, func(UintObserver) MappingUint2UintFunc {
		return func(next uint, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Uint struct {
	parent UintObservable
	mapper func(uint) UintObservable
}

func (f *flatMapUint2Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *UintStream) Map(f func(uint) uint) *UintStream {
	return FromUintObservable(MapUint2UintObserveNext(s, f))
}

func (s *UintStream) FlatMap(f func(uint) UintObservable) *UintStream {
	return &UintStream{&flatMapUint2Uint{s, f}}
}

type MappingUint2IntFunc func(next uint, err error, complete bool, observer IntObserver)
type MappingUint2IntFuncFactory func(observer IntObserver) MappingUint2IntFunc

type MappingUint2IntObservable struct {
	parent UintObservable
	mapper MappingUint2IntFuncFactory
}

func (f *MappingUint2IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2IntObservable(parent UintObservable, mapper MappingUint2IntFuncFactory) IntObservable {
	return &MappingUint2IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2IntObserveDirect(parent UintObservable, mapper MappingUint2IntFunc) IntObservable {
	return MapUint2IntObservable(parent, func(IntObserver) MappingUint2IntFunc {
		return mapper
	})
}

func MapUint2IntObserveNext(parent UintObservable, mapper func(uint) int) IntObservable {
	return MapUint2IntObservable(parent, func(IntObserver) MappingUint2IntFunc {
		return func(next uint, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Int struct {
	parent UintObservable
	mapper func(uint) IntObservable
}

func (f *flatMapUint2Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *UintStream) MapInt(f func(uint) int) *IntStream {
	return FromIntObservable(MapUint2IntObserveNext(s, f))
}

func (s *UintStream) FlatMapInt(f func(uint) IntObservable) *IntStream {
	return &IntStream{&flatMapUint2Int{s, f}}
}

type MappingUint2Uint8Func func(next uint, err error, complete bool, observer Uint8Observer)
type MappingUint2Uint8FuncFactory func(observer Uint8Observer) MappingUint2Uint8Func

type MappingUint2Uint8Observable struct {
	parent UintObservable
	mapper MappingUint2Uint8FuncFactory
}

func (f *MappingUint2Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2Uint8Observable(parent UintObservable, mapper MappingUint2Uint8FuncFactory) Uint8Observable {
	return &MappingUint2Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2Uint8ObserveDirect(parent UintObservable, mapper MappingUint2Uint8Func) Uint8Observable {
	return MapUint2Uint8Observable(parent, func(Uint8Observer) MappingUint2Uint8Func {
		return mapper
	})
}

func MapUint2Uint8ObserveNext(parent UintObservable, mapper func(uint) uint8) Uint8Observable {
	return MapUint2Uint8Observable(parent, func(Uint8Observer) MappingUint2Uint8Func {
		return func(next uint, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Uint8 struct {
	parent UintObservable
	mapper func(uint) Uint8Observable
}

func (f *flatMapUint2Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *UintStream) MapUint8(f func(uint) uint8) *Uint8Stream {
	return FromUint8Observable(MapUint2Uint8ObserveNext(s, f))
}

func (s *UintStream) FlatMapUint8(f func(uint) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapUint2Uint8{s, f}}
}

type MappingUint2Int8Func func(next uint, err error, complete bool, observer Int8Observer)
type MappingUint2Int8FuncFactory func(observer Int8Observer) MappingUint2Int8Func

type MappingUint2Int8Observable struct {
	parent UintObservable
	mapper MappingUint2Int8FuncFactory
}

func (f *MappingUint2Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2Int8Observable(parent UintObservable, mapper MappingUint2Int8FuncFactory) Int8Observable {
	return &MappingUint2Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2Int8ObserveDirect(parent UintObservable, mapper MappingUint2Int8Func) Int8Observable {
	return MapUint2Int8Observable(parent, func(Int8Observer) MappingUint2Int8Func {
		return mapper
	})
}

func MapUint2Int8ObserveNext(parent UintObservable, mapper func(uint) int8) Int8Observable {
	return MapUint2Int8Observable(parent, func(Int8Observer) MappingUint2Int8Func {
		return func(next uint, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Int8 struct {
	parent UintObservable
	mapper func(uint) Int8Observable
}

func (f *flatMapUint2Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *UintStream) MapInt8(f func(uint) int8) *Int8Stream {
	return FromInt8Observable(MapUint2Int8ObserveNext(s, f))
}

func (s *UintStream) FlatMapInt8(f func(uint) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapUint2Int8{s, f}}
}

type MappingUint2Uint16Func func(next uint, err error, complete bool, observer Uint16Observer)
type MappingUint2Uint16FuncFactory func(observer Uint16Observer) MappingUint2Uint16Func

type MappingUint2Uint16Observable struct {
	parent UintObservable
	mapper MappingUint2Uint16FuncFactory
}

func (f *MappingUint2Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2Uint16Observable(parent UintObservable, mapper MappingUint2Uint16FuncFactory) Uint16Observable {
	return &MappingUint2Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2Uint16ObserveDirect(parent UintObservable, mapper MappingUint2Uint16Func) Uint16Observable {
	return MapUint2Uint16Observable(parent, func(Uint16Observer) MappingUint2Uint16Func {
		return mapper
	})
}

func MapUint2Uint16ObserveNext(parent UintObservable, mapper func(uint) uint16) Uint16Observable {
	return MapUint2Uint16Observable(parent, func(Uint16Observer) MappingUint2Uint16Func {
		return func(next uint, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Uint16 struct {
	parent UintObservable
	mapper func(uint) Uint16Observable
}

func (f *flatMapUint2Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *UintStream) MapUint16(f func(uint) uint16) *Uint16Stream {
	return FromUint16Observable(MapUint2Uint16ObserveNext(s, f))
}

func (s *UintStream) FlatMapUint16(f func(uint) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapUint2Uint16{s, f}}
}

type MappingUint2Int16Func func(next uint, err error, complete bool, observer Int16Observer)
type MappingUint2Int16FuncFactory func(observer Int16Observer) MappingUint2Int16Func

type MappingUint2Int16Observable struct {
	parent UintObservable
	mapper MappingUint2Int16FuncFactory
}

func (f *MappingUint2Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2Int16Observable(parent UintObservable, mapper MappingUint2Int16FuncFactory) Int16Observable {
	return &MappingUint2Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2Int16ObserveDirect(parent UintObservable, mapper MappingUint2Int16Func) Int16Observable {
	return MapUint2Int16Observable(parent, func(Int16Observer) MappingUint2Int16Func {
		return mapper
	})
}

func MapUint2Int16ObserveNext(parent UintObservable, mapper func(uint) int16) Int16Observable {
	return MapUint2Int16Observable(parent, func(Int16Observer) MappingUint2Int16Func {
		return func(next uint, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Int16 struct {
	parent UintObservable
	mapper func(uint) Int16Observable
}

func (f *flatMapUint2Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *UintStream) MapInt16(f func(uint) int16) *Int16Stream {
	return FromInt16Observable(MapUint2Int16ObserveNext(s, f))
}

func (s *UintStream) FlatMapInt16(f func(uint) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapUint2Int16{s, f}}
}

type MappingUint2Uint32Func func(next uint, err error, complete bool, observer Uint32Observer)
type MappingUint2Uint32FuncFactory func(observer Uint32Observer) MappingUint2Uint32Func

type MappingUint2Uint32Observable struct {
	parent UintObservable
	mapper MappingUint2Uint32FuncFactory
}

func (f *MappingUint2Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2Uint32Observable(parent UintObservable, mapper MappingUint2Uint32FuncFactory) Uint32Observable {
	return &MappingUint2Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2Uint32ObserveDirect(parent UintObservable, mapper MappingUint2Uint32Func) Uint32Observable {
	return MapUint2Uint32Observable(parent, func(Uint32Observer) MappingUint2Uint32Func {
		return mapper
	})
}

func MapUint2Uint32ObserveNext(parent UintObservable, mapper func(uint) uint32) Uint32Observable {
	return MapUint2Uint32Observable(parent, func(Uint32Observer) MappingUint2Uint32Func {
		return func(next uint, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Uint32 struct {
	parent UintObservable
	mapper func(uint) Uint32Observable
}

func (f *flatMapUint2Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *UintStream) MapUint32(f func(uint) uint32) *Uint32Stream {
	return FromUint32Observable(MapUint2Uint32ObserveNext(s, f))
}

func (s *UintStream) FlatMapUint32(f func(uint) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapUint2Uint32{s, f}}
}

type MappingUint2Int32Func func(next uint, err error, complete bool, observer Int32Observer)
type MappingUint2Int32FuncFactory func(observer Int32Observer) MappingUint2Int32Func

type MappingUint2Int32Observable struct {
	parent UintObservable
	mapper MappingUint2Int32FuncFactory
}

func (f *MappingUint2Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2Int32Observable(parent UintObservable, mapper MappingUint2Int32FuncFactory) Int32Observable {
	return &MappingUint2Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2Int32ObserveDirect(parent UintObservable, mapper MappingUint2Int32Func) Int32Observable {
	return MapUint2Int32Observable(parent, func(Int32Observer) MappingUint2Int32Func {
		return mapper
	})
}

func MapUint2Int32ObserveNext(parent UintObservable, mapper func(uint) int32) Int32Observable {
	return MapUint2Int32Observable(parent, func(Int32Observer) MappingUint2Int32Func {
		return func(next uint, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Int32 struct {
	parent UintObservable
	mapper func(uint) Int32Observable
}

func (f *flatMapUint2Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *UintStream) MapInt32(f func(uint) int32) *Int32Stream {
	return FromInt32Observable(MapUint2Int32ObserveNext(s, f))
}

func (s *UintStream) FlatMapInt32(f func(uint) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapUint2Int32{s, f}}
}

type MappingUint2Uint64Func func(next uint, err error, complete bool, observer Uint64Observer)
type MappingUint2Uint64FuncFactory func(observer Uint64Observer) MappingUint2Uint64Func

type MappingUint2Uint64Observable struct {
	parent UintObservable
	mapper MappingUint2Uint64FuncFactory
}

func (f *MappingUint2Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2Uint64Observable(parent UintObservable, mapper MappingUint2Uint64FuncFactory) Uint64Observable {
	return &MappingUint2Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2Uint64ObserveDirect(parent UintObservable, mapper MappingUint2Uint64Func) Uint64Observable {
	return MapUint2Uint64Observable(parent, func(Uint64Observer) MappingUint2Uint64Func {
		return mapper
	})
}

func MapUint2Uint64ObserveNext(parent UintObservable, mapper func(uint) uint64) Uint64Observable {
	return MapUint2Uint64Observable(parent, func(Uint64Observer) MappingUint2Uint64Func {
		return func(next uint, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Uint64 struct {
	parent UintObservable
	mapper func(uint) Uint64Observable
}

func (f *flatMapUint2Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *UintStream) MapUint64(f func(uint) uint64) *Uint64Stream {
	return FromUint64Observable(MapUint2Uint64ObserveNext(s, f))
}

func (s *UintStream) FlatMapUint64(f func(uint) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapUint2Uint64{s, f}}
}

type MappingUint2Int64Func func(next uint, err error, complete bool, observer Int64Observer)
type MappingUint2Int64FuncFactory func(observer Int64Observer) MappingUint2Int64Func

type MappingUint2Int64Observable struct {
	parent UintObservable
	mapper MappingUint2Int64FuncFactory
}

func (f *MappingUint2Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2Int64Observable(parent UintObservable, mapper MappingUint2Int64FuncFactory) Int64Observable {
	return &MappingUint2Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2Int64ObserveDirect(parent UintObservable, mapper MappingUint2Int64Func) Int64Observable {
	return MapUint2Int64Observable(parent, func(Int64Observer) MappingUint2Int64Func {
		return mapper
	})
}

func MapUint2Int64ObserveNext(parent UintObservable, mapper func(uint) int64) Int64Observable {
	return MapUint2Int64Observable(parent, func(Int64Observer) MappingUint2Int64Func {
		return func(next uint, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Int64 struct {
	parent UintObservable
	mapper func(uint) Int64Observable
}

func (f *flatMapUint2Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *UintStream) MapInt64(f func(uint) int64) *Int64Stream {
	return FromInt64Observable(MapUint2Int64ObserveNext(s, f))
}

func (s *UintStream) FlatMapInt64(f func(uint) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapUint2Int64{s, f}}
}

type MappingUint2Float32Func func(next uint, err error, complete bool, observer Float32Observer)
type MappingUint2Float32FuncFactory func(observer Float32Observer) MappingUint2Float32Func

type MappingUint2Float32Observable struct {
	parent UintObservable
	mapper MappingUint2Float32FuncFactory
}

func (f *MappingUint2Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2Float32Observable(parent UintObservable, mapper MappingUint2Float32FuncFactory) Float32Observable {
	return &MappingUint2Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2Float32ObserveDirect(parent UintObservable, mapper MappingUint2Float32Func) Float32Observable {
	return MapUint2Float32Observable(parent, func(Float32Observer) MappingUint2Float32Func {
		return mapper
	})
}

func MapUint2Float32ObserveNext(parent UintObservable, mapper func(uint) float32) Float32Observable {
	return MapUint2Float32Observable(parent, func(Float32Observer) MappingUint2Float32Func {
		return func(next uint, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Float32 struct {
	parent UintObservable
	mapper func(uint) Float32Observable
}

func (f *flatMapUint2Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *UintStream) MapFloat32(f func(uint) float32) *Float32Stream {
	return FromFloat32Observable(MapUint2Float32ObserveNext(s, f))
}

func (s *UintStream) FlatMapFloat32(f func(uint) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapUint2Float32{s, f}}
}

type MappingUint2Float64Func func(next uint, err error, complete bool, observer Float64Observer)
type MappingUint2Float64FuncFactory func(observer Float64Observer) MappingUint2Float64Func

type MappingUint2Float64Observable struct {
	parent UintObservable
	mapper MappingUint2Float64FuncFactory
}

func (f *MappingUint2Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2Float64Observable(parent UintObservable, mapper MappingUint2Float64FuncFactory) Float64Observable {
	return &MappingUint2Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2Float64ObserveDirect(parent UintObservable, mapper MappingUint2Float64Func) Float64Observable {
	return MapUint2Float64Observable(parent, func(Float64Observer) MappingUint2Float64Func {
		return mapper
	})
}

func MapUint2Float64ObserveNext(parent UintObservable, mapper func(uint) float64) Float64Observable {
	return MapUint2Float64Observable(parent, func(Float64Observer) MappingUint2Float64Func {
		return func(next uint, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Float64 struct {
	parent UintObservable
	mapper func(uint) Float64Observable
}

func (f *flatMapUint2Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *UintStream) MapFloat64(f func(uint) float64) *Float64Stream {
	return FromFloat64Observable(MapUint2Float64ObserveNext(s, f))
}

func (s *UintStream) FlatMapFloat64(f func(uint) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapUint2Float64{s, f}}
}

type MappingUint2Complex64Func func(next uint, err error, complete bool, observer Complex64Observer)
type MappingUint2Complex64FuncFactory func(observer Complex64Observer) MappingUint2Complex64Func

type MappingUint2Complex64Observable struct {
	parent UintObservable
	mapper MappingUint2Complex64FuncFactory
}

func (f *MappingUint2Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2Complex64Observable(parent UintObservable, mapper MappingUint2Complex64FuncFactory) Complex64Observable {
	return &MappingUint2Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2Complex64ObserveDirect(parent UintObservable, mapper MappingUint2Complex64Func) Complex64Observable {
	return MapUint2Complex64Observable(parent, func(Complex64Observer) MappingUint2Complex64Func {
		return mapper
	})
}

func MapUint2Complex64ObserveNext(parent UintObservable, mapper func(uint) complex64) Complex64Observable {
	return MapUint2Complex64Observable(parent, func(Complex64Observer) MappingUint2Complex64Func {
		return func(next uint, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Complex64 struct {
	parent UintObservable
	mapper func(uint) Complex64Observable
}

func (f *flatMapUint2Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *UintStream) MapComplex64(f func(uint) complex64) *Complex64Stream {
	return FromComplex64Observable(MapUint2Complex64ObserveNext(s, f))
}

func (s *UintStream) FlatMapComplex64(f func(uint) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapUint2Complex64{s, f}}
}

type MappingUint2Complex128Func func(next uint, err error, complete bool, observer Complex128Observer)
type MappingUint2Complex128FuncFactory func(observer Complex128Observer) MappingUint2Complex128Func

type MappingUint2Complex128Observable struct {
	parent UintObservable
	mapper MappingUint2Complex128FuncFactory
}

func (f *MappingUint2Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2Complex128Observable(parent UintObservable, mapper MappingUint2Complex128FuncFactory) Complex128Observable {
	return &MappingUint2Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2Complex128ObserveDirect(parent UintObservable, mapper MappingUint2Complex128Func) Complex128Observable {
	return MapUint2Complex128Observable(parent, func(Complex128Observer) MappingUint2Complex128Func {
		return mapper
	})
}

func MapUint2Complex128ObserveNext(parent UintObservable, mapper func(uint) complex128) Complex128Observable {
	return MapUint2Complex128Observable(parent, func(Complex128Observer) MappingUint2Complex128Func {
		return func(next uint, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Complex128 struct {
	parent UintObservable
	mapper func(uint) Complex128Observable
}

func (f *flatMapUint2Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *UintStream) MapComplex128(f func(uint) complex128) *Complex128Stream {
	return FromComplex128Observable(MapUint2Complex128ObserveNext(s, f))
}

func (s *UintStream) FlatMapComplex128(f func(uint) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapUint2Complex128{s, f}}
}

type MappingUint2TimeFunc func(next uint, err error, complete bool, observer TimeObserver)
type MappingUint2TimeFuncFactory func(observer TimeObserver) MappingUint2TimeFunc

type MappingUint2TimeObservable struct {
	parent UintObservable
	mapper MappingUint2TimeFuncFactory
}

func (f *MappingUint2TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2TimeObservable(parent UintObservable, mapper MappingUint2TimeFuncFactory) TimeObservable {
	return &MappingUint2TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2TimeObserveDirect(parent UintObservable, mapper MappingUint2TimeFunc) TimeObservable {
	return MapUint2TimeObservable(parent, func(TimeObserver) MappingUint2TimeFunc {
		return mapper
	})
}

func MapUint2TimeObserveNext(parent UintObservable, mapper func(uint) time.Time) TimeObservable {
	return MapUint2TimeObservable(parent, func(TimeObserver) MappingUint2TimeFunc {
		return func(next uint, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Time struct {
	parent UintObservable
	mapper func(uint) TimeObservable
}

func (f *flatMapUint2Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *UintStream) MapTime(f func(uint) time.Time) *TimeStream {
	return FromTimeObservable(MapUint2TimeObserveNext(s, f))
}

func (s *UintStream) FlatMapTime(f func(uint) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapUint2Time{s, f}}
}

type MappingUint2DurationFunc func(next uint, err error, complete bool, observer DurationObserver)
type MappingUint2DurationFuncFactory func(observer DurationObserver) MappingUint2DurationFunc

type MappingUint2DurationObservable struct {
	parent UintObservable
	mapper MappingUint2DurationFuncFactory
}

func (f *MappingUint2DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint2DurationObservable(parent UintObservable, mapper MappingUint2DurationFuncFactory) DurationObservable {
	return &MappingUint2DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint2DurationObserveDirect(parent UintObservable, mapper MappingUint2DurationFunc) DurationObservable {
	return MapUint2DurationObservable(parent, func(DurationObserver) MappingUint2DurationFunc {
		return mapper
	})
}

func MapUint2DurationObserveNext(parent UintObservable, mapper func(uint) time.Duration) DurationObservable {
	return MapUint2DurationObservable(parent, func(DurationObserver) MappingUint2DurationFunc {
		return func(next uint, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint2Duration struct {
	parent UintObservable
	mapper func(uint) DurationObservable
}

func (f *flatMapUint2Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(UintObserverFunc(func(next uint, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *UintStream) MapDuration(f func(uint) time.Duration) *DurationStream {
	return FromDurationObservable(MapUint2DurationObserveNext(s, f))
}

func (s *UintStream) FlatMapDuration(f func(uint) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapUint2Duration{s, f}}
}

type IntObserver interface {
	Next(int)
	TerminationObserver
}

// A IntSubscriber represents a subscribed IntObserver.
type IntSubscriber interface {
	Subscription
	IntObserver
}

type implIntSubscriber struct {
	Subscription
	IntObserver
}

func IntObserverAsGenericObserver(observer IntObserver) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(int))
		}
	})
}

func GenericObserverAsIntObserver(observer GenericObserver) IntObserver {
	return IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type IntObservableFactory func(observer IntObserver, subscription Subscription)

func (f IntObservableFactory) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateInt calls f(observer, subscription) to produce values for a stream.
func CreateInt(f func(observer IntObserver, subscription Subscription)) *IntStream {
	return FromIntObservable(IntObservableFactory(f))
}

// Repeat value count times.
func RepeatInt(value int, count int) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartInt is designed to be used with functions that return a
// (int, error) tuple.
//
// If the error is non-nil the returned IntStream will be that error,
// otherwise it will be a single-value stream of int.
func StartInt(f func() (int, error)) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughInt(next int, err error, complete bool, observer IntObserver) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroInt = *new(int)

type IntObserverFunc func(int, error, bool)

func (f IntObserverFunc) Next(next int)   { f(next, nil, false) }
func (f IntObserverFunc) Error(err error) { f(zeroInt, err, false) }
func (f IntObserverFunc) Complete()       { f(zeroInt, nil, true) }

type IntObservable interface {
	Subscribe(IntObserver) Subscription
}

// Convert a GenericObservableFilter to a IntObservable
func (f GenericObservableFilterFactory) Int(parent IntObservable) IntObservable {
	return MapInt2IntObservable(parent, func(observer IntObserver) MappingInt2IntFunc {
		gobserver := IntObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next int, err error, complete bool, observer IntObserver) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverInt() *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {})
}

func EmptyInt() *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowInt(err error) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		observer.Error(err)
	})
}

func FromIntArray(array []int) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromInts(array ...int) *IntStream {
	return FromIntArray(array)
}

func JustInt(element int) *IntStream {
	return FromIntArray([]int{element})
}

func MergeInt(observables ...IntObservable) *IntStream {
	if len(observables) == 0 {
		return EmptyInt()
	}
	return (&IntStream{observables[0]}).Merge(observables[1:]...)
}

func MergeIntDelayError(observables ...IntObservable) *IntStream {
	if len(observables) == 0 {
		return EmptyInt()
	}
	return (&IntStream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromIntChannel(ch <-chan int) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type IntStream struct {
	IntObservable
}

func FromIntObservable(observable IntObservable) *IntStream {
	return &IntStream{observable}
}

func (s *IntStream) SubscribeFunc(f func(int, error, bool)) Subscription {
	return s.Subscribe(IntObserverFunc(f))
}

func (s *IntStream) SubscribeNext(f func(v int)) Subscription {
	return s.SubscribeFunc(func(next int, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *IntStream) Distinct() *IntStream {
	return FromIntObservable(distinctFilter().Int(s))
}

// ElementAt yields the Nth element of the stream.
func (s *IntStream) ElementAt(n int) *IntStream {
	return FromIntObservable(elementAtFilter(n).Int(s))
}

// Filter elements in the stream on a function.
func (s *IntStream) Filter(f func(int) bool) *IntStream {
	return FromIntObservable(filterFilter(func(v interface{}) bool { return f(v.(int)) }).Int(s))
}

// Last returns just the first element of the stream.
func (s *IntStream) First() *IntStream {
	return FromIntObservable(firstFilter().Int(s))
}

// Last returns just the last element of the stream.
func (s *IntStream) Last() *IntStream {
	return FromIntObservable(lastFilter().Int(s))
}

// SkipLast skips the first N elements of the stream.
func (s *IntStream) Skip(n int) *IntStream {
	return FromIntObservable(skipFilter(n).Int(s))
}

// SkipLast skips the last N elements of the stream.
func (s *IntStream) SkipLast(n int) *IntStream {
	return FromIntObservable(skipLastFilter(n).Int(s))
}

// Take returns just the first N elements of the stream.
func (s *IntStream) Take(n int) *IntStream {
	return FromIntObservable(takeFilter(n).Int(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *IntStream) TakeLast(n int) *IntStream {
	return FromIntObservable(takeLastFilter(n).Int(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *IntStream) IgnoreElements() *IntStream {
	return FromIntObservable(ignoreElementsFilter().Int(s))
}

func (s *IntStream) Replay(size int, duration time.Duration) *IntStream {
	return FromIntObservable(replayFilter(size, duration).Int(s))
}

func (s *IntStream) Sample(duration time.Duration) *IntStream {
	return FromIntObservable(sampleFilter(duration).Int(s))
}

func (s *IntStream) Debounce(duration time.Duration) *IntStream {
	return FromIntObservable(debounceFilter(duration).Int(s))
}

// Wait for completion of the stream and return any error.
func (s *IntStream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeIntSubscriber(observer IntObserver) IntSubscriber {
	if subscriber, ok := observer.(IntSubscriber); ok {
		return subscriber
	}
	return &implIntSubscriber{NewGenericSubscription(), observer}
}

type concatIntSubscriber struct {
	observable  int
	observer    IntObserver
	observables []IntObservable
	Subscription
}

func (c *concatIntSubscriber) Next(next int) {
	c.observer.Next(next)
}

func (c *concatIntSubscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatIntSubscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatIntObservable struct {
	observables []IntObservable
}

func (m *concatIntObservable) Subscribe(observer IntObserver) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatIntSubscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *IntStream) Concat(observables ...IntObservable) *IntStream {
	return &IntStream{&concatIntObservable{append([]IntObservable{s}, observables...)}}
}

type mergeIntObservable struct {
	delayError  bool
	observables []IntObservable
}

func (m *mergeIntObservable) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next int, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(IntObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *IntStream) Merge(other ...IntObservable) *IntStream {
	if len(other) == 0 {
		return s
	}
	return &IntStream{&mergeIntObservable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *IntStream) MergeDelayError(other ...IntObservable) *IntStream {
	if len(other) == 0 {
		return s
	}
	return &IntStream{&mergeIntObservable{true, append(other, s)}}
}

type catchIntObservable struct {
	parent IntObservable
	catch  IntObservable
}

func (r *catchIntObservable) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	run := func(next int, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(IntObserverFunc(run))
	return subscription
}

func (s *IntStream) Catch(catch IntObservable) *IntStream {
	return &IntStream{&catchIntObservable{s, catch}}
}

type retryIntObservable struct {
	observable IntObservable
}

type retryIntObserver struct {
	observable IntObservable
	observer   IntObserver
}

func (r *retryIntObserver) retry(next int, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(IntObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryIntObservable) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryIntObserver{r.observable, observer}
	r.observable.Subscribe(IntObserverFunc(ro.retry))
	return subscription
}

func (s *IntStream) Retry() *IntStream {
	return &IntStream{&retryIntObservable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *IntStream) Do(f func(next int)) *IntStream {
	return FromIntObservable(MapInt2IntObserveNext(s, func(next int) int {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *IntStream) DoOnError(f func(err error)) *IntStream {
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		if err != nil {
			f(err)
		}
		PassthroughInt(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *IntStream) DoOnComplete(f func()) *IntStream {
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		if complete {
			f()
		}
		PassthroughInt(next, err, complete, observer)
	}))
}

func (s *IntStream) Reduce(initial int, reducer func(int, int) int) *IntStream {
	value := initial
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *IntStream) Scan(initial int, f func(int, int) int) *IntStream {
	value := initial
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutInt struct {
	parent  IntObservable
	timeout time.Duration
}

func (t *timeoutInt) Subscribe(observer IntObserver) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *IntStream) Timeout(timeout time.Duration) *IntStream {
	return &IntStream{&timeoutInt{s, timeout}}
}

type forkedIntStream struct {
	lock      sync.Mutex
	parent    IntObservable
	observers []IntObserver
}

func (f *forkedIntStream) Subscribe(observer IntObserver) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *IntStream) Fork() *IntStream {
	f := &forkedIntStream{parent: s}
	go s.Subscribe(IntObserverFunc(func(n int, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &IntStream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *IntStream) ToOneWithError() (int, error) {
	valuech := make(chan int, 1)
	errch := make(chan error, 1)
	FromIntObservable(oneFilter().Int(s)).SubscribeFunc(func(next int, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroInt, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *IntStream) ToOne() int {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *IntStream) ToArrayWithError() ([]int, error) {
	array := []int{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *IntStream) ToArray() []int {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *IntStream) ToChannelWithError() (<-chan int, <-chan error) {
	ch := make(chan int, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *IntStream) ToChannel() <-chan int {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *IntStream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

func (s *IntStream) Average() *IntStream {
	var sum int
	var count int
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(sum / count)
			observer.Error(err)
		case complete:
			observer.Next(sum / count)
			observer.Complete()
		default:
			sum += next
			count++
		}
	}))
}

func (s *IntStream) Sum() *IntStream {
	var sum int
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(sum)
			observer.Error(err)
		case complete:
			observer.Next(sum)
			observer.Complete()
		default:
			sum += next
		}
	}))
}

func (s *IntStream) Min() *IntStream {
	started := false
	var min int
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			if started {
				observer.Next(min)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(min)
			}
			observer.Complete()
		default:
			if started {
				if min > next {
					min = next
				}
			} else {
				min = next
				started = true
			}
		}
	}))
}

func (s *IntStream) Max() *IntStream {
	started := false
	var max int
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			if started {
				observer.Next(max)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(max)
			}
			observer.Complete()
		default:
			if started {
				if max <= next {
					max = next
				}
			} else {
				max = next
				started = true
			}
		}
	}))
}

type MappingInt2BoolFunc func(next int, err error, complete bool, observer BoolObserver)
type MappingInt2BoolFuncFactory func(observer BoolObserver) MappingInt2BoolFunc

type MappingInt2BoolObservable struct {
	parent IntObservable
	mapper MappingInt2BoolFuncFactory
}

func (f *MappingInt2BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2BoolObservable(parent IntObservable, mapper MappingInt2BoolFuncFactory) BoolObservable {
	return &MappingInt2BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2BoolObserveDirect(parent IntObservable, mapper MappingInt2BoolFunc) BoolObservable {
	return MapInt2BoolObservable(parent, func(BoolObserver) MappingInt2BoolFunc {
		return mapper
	})
}

func MapInt2BoolObserveNext(parent IntObservable, mapper func(int) bool) BoolObservable {
	return MapInt2BoolObservable(parent, func(BoolObserver) MappingInt2BoolFunc {
		return func(next int, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Bool struct {
	parent IntObservable
	mapper func(int) BoolObservable
}

func (f *flatMapInt2Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *IntStream) MapBool(f func(int) bool) *BoolStream {
	return FromBoolObservable(MapInt2BoolObserveNext(s, f))
}

func (s *IntStream) FlatMapBool(f func(int) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapInt2Bool{s, f}}
}

type MappingInt2RuneFunc func(next int, err error, complete bool, observer RuneObserver)
type MappingInt2RuneFuncFactory func(observer RuneObserver) MappingInt2RuneFunc

type MappingInt2RuneObservable struct {
	parent IntObservable
	mapper MappingInt2RuneFuncFactory
}

func (f *MappingInt2RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2RuneObservable(parent IntObservable, mapper MappingInt2RuneFuncFactory) RuneObservable {
	return &MappingInt2RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2RuneObserveDirect(parent IntObservable, mapper MappingInt2RuneFunc) RuneObservable {
	return MapInt2RuneObservable(parent, func(RuneObserver) MappingInt2RuneFunc {
		return mapper
	})
}

func MapInt2RuneObserveNext(parent IntObservable, mapper func(int) rune) RuneObservable {
	return MapInt2RuneObservable(parent, func(RuneObserver) MappingInt2RuneFunc {
		return func(next int, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Rune struct {
	parent IntObservable
	mapper func(int) RuneObservable
}

func (f *flatMapInt2Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *IntStream) MapRune(f func(int) rune) *RuneStream {
	return FromRuneObservable(MapInt2RuneObserveNext(s, f))
}

func (s *IntStream) FlatMapRune(f func(int) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapInt2Rune{s, f}}
}

type MappingInt2ByteFunc func(next int, err error, complete bool, observer ByteObserver)
type MappingInt2ByteFuncFactory func(observer ByteObserver) MappingInt2ByteFunc

type MappingInt2ByteObservable struct {
	parent IntObservable
	mapper MappingInt2ByteFuncFactory
}

func (f *MappingInt2ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2ByteObservable(parent IntObservable, mapper MappingInt2ByteFuncFactory) ByteObservable {
	return &MappingInt2ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2ByteObserveDirect(parent IntObservable, mapper MappingInt2ByteFunc) ByteObservable {
	return MapInt2ByteObservable(parent, func(ByteObserver) MappingInt2ByteFunc {
		return mapper
	})
}

func MapInt2ByteObserveNext(parent IntObservable, mapper func(int) byte) ByteObservable {
	return MapInt2ByteObservable(parent, func(ByteObserver) MappingInt2ByteFunc {
		return func(next int, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Byte struct {
	parent IntObservable
	mapper func(int) ByteObservable
}

func (f *flatMapInt2Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *IntStream) MapByte(f func(int) byte) *ByteStream {
	return FromByteObservable(MapInt2ByteObserveNext(s, f))
}

func (s *IntStream) FlatMapByte(f func(int) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapInt2Byte{s, f}}
}

type MappingInt2StringFunc func(next int, err error, complete bool, observer StringObserver)
type MappingInt2StringFuncFactory func(observer StringObserver) MappingInt2StringFunc

type MappingInt2StringObservable struct {
	parent IntObservable
	mapper MappingInt2StringFuncFactory
}

func (f *MappingInt2StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2StringObservable(parent IntObservable, mapper MappingInt2StringFuncFactory) StringObservable {
	return &MappingInt2StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2StringObserveDirect(parent IntObservable, mapper MappingInt2StringFunc) StringObservable {
	return MapInt2StringObservable(parent, func(StringObserver) MappingInt2StringFunc {
		return mapper
	})
}

func MapInt2StringObserveNext(parent IntObservable, mapper func(int) string) StringObservable {
	return MapInt2StringObservable(parent, func(StringObserver) MappingInt2StringFunc {
		return func(next int, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2String struct {
	parent IntObservable
	mapper func(int) StringObservable
}

func (f *flatMapInt2String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *IntStream) MapString(f func(int) string) *StringStream {
	return FromStringObservable(MapInt2StringObserveNext(s, f))
}

func (s *IntStream) FlatMapString(f func(int) StringObservable) *StringStream {
	return &StringStream{&flatMapInt2String{s, f}}
}

type MappingInt2UintFunc func(next int, err error, complete bool, observer UintObserver)
type MappingInt2UintFuncFactory func(observer UintObserver) MappingInt2UintFunc

type MappingInt2UintObservable struct {
	parent IntObservable
	mapper MappingInt2UintFuncFactory
}

func (f *MappingInt2UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2UintObservable(parent IntObservable, mapper MappingInt2UintFuncFactory) UintObservable {
	return &MappingInt2UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2UintObserveDirect(parent IntObservable, mapper MappingInt2UintFunc) UintObservable {
	return MapInt2UintObservable(parent, func(UintObserver) MappingInt2UintFunc {
		return mapper
	})
}

func MapInt2UintObserveNext(parent IntObservable, mapper func(int) uint) UintObservable {
	return MapInt2UintObservable(parent, func(UintObserver) MappingInt2UintFunc {
		return func(next int, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Uint struct {
	parent IntObservable
	mapper func(int) UintObservable
}

func (f *flatMapInt2Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *IntStream) MapUint(f func(int) uint) *UintStream {
	return FromUintObservable(MapInt2UintObserveNext(s, f))
}

func (s *IntStream) FlatMapUint(f func(int) UintObservable) *UintStream {
	return &UintStream{&flatMapInt2Uint{s, f}}
}

type MappingInt2IntFunc func(next int, err error, complete bool, observer IntObserver)
type MappingInt2IntFuncFactory func(observer IntObserver) MappingInt2IntFunc

type MappingInt2IntObservable struct {
	parent IntObservable
	mapper MappingInt2IntFuncFactory
}

func (f *MappingInt2IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2IntObservable(parent IntObservable, mapper MappingInt2IntFuncFactory) IntObservable {
	return &MappingInt2IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2IntObserveDirect(parent IntObservable, mapper MappingInt2IntFunc) IntObservable {
	return MapInt2IntObservable(parent, func(IntObserver) MappingInt2IntFunc {
		return mapper
	})
}

func MapInt2IntObserveNext(parent IntObservable, mapper func(int) int) IntObservable {
	return MapInt2IntObservable(parent, func(IntObserver) MappingInt2IntFunc {
		return func(next int, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Int struct {
	parent IntObservable
	mapper func(int) IntObservable
}

func (f *flatMapInt2Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *IntStream) Map(f func(int) int) *IntStream {
	return FromIntObservable(MapInt2IntObserveNext(s, f))
}

func (s *IntStream) FlatMap(f func(int) IntObservable) *IntStream {
	return &IntStream{&flatMapInt2Int{s, f}}
}

type MappingInt2Uint8Func func(next int, err error, complete bool, observer Uint8Observer)
type MappingInt2Uint8FuncFactory func(observer Uint8Observer) MappingInt2Uint8Func

type MappingInt2Uint8Observable struct {
	parent IntObservable
	mapper MappingInt2Uint8FuncFactory
}

func (f *MappingInt2Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2Uint8Observable(parent IntObservable, mapper MappingInt2Uint8FuncFactory) Uint8Observable {
	return &MappingInt2Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2Uint8ObserveDirect(parent IntObservable, mapper MappingInt2Uint8Func) Uint8Observable {
	return MapInt2Uint8Observable(parent, func(Uint8Observer) MappingInt2Uint8Func {
		return mapper
	})
}

func MapInt2Uint8ObserveNext(parent IntObservable, mapper func(int) uint8) Uint8Observable {
	return MapInt2Uint8Observable(parent, func(Uint8Observer) MappingInt2Uint8Func {
		return func(next int, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Uint8 struct {
	parent IntObservable
	mapper func(int) Uint8Observable
}

func (f *flatMapInt2Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *IntStream) MapUint8(f func(int) uint8) *Uint8Stream {
	return FromUint8Observable(MapInt2Uint8ObserveNext(s, f))
}

func (s *IntStream) FlatMapUint8(f func(int) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapInt2Uint8{s, f}}
}

type MappingInt2Int8Func func(next int, err error, complete bool, observer Int8Observer)
type MappingInt2Int8FuncFactory func(observer Int8Observer) MappingInt2Int8Func

type MappingInt2Int8Observable struct {
	parent IntObservable
	mapper MappingInt2Int8FuncFactory
}

func (f *MappingInt2Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2Int8Observable(parent IntObservable, mapper MappingInt2Int8FuncFactory) Int8Observable {
	return &MappingInt2Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2Int8ObserveDirect(parent IntObservable, mapper MappingInt2Int8Func) Int8Observable {
	return MapInt2Int8Observable(parent, func(Int8Observer) MappingInt2Int8Func {
		return mapper
	})
}

func MapInt2Int8ObserveNext(parent IntObservable, mapper func(int) int8) Int8Observable {
	return MapInt2Int8Observable(parent, func(Int8Observer) MappingInt2Int8Func {
		return func(next int, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Int8 struct {
	parent IntObservable
	mapper func(int) Int8Observable
}

func (f *flatMapInt2Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *IntStream) MapInt8(f func(int) int8) *Int8Stream {
	return FromInt8Observable(MapInt2Int8ObserveNext(s, f))
}

func (s *IntStream) FlatMapInt8(f func(int) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapInt2Int8{s, f}}
}

type MappingInt2Uint16Func func(next int, err error, complete bool, observer Uint16Observer)
type MappingInt2Uint16FuncFactory func(observer Uint16Observer) MappingInt2Uint16Func

type MappingInt2Uint16Observable struct {
	parent IntObservable
	mapper MappingInt2Uint16FuncFactory
}

func (f *MappingInt2Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2Uint16Observable(parent IntObservable, mapper MappingInt2Uint16FuncFactory) Uint16Observable {
	return &MappingInt2Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2Uint16ObserveDirect(parent IntObservable, mapper MappingInt2Uint16Func) Uint16Observable {
	return MapInt2Uint16Observable(parent, func(Uint16Observer) MappingInt2Uint16Func {
		return mapper
	})
}

func MapInt2Uint16ObserveNext(parent IntObservable, mapper func(int) uint16) Uint16Observable {
	return MapInt2Uint16Observable(parent, func(Uint16Observer) MappingInt2Uint16Func {
		return func(next int, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Uint16 struct {
	parent IntObservable
	mapper func(int) Uint16Observable
}

func (f *flatMapInt2Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *IntStream) MapUint16(f func(int) uint16) *Uint16Stream {
	return FromUint16Observable(MapInt2Uint16ObserveNext(s, f))
}

func (s *IntStream) FlatMapUint16(f func(int) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapInt2Uint16{s, f}}
}

type MappingInt2Int16Func func(next int, err error, complete bool, observer Int16Observer)
type MappingInt2Int16FuncFactory func(observer Int16Observer) MappingInt2Int16Func

type MappingInt2Int16Observable struct {
	parent IntObservable
	mapper MappingInt2Int16FuncFactory
}

func (f *MappingInt2Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2Int16Observable(parent IntObservable, mapper MappingInt2Int16FuncFactory) Int16Observable {
	return &MappingInt2Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2Int16ObserveDirect(parent IntObservable, mapper MappingInt2Int16Func) Int16Observable {
	return MapInt2Int16Observable(parent, func(Int16Observer) MappingInt2Int16Func {
		return mapper
	})
}

func MapInt2Int16ObserveNext(parent IntObservable, mapper func(int) int16) Int16Observable {
	return MapInt2Int16Observable(parent, func(Int16Observer) MappingInt2Int16Func {
		return func(next int, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Int16 struct {
	parent IntObservable
	mapper func(int) Int16Observable
}

func (f *flatMapInt2Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *IntStream) MapInt16(f func(int) int16) *Int16Stream {
	return FromInt16Observable(MapInt2Int16ObserveNext(s, f))
}

func (s *IntStream) FlatMapInt16(f func(int) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapInt2Int16{s, f}}
}

type MappingInt2Uint32Func func(next int, err error, complete bool, observer Uint32Observer)
type MappingInt2Uint32FuncFactory func(observer Uint32Observer) MappingInt2Uint32Func

type MappingInt2Uint32Observable struct {
	parent IntObservable
	mapper MappingInt2Uint32FuncFactory
}

func (f *MappingInt2Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2Uint32Observable(parent IntObservable, mapper MappingInt2Uint32FuncFactory) Uint32Observable {
	return &MappingInt2Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2Uint32ObserveDirect(parent IntObservable, mapper MappingInt2Uint32Func) Uint32Observable {
	return MapInt2Uint32Observable(parent, func(Uint32Observer) MappingInt2Uint32Func {
		return mapper
	})
}

func MapInt2Uint32ObserveNext(parent IntObservable, mapper func(int) uint32) Uint32Observable {
	return MapInt2Uint32Observable(parent, func(Uint32Observer) MappingInt2Uint32Func {
		return func(next int, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Uint32 struct {
	parent IntObservable
	mapper func(int) Uint32Observable
}

func (f *flatMapInt2Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *IntStream) MapUint32(f func(int) uint32) *Uint32Stream {
	return FromUint32Observable(MapInt2Uint32ObserveNext(s, f))
}

func (s *IntStream) FlatMapUint32(f func(int) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapInt2Uint32{s, f}}
}

type MappingInt2Int32Func func(next int, err error, complete bool, observer Int32Observer)
type MappingInt2Int32FuncFactory func(observer Int32Observer) MappingInt2Int32Func

type MappingInt2Int32Observable struct {
	parent IntObservable
	mapper MappingInt2Int32FuncFactory
}

func (f *MappingInt2Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2Int32Observable(parent IntObservable, mapper MappingInt2Int32FuncFactory) Int32Observable {
	return &MappingInt2Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2Int32ObserveDirect(parent IntObservable, mapper MappingInt2Int32Func) Int32Observable {
	return MapInt2Int32Observable(parent, func(Int32Observer) MappingInt2Int32Func {
		return mapper
	})
}

func MapInt2Int32ObserveNext(parent IntObservable, mapper func(int) int32) Int32Observable {
	return MapInt2Int32Observable(parent, func(Int32Observer) MappingInt2Int32Func {
		return func(next int, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Int32 struct {
	parent IntObservable
	mapper func(int) Int32Observable
}

func (f *flatMapInt2Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *IntStream) MapInt32(f func(int) int32) *Int32Stream {
	return FromInt32Observable(MapInt2Int32ObserveNext(s, f))
}

func (s *IntStream) FlatMapInt32(f func(int) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapInt2Int32{s, f}}
}

type MappingInt2Uint64Func func(next int, err error, complete bool, observer Uint64Observer)
type MappingInt2Uint64FuncFactory func(observer Uint64Observer) MappingInt2Uint64Func

type MappingInt2Uint64Observable struct {
	parent IntObservable
	mapper MappingInt2Uint64FuncFactory
}

func (f *MappingInt2Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2Uint64Observable(parent IntObservable, mapper MappingInt2Uint64FuncFactory) Uint64Observable {
	return &MappingInt2Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2Uint64ObserveDirect(parent IntObservable, mapper MappingInt2Uint64Func) Uint64Observable {
	return MapInt2Uint64Observable(parent, func(Uint64Observer) MappingInt2Uint64Func {
		return mapper
	})
}

func MapInt2Uint64ObserveNext(parent IntObservable, mapper func(int) uint64) Uint64Observable {
	return MapInt2Uint64Observable(parent, func(Uint64Observer) MappingInt2Uint64Func {
		return func(next int, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Uint64 struct {
	parent IntObservable
	mapper func(int) Uint64Observable
}

func (f *flatMapInt2Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *IntStream) MapUint64(f func(int) uint64) *Uint64Stream {
	return FromUint64Observable(MapInt2Uint64ObserveNext(s, f))
}

func (s *IntStream) FlatMapUint64(f func(int) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapInt2Uint64{s, f}}
}

type MappingInt2Int64Func func(next int, err error, complete bool, observer Int64Observer)
type MappingInt2Int64FuncFactory func(observer Int64Observer) MappingInt2Int64Func

type MappingInt2Int64Observable struct {
	parent IntObservable
	mapper MappingInt2Int64FuncFactory
}

func (f *MappingInt2Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2Int64Observable(parent IntObservable, mapper MappingInt2Int64FuncFactory) Int64Observable {
	return &MappingInt2Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2Int64ObserveDirect(parent IntObservable, mapper MappingInt2Int64Func) Int64Observable {
	return MapInt2Int64Observable(parent, func(Int64Observer) MappingInt2Int64Func {
		return mapper
	})
}

func MapInt2Int64ObserveNext(parent IntObservable, mapper func(int) int64) Int64Observable {
	return MapInt2Int64Observable(parent, func(Int64Observer) MappingInt2Int64Func {
		return func(next int, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Int64 struct {
	parent IntObservable
	mapper func(int) Int64Observable
}

func (f *flatMapInt2Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *IntStream) MapInt64(f func(int) int64) *Int64Stream {
	return FromInt64Observable(MapInt2Int64ObserveNext(s, f))
}

func (s *IntStream) FlatMapInt64(f func(int) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapInt2Int64{s, f}}
}

type MappingInt2Float32Func func(next int, err error, complete bool, observer Float32Observer)
type MappingInt2Float32FuncFactory func(observer Float32Observer) MappingInt2Float32Func

type MappingInt2Float32Observable struct {
	parent IntObservable
	mapper MappingInt2Float32FuncFactory
}

func (f *MappingInt2Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2Float32Observable(parent IntObservable, mapper MappingInt2Float32FuncFactory) Float32Observable {
	return &MappingInt2Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2Float32ObserveDirect(parent IntObservable, mapper MappingInt2Float32Func) Float32Observable {
	return MapInt2Float32Observable(parent, func(Float32Observer) MappingInt2Float32Func {
		return mapper
	})
}

func MapInt2Float32ObserveNext(parent IntObservable, mapper func(int) float32) Float32Observable {
	return MapInt2Float32Observable(parent, func(Float32Observer) MappingInt2Float32Func {
		return func(next int, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Float32 struct {
	parent IntObservable
	mapper func(int) Float32Observable
}

func (f *flatMapInt2Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *IntStream) MapFloat32(f func(int) float32) *Float32Stream {
	return FromFloat32Observable(MapInt2Float32ObserveNext(s, f))
}

func (s *IntStream) FlatMapFloat32(f func(int) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapInt2Float32{s, f}}
}

type MappingInt2Float64Func func(next int, err error, complete bool, observer Float64Observer)
type MappingInt2Float64FuncFactory func(observer Float64Observer) MappingInt2Float64Func

type MappingInt2Float64Observable struct {
	parent IntObservable
	mapper MappingInt2Float64FuncFactory
}

func (f *MappingInt2Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2Float64Observable(parent IntObservable, mapper MappingInt2Float64FuncFactory) Float64Observable {
	return &MappingInt2Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2Float64ObserveDirect(parent IntObservable, mapper MappingInt2Float64Func) Float64Observable {
	return MapInt2Float64Observable(parent, func(Float64Observer) MappingInt2Float64Func {
		return mapper
	})
}

func MapInt2Float64ObserveNext(parent IntObservable, mapper func(int) float64) Float64Observable {
	return MapInt2Float64Observable(parent, func(Float64Observer) MappingInt2Float64Func {
		return func(next int, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Float64 struct {
	parent IntObservable
	mapper func(int) Float64Observable
}

func (f *flatMapInt2Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *IntStream) MapFloat64(f func(int) float64) *Float64Stream {
	return FromFloat64Observable(MapInt2Float64ObserveNext(s, f))
}

func (s *IntStream) FlatMapFloat64(f func(int) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapInt2Float64{s, f}}
}

type MappingInt2Complex64Func func(next int, err error, complete bool, observer Complex64Observer)
type MappingInt2Complex64FuncFactory func(observer Complex64Observer) MappingInt2Complex64Func

type MappingInt2Complex64Observable struct {
	parent IntObservable
	mapper MappingInt2Complex64FuncFactory
}

func (f *MappingInt2Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2Complex64Observable(parent IntObservable, mapper MappingInt2Complex64FuncFactory) Complex64Observable {
	return &MappingInt2Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2Complex64ObserveDirect(parent IntObservable, mapper MappingInt2Complex64Func) Complex64Observable {
	return MapInt2Complex64Observable(parent, func(Complex64Observer) MappingInt2Complex64Func {
		return mapper
	})
}

func MapInt2Complex64ObserveNext(parent IntObservable, mapper func(int) complex64) Complex64Observable {
	return MapInt2Complex64Observable(parent, func(Complex64Observer) MappingInt2Complex64Func {
		return func(next int, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Complex64 struct {
	parent IntObservable
	mapper func(int) Complex64Observable
}

func (f *flatMapInt2Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *IntStream) MapComplex64(f func(int) complex64) *Complex64Stream {
	return FromComplex64Observable(MapInt2Complex64ObserveNext(s, f))
}

func (s *IntStream) FlatMapComplex64(f func(int) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapInt2Complex64{s, f}}
}

type MappingInt2Complex128Func func(next int, err error, complete bool, observer Complex128Observer)
type MappingInt2Complex128FuncFactory func(observer Complex128Observer) MappingInt2Complex128Func

type MappingInt2Complex128Observable struct {
	parent IntObservable
	mapper MappingInt2Complex128FuncFactory
}

func (f *MappingInt2Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2Complex128Observable(parent IntObservable, mapper MappingInt2Complex128FuncFactory) Complex128Observable {
	return &MappingInt2Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2Complex128ObserveDirect(parent IntObservable, mapper MappingInt2Complex128Func) Complex128Observable {
	return MapInt2Complex128Observable(parent, func(Complex128Observer) MappingInt2Complex128Func {
		return mapper
	})
}

func MapInt2Complex128ObserveNext(parent IntObservable, mapper func(int) complex128) Complex128Observable {
	return MapInt2Complex128Observable(parent, func(Complex128Observer) MappingInt2Complex128Func {
		return func(next int, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Complex128 struct {
	parent IntObservable
	mapper func(int) Complex128Observable
}

func (f *flatMapInt2Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *IntStream) MapComplex128(f func(int) complex128) *Complex128Stream {
	return FromComplex128Observable(MapInt2Complex128ObserveNext(s, f))
}

func (s *IntStream) FlatMapComplex128(f func(int) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapInt2Complex128{s, f}}
}

type MappingInt2TimeFunc func(next int, err error, complete bool, observer TimeObserver)
type MappingInt2TimeFuncFactory func(observer TimeObserver) MappingInt2TimeFunc

type MappingInt2TimeObservable struct {
	parent IntObservable
	mapper MappingInt2TimeFuncFactory
}

func (f *MappingInt2TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2TimeObservable(parent IntObservable, mapper MappingInt2TimeFuncFactory) TimeObservable {
	return &MappingInt2TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2TimeObserveDirect(parent IntObservable, mapper MappingInt2TimeFunc) TimeObservable {
	return MapInt2TimeObservable(parent, func(TimeObserver) MappingInt2TimeFunc {
		return mapper
	})
}

func MapInt2TimeObserveNext(parent IntObservable, mapper func(int) time.Time) TimeObservable {
	return MapInt2TimeObservable(parent, func(TimeObserver) MappingInt2TimeFunc {
		return func(next int, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Time struct {
	parent IntObservable
	mapper func(int) TimeObservable
}

func (f *flatMapInt2Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *IntStream) MapTime(f func(int) time.Time) *TimeStream {
	return FromTimeObservable(MapInt2TimeObserveNext(s, f))
}

func (s *IntStream) FlatMapTime(f func(int) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapInt2Time{s, f}}
}

type MappingInt2DurationFunc func(next int, err error, complete bool, observer DurationObserver)
type MappingInt2DurationFuncFactory func(observer DurationObserver) MappingInt2DurationFunc

type MappingInt2DurationObservable struct {
	parent IntObservable
	mapper MappingInt2DurationFuncFactory
}

func (f *MappingInt2DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt2DurationObservable(parent IntObservable, mapper MappingInt2DurationFuncFactory) DurationObservable {
	return &MappingInt2DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2DurationObserveDirect(parent IntObservable, mapper MappingInt2DurationFunc) DurationObservable {
	return MapInt2DurationObservable(parent, func(DurationObserver) MappingInt2DurationFunc {
		return mapper
	})
}

func MapInt2DurationObserveNext(parent IntObservable, mapper func(int) time.Duration) DurationObservable {
	return MapInt2DurationObservable(parent, func(DurationObserver) MappingInt2DurationFunc {
		return func(next int, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt2Duration struct {
	parent IntObservable
	mapper func(int) DurationObservable
}

func (f *flatMapInt2Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(IntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *IntStream) MapDuration(f func(int) time.Duration) *DurationStream {
	return FromDurationObservable(MapInt2DurationObserveNext(s, f))
}

func (s *IntStream) FlatMapDuration(f func(int) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapInt2Duration{s, f}}
}

type Uint8Observer interface {
	Next(uint8)
	TerminationObserver
}

// A Uint8Subscriber represents a subscribed Uint8Observer.
type Uint8Subscriber interface {
	Subscription
	Uint8Observer
}

type implUint8Subscriber struct {
	Subscription
	Uint8Observer
}

func Uint8ObserverAsGenericObserver(observer Uint8Observer) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(uint8))
		}
	})
}

func GenericObserverAsUint8Observer(observer GenericObserver) Uint8Observer {
	return Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type Uint8ObservableFactory func(observer Uint8Observer, subscription Subscription)

func (f Uint8ObservableFactory) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateUint8 calls f(observer, subscription) to produce values for a stream.
func CreateUint8(f func(observer Uint8Observer, subscription Subscription)) *Uint8Stream {
	return FromUint8Observable(Uint8ObservableFactory(f))
}

// Repeat value count times.
func RepeatUint8(value uint8, count int) *Uint8Stream {
	return CreateUint8(func(observer Uint8Observer, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartUint8 is designed to be used with functions that return a
// (uint8, error) tuple.
//
// If the error is non-nil the returned Uint8Stream will be that error,
// otherwise it will be a single-value stream of uint8.
func StartUint8(f func() (uint8, error)) *Uint8Stream {
	return CreateUint8(func(observer Uint8Observer, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughUint8(next uint8, err error, complete bool, observer Uint8Observer) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroUint8 = *new(uint8)

type Uint8ObserverFunc func(uint8, error, bool)

func (f Uint8ObserverFunc) Next(next uint8) { f(next, nil, false) }
func (f Uint8ObserverFunc) Error(err error) { f(zeroUint8, err, false) }
func (f Uint8ObserverFunc) Complete()       { f(zeroUint8, nil, true) }

type Uint8Observable interface {
	Subscribe(Uint8Observer) Subscription
}

// Convert a GenericObservableFilter to a Uint8Observable
func (f GenericObservableFilterFactory) Uint8(parent Uint8Observable) Uint8Observable {
	return MapUint82Uint8Observable(parent, func(observer Uint8Observer) MappingUint82Uint8Func {
		gobserver := Uint8ObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next uint8, err error, complete bool, observer Uint8Observer) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverUint8() *Uint8Stream {
	return CreateUint8(func(observer Uint8Observer, subscription Subscription) {})
}

func EmptyUint8() *Uint8Stream {
	return CreateUint8(func(observer Uint8Observer, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowUint8(err error) *Uint8Stream {
	return CreateUint8(func(observer Uint8Observer, subscription Subscription) {
		observer.Error(err)
	})
}

func FromUint8Array(array []uint8) *Uint8Stream {
	return CreateUint8(func(observer Uint8Observer, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromUint8s(array ...uint8) *Uint8Stream {
	return FromUint8Array(array)
}

func JustUint8(element uint8) *Uint8Stream {
	return FromUint8Array([]uint8{element})
}

func MergeUint8(observables ...Uint8Observable) *Uint8Stream {
	if len(observables) == 0 {
		return EmptyUint8()
	}
	return (&Uint8Stream{observables[0]}).Merge(observables[1:]...)
}

func MergeUint8DelayError(observables ...Uint8Observable) *Uint8Stream {
	if len(observables) == 0 {
		return EmptyUint8()
	}
	return (&Uint8Stream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromUint8Channel(ch <-chan uint8) *Uint8Stream {
	return CreateUint8(func(observer Uint8Observer, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type Uint8Stream struct {
	Uint8Observable
}

func FromUint8Observable(observable Uint8Observable) *Uint8Stream {
	return &Uint8Stream{observable}
}

func (s *Uint8Stream) SubscribeFunc(f func(uint8, error, bool)) Subscription {
	return s.Subscribe(Uint8ObserverFunc(f))
}

func (s *Uint8Stream) SubscribeNext(f func(v uint8)) Subscription {
	return s.SubscribeFunc(func(next uint8, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *Uint8Stream) Distinct() *Uint8Stream {
	return FromUint8Observable(distinctFilter().Uint8(s))
}

// ElementAt yields the Nth element of the stream.
func (s *Uint8Stream) ElementAt(n int) *Uint8Stream {
	return FromUint8Observable(elementAtFilter(n).Uint8(s))
}

// Filter elements in the stream on a function.
func (s *Uint8Stream) Filter(f func(uint8) bool) *Uint8Stream {
	return FromUint8Observable(filterFilter(func(v interface{}) bool { return f(v.(uint8)) }).Uint8(s))
}

// Last returns just the first element of the stream.
func (s *Uint8Stream) First() *Uint8Stream {
	return FromUint8Observable(firstFilter().Uint8(s))
}

// Last returns just the last element of the stream.
func (s *Uint8Stream) Last() *Uint8Stream {
	return FromUint8Observable(lastFilter().Uint8(s))
}

// SkipLast skips the first N elements of the stream.
func (s *Uint8Stream) Skip(n int) *Uint8Stream {
	return FromUint8Observable(skipFilter(n).Uint8(s))
}

// SkipLast skips the last N elements of the stream.
func (s *Uint8Stream) SkipLast(n int) *Uint8Stream {
	return FromUint8Observable(skipLastFilter(n).Uint8(s))
}

// Take returns just the first N elements of the stream.
func (s *Uint8Stream) Take(n int) *Uint8Stream {
	return FromUint8Observable(takeFilter(n).Uint8(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *Uint8Stream) TakeLast(n int) *Uint8Stream {
	return FromUint8Observable(takeLastFilter(n).Uint8(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *Uint8Stream) IgnoreElements() *Uint8Stream {
	return FromUint8Observable(ignoreElementsFilter().Uint8(s))
}

func (s *Uint8Stream) Replay(size int, duration time.Duration) *Uint8Stream {
	return FromUint8Observable(replayFilter(size, duration).Uint8(s))
}

func (s *Uint8Stream) Sample(duration time.Duration) *Uint8Stream {
	return FromUint8Observable(sampleFilter(duration).Uint8(s))
}

func (s *Uint8Stream) Debounce(duration time.Duration) *Uint8Stream {
	return FromUint8Observable(debounceFilter(duration).Uint8(s))
}

// Wait for completion of the stream and return any error.
func (s *Uint8Stream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeUint8Subscriber(observer Uint8Observer) Uint8Subscriber {
	if subscriber, ok := observer.(Uint8Subscriber); ok {
		return subscriber
	}
	return &implUint8Subscriber{NewGenericSubscription(), observer}
}

type concatUint8Subscriber struct {
	observable  int
	observer    Uint8Observer
	observables []Uint8Observable
	Subscription
}

func (c *concatUint8Subscriber) Next(next uint8) {
	c.observer.Next(next)
}

func (c *concatUint8Subscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatUint8Subscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatUint8Observable struct {
	observables []Uint8Observable
}

func (m *concatUint8Observable) Subscribe(observer Uint8Observer) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatUint8Subscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *Uint8Stream) Concat(observables ...Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&concatUint8Observable{append([]Uint8Observable{s}, observables...)}}
}

type mergeUint8Observable struct {
	delayError  bool
	observables []Uint8Observable
}

func (m *mergeUint8Observable) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next uint8, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(Uint8ObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *Uint8Stream) Merge(other ...Uint8Observable) *Uint8Stream {
	if len(other) == 0 {
		return s
	}
	return &Uint8Stream{&mergeUint8Observable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *Uint8Stream) MergeDelayError(other ...Uint8Observable) *Uint8Stream {
	if len(other) == 0 {
		return s
	}
	return &Uint8Stream{&mergeUint8Observable{true, append(other, s)}}
}

type catchUint8Observable struct {
	parent Uint8Observable
	catch  Uint8Observable
}

func (r *catchUint8Observable) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	run := func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(Uint8ObserverFunc(run))
	return subscription
}

func (s *Uint8Stream) Catch(catch Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&catchUint8Observable{s, catch}}
}

type retryUint8Observable struct {
	observable Uint8Observable
}

type retryUint8Observer struct {
	observable Uint8Observable
	observer   Uint8Observer
}

func (r *retryUint8Observer) retry(next uint8, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(Uint8ObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryUint8Observable) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryUint8Observer{r.observable, observer}
	r.observable.Subscribe(Uint8ObserverFunc(ro.retry))
	return subscription
}

func (s *Uint8Stream) Retry() *Uint8Stream {
	return &Uint8Stream{&retryUint8Observable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *Uint8Stream) Do(f func(next uint8)) *Uint8Stream {
	return FromUint8Observable(MapUint82Uint8ObserveNext(s, func(next uint8) uint8 {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *Uint8Stream) DoOnError(f func(err error)) *Uint8Stream {
	return FromUint8Observable(MapUint82Uint8ObserveDirect(s, func(next uint8, err error, complete bool, observer Uint8Observer) {
		if err != nil {
			f(err)
		}
		PassthroughUint8(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *Uint8Stream) DoOnComplete(f func()) *Uint8Stream {
	return FromUint8Observable(MapUint82Uint8ObserveDirect(s, func(next uint8, err error, complete bool, observer Uint8Observer) {
		if complete {
			f()
		}
		PassthroughUint8(next, err, complete, observer)
	}))
}

func (s *Uint8Stream) Reduce(initial uint8, reducer func(uint8, uint8) uint8) *Uint8Stream {
	value := initial
	return FromUint8Observable(MapUint82Uint8ObserveDirect(s, func(next uint8, err error, complete bool, observer Uint8Observer) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *Uint8Stream) Scan(initial uint8, f func(uint8, uint8) uint8) *Uint8Stream {
	value := initial
	return FromUint8Observable(MapUint82Uint8ObserveDirect(s, func(next uint8, err error, complete bool, observer Uint8Observer) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutUint8 struct {
	parent  Uint8Observable
	timeout time.Duration
}

func (t *timeoutUint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *Uint8Stream) Timeout(timeout time.Duration) *Uint8Stream {
	return &Uint8Stream{&timeoutUint8{s, timeout}}
}

type forkedUint8Stream struct {
	lock      sync.Mutex
	parent    Uint8Observable
	observers []Uint8Observer
}

func (f *forkedUint8Stream) Subscribe(observer Uint8Observer) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *Uint8Stream) Fork() *Uint8Stream {
	f := &forkedUint8Stream{parent: s}
	go s.Subscribe(Uint8ObserverFunc(func(n uint8, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &Uint8Stream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *Uint8Stream) ToOneWithError() (uint8, error) {
	valuech := make(chan uint8, 1)
	errch := make(chan error, 1)
	FromUint8Observable(oneFilter().Uint8(s)).SubscribeFunc(func(next uint8, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroUint8, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *Uint8Stream) ToOne() uint8 {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *Uint8Stream) ToArrayWithError() ([]uint8, error) {
	array := []uint8{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *Uint8Stream) ToArray() []uint8 {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *Uint8Stream) ToChannelWithError() (<-chan uint8, <-chan error) {
	ch := make(chan uint8, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *Uint8Stream) ToChannel() <-chan uint8 {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *Uint8Stream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapUint82IntObserveDirect(s, func(next uint8, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

func (s *Uint8Stream) Average() *Uint8Stream {
	var sum uint8
	var count uint8
	return FromUint8Observable(MapUint82Uint8ObserveDirect(s, func(next uint8, err error, complete bool, observer Uint8Observer) {
		switch {
		case err != nil:
			observer.Next(sum / count)
			observer.Error(err)
		case complete:
			observer.Next(sum / count)
			observer.Complete()
		default:
			sum += next
			count++
		}
	}))
}

func (s *Uint8Stream) Sum() *Uint8Stream {
	var sum uint8
	return FromUint8Observable(MapUint82Uint8ObserveDirect(s, func(next uint8, err error, complete bool, observer Uint8Observer) {
		switch {
		case err != nil:
			observer.Next(sum)
			observer.Error(err)
		case complete:
			observer.Next(sum)
			observer.Complete()
		default:
			sum += next
		}
	}))
}

func (s *Uint8Stream) Min() *Uint8Stream {
	started := false
	var min uint8
	return FromUint8Observable(MapUint82Uint8ObserveDirect(s, func(next uint8, err error, complete bool, observer Uint8Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(min)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(min)
			}
			observer.Complete()
		default:
			if started {
				if min > next {
					min = next
				}
			} else {
				min = next
				started = true
			}
		}
	}))
}

func (s *Uint8Stream) Max() *Uint8Stream {
	started := false
	var max uint8
	return FromUint8Observable(MapUint82Uint8ObserveDirect(s, func(next uint8, err error, complete bool, observer Uint8Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(max)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(max)
			}
			observer.Complete()
		default:
			if started {
				if max <= next {
					max = next
				}
			} else {
				max = next
				started = true
			}
		}
	}))
}

type MappingUint82BoolFunc func(next uint8, err error, complete bool, observer BoolObserver)
type MappingUint82BoolFuncFactory func(observer BoolObserver) MappingUint82BoolFunc

type MappingUint82BoolObservable struct {
	parent Uint8Observable
	mapper MappingUint82BoolFuncFactory
}

func (f *MappingUint82BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82BoolObservable(parent Uint8Observable, mapper MappingUint82BoolFuncFactory) BoolObservable {
	return &MappingUint82BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82BoolObserveDirect(parent Uint8Observable, mapper MappingUint82BoolFunc) BoolObservable {
	return MapUint82BoolObservable(parent, func(BoolObserver) MappingUint82BoolFunc {
		return mapper
	})
}

func MapUint82BoolObserveNext(parent Uint8Observable, mapper func(uint8) bool) BoolObservable {
	return MapUint82BoolObservable(parent, func(BoolObserver) MappingUint82BoolFunc {
		return func(next uint8, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Bool struct {
	parent Uint8Observable
	mapper func(uint8) BoolObservable
}

func (f *flatMapUint82Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *Uint8Stream) MapBool(f func(uint8) bool) *BoolStream {
	return FromBoolObservable(MapUint82BoolObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapBool(f func(uint8) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapUint82Bool{s, f}}
}

type MappingUint82RuneFunc func(next uint8, err error, complete bool, observer RuneObserver)
type MappingUint82RuneFuncFactory func(observer RuneObserver) MappingUint82RuneFunc

type MappingUint82RuneObservable struct {
	parent Uint8Observable
	mapper MappingUint82RuneFuncFactory
}

func (f *MappingUint82RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82RuneObservable(parent Uint8Observable, mapper MappingUint82RuneFuncFactory) RuneObservable {
	return &MappingUint82RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82RuneObserveDirect(parent Uint8Observable, mapper MappingUint82RuneFunc) RuneObservable {
	return MapUint82RuneObservable(parent, func(RuneObserver) MappingUint82RuneFunc {
		return mapper
	})
}

func MapUint82RuneObserveNext(parent Uint8Observable, mapper func(uint8) rune) RuneObservable {
	return MapUint82RuneObservable(parent, func(RuneObserver) MappingUint82RuneFunc {
		return func(next uint8, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Rune struct {
	parent Uint8Observable
	mapper func(uint8) RuneObservable
}

func (f *flatMapUint82Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *Uint8Stream) MapRune(f func(uint8) rune) *RuneStream {
	return FromRuneObservable(MapUint82RuneObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapRune(f func(uint8) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapUint82Rune{s, f}}
}

type MappingUint82ByteFunc func(next uint8, err error, complete bool, observer ByteObserver)
type MappingUint82ByteFuncFactory func(observer ByteObserver) MappingUint82ByteFunc

type MappingUint82ByteObservable struct {
	parent Uint8Observable
	mapper MappingUint82ByteFuncFactory
}

func (f *MappingUint82ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82ByteObservable(parent Uint8Observable, mapper MappingUint82ByteFuncFactory) ByteObservable {
	return &MappingUint82ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82ByteObserveDirect(parent Uint8Observable, mapper MappingUint82ByteFunc) ByteObservable {
	return MapUint82ByteObservable(parent, func(ByteObserver) MappingUint82ByteFunc {
		return mapper
	})
}

func MapUint82ByteObserveNext(parent Uint8Observable, mapper func(uint8) byte) ByteObservable {
	return MapUint82ByteObservable(parent, func(ByteObserver) MappingUint82ByteFunc {
		return func(next uint8, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Byte struct {
	parent Uint8Observable
	mapper func(uint8) ByteObservable
}

func (f *flatMapUint82Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *Uint8Stream) MapByte(f func(uint8) byte) *ByteStream {
	return FromByteObservable(MapUint82ByteObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapByte(f func(uint8) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapUint82Byte{s, f}}
}

type MappingUint82StringFunc func(next uint8, err error, complete bool, observer StringObserver)
type MappingUint82StringFuncFactory func(observer StringObserver) MappingUint82StringFunc

type MappingUint82StringObservable struct {
	parent Uint8Observable
	mapper MappingUint82StringFuncFactory
}

func (f *MappingUint82StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82StringObservable(parent Uint8Observable, mapper MappingUint82StringFuncFactory) StringObservable {
	return &MappingUint82StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82StringObserveDirect(parent Uint8Observable, mapper MappingUint82StringFunc) StringObservable {
	return MapUint82StringObservable(parent, func(StringObserver) MappingUint82StringFunc {
		return mapper
	})
}

func MapUint82StringObserveNext(parent Uint8Observable, mapper func(uint8) string) StringObservable {
	return MapUint82StringObservable(parent, func(StringObserver) MappingUint82StringFunc {
		return func(next uint8, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82String struct {
	parent Uint8Observable
	mapper func(uint8) StringObservable
}

func (f *flatMapUint82String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *Uint8Stream) MapString(f func(uint8) string) *StringStream {
	return FromStringObservable(MapUint82StringObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapString(f func(uint8) StringObservable) *StringStream {
	return &StringStream{&flatMapUint82String{s, f}}
}

type MappingUint82UintFunc func(next uint8, err error, complete bool, observer UintObserver)
type MappingUint82UintFuncFactory func(observer UintObserver) MappingUint82UintFunc

type MappingUint82UintObservable struct {
	parent Uint8Observable
	mapper MappingUint82UintFuncFactory
}

func (f *MappingUint82UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82UintObservable(parent Uint8Observable, mapper MappingUint82UintFuncFactory) UintObservable {
	return &MappingUint82UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82UintObserveDirect(parent Uint8Observable, mapper MappingUint82UintFunc) UintObservable {
	return MapUint82UintObservable(parent, func(UintObserver) MappingUint82UintFunc {
		return mapper
	})
}

func MapUint82UintObserveNext(parent Uint8Observable, mapper func(uint8) uint) UintObservable {
	return MapUint82UintObservable(parent, func(UintObserver) MappingUint82UintFunc {
		return func(next uint8, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Uint struct {
	parent Uint8Observable
	mapper func(uint8) UintObservable
}

func (f *flatMapUint82Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *Uint8Stream) MapUint(f func(uint8) uint) *UintStream {
	return FromUintObservable(MapUint82UintObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapUint(f func(uint8) UintObservable) *UintStream {
	return &UintStream{&flatMapUint82Uint{s, f}}
}

type MappingUint82IntFunc func(next uint8, err error, complete bool, observer IntObserver)
type MappingUint82IntFuncFactory func(observer IntObserver) MappingUint82IntFunc

type MappingUint82IntObservable struct {
	parent Uint8Observable
	mapper MappingUint82IntFuncFactory
}

func (f *MappingUint82IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82IntObservable(parent Uint8Observable, mapper MappingUint82IntFuncFactory) IntObservable {
	return &MappingUint82IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82IntObserveDirect(parent Uint8Observable, mapper MappingUint82IntFunc) IntObservable {
	return MapUint82IntObservable(parent, func(IntObserver) MappingUint82IntFunc {
		return mapper
	})
}

func MapUint82IntObserveNext(parent Uint8Observable, mapper func(uint8) int) IntObservable {
	return MapUint82IntObservable(parent, func(IntObserver) MappingUint82IntFunc {
		return func(next uint8, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Int struct {
	parent Uint8Observable
	mapper func(uint8) IntObservable
}

func (f *flatMapUint82Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *Uint8Stream) MapInt(f func(uint8) int) *IntStream {
	return FromIntObservable(MapUint82IntObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapInt(f func(uint8) IntObservable) *IntStream {
	return &IntStream{&flatMapUint82Int{s, f}}
}

type MappingUint82Uint8Func func(next uint8, err error, complete bool, observer Uint8Observer)
type MappingUint82Uint8FuncFactory func(observer Uint8Observer) MappingUint82Uint8Func

type MappingUint82Uint8Observable struct {
	parent Uint8Observable
	mapper MappingUint82Uint8FuncFactory
}

func (f *MappingUint82Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82Uint8Observable(parent Uint8Observable, mapper MappingUint82Uint8FuncFactory) Uint8Observable {
	return &MappingUint82Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82Uint8ObserveDirect(parent Uint8Observable, mapper MappingUint82Uint8Func) Uint8Observable {
	return MapUint82Uint8Observable(parent, func(Uint8Observer) MappingUint82Uint8Func {
		return mapper
	})
}

func MapUint82Uint8ObserveNext(parent Uint8Observable, mapper func(uint8) uint8) Uint8Observable {
	return MapUint82Uint8Observable(parent, func(Uint8Observer) MappingUint82Uint8Func {
		return func(next uint8, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Uint8 struct {
	parent Uint8Observable
	mapper func(uint8) Uint8Observable
}

func (f *flatMapUint82Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *Uint8Stream) Map(f func(uint8) uint8) *Uint8Stream {
	return FromUint8Observable(MapUint82Uint8ObserveNext(s, f))
}

func (s *Uint8Stream) FlatMap(f func(uint8) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapUint82Uint8{s, f}}
}

type MappingUint82Int8Func func(next uint8, err error, complete bool, observer Int8Observer)
type MappingUint82Int8FuncFactory func(observer Int8Observer) MappingUint82Int8Func

type MappingUint82Int8Observable struct {
	parent Uint8Observable
	mapper MappingUint82Int8FuncFactory
}

func (f *MappingUint82Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82Int8Observable(parent Uint8Observable, mapper MappingUint82Int8FuncFactory) Int8Observable {
	return &MappingUint82Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82Int8ObserveDirect(parent Uint8Observable, mapper MappingUint82Int8Func) Int8Observable {
	return MapUint82Int8Observable(parent, func(Int8Observer) MappingUint82Int8Func {
		return mapper
	})
}

func MapUint82Int8ObserveNext(parent Uint8Observable, mapper func(uint8) int8) Int8Observable {
	return MapUint82Int8Observable(parent, func(Int8Observer) MappingUint82Int8Func {
		return func(next uint8, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Int8 struct {
	parent Uint8Observable
	mapper func(uint8) Int8Observable
}

func (f *flatMapUint82Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *Uint8Stream) MapInt8(f func(uint8) int8) *Int8Stream {
	return FromInt8Observable(MapUint82Int8ObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapInt8(f func(uint8) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapUint82Int8{s, f}}
}

type MappingUint82Uint16Func func(next uint8, err error, complete bool, observer Uint16Observer)
type MappingUint82Uint16FuncFactory func(observer Uint16Observer) MappingUint82Uint16Func

type MappingUint82Uint16Observable struct {
	parent Uint8Observable
	mapper MappingUint82Uint16FuncFactory
}

func (f *MappingUint82Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82Uint16Observable(parent Uint8Observable, mapper MappingUint82Uint16FuncFactory) Uint16Observable {
	return &MappingUint82Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82Uint16ObserveDirect(parent Uint8Observable, mapper MappingUint82Uint16Func) Uint16Observable {
	return MapUint82Uint16Observable(parent, func(Uint16Observer) MappingUint82Uint16Func {
		return mapper
	})
}

func MapUint82Uint16ObserveNext(parent Uint8Observable, mapper func(uint8) uint16) Uint16Observable {
	return MapUint82Uint16Observable(parent, func(Uint16Observer) MappingUint82Uint16Func {
		return func(next uint8, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Uint16 struct {
	parent Uint8Observable
	mapper func(uint8) Uint16Observable
}

func (f *flatMapUint82Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *Uint8Stream) MapUint16(f func(uint8) uint16) *Uint16Stream {
	return FromUint16Observable(MapUint82Uint16ObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapUint16(f func(uint8) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapUint82Uint16{s, f}}
}

type MappingUint82Int16Func func(next uint8, err error, complete bool, observer Int16Observer)
type MappingUint82Int16FuncFactory func(observer Int16Observer) MappingUint82Int16Func

type MappingUint82Int16Observable struct {
	parent Uint8Observable
	mapper MappingUint82Int16FuncFactory
}

func (f *MappingUint82Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82Int16Observable(parent Uint8Observable, mapper MappingUint82Int16FuncFactory) Int16Observable {
	return &MappingUint82Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82Int16ObserveDirect(parent Uint8Observable, mapper MappingUint82Int16Func) Int16Observable {
	return MapUint82Int16Observable(parent, func(Int16Observer) MappingUint82Int16Func {
		return mapper
	})
}

func MapUint82Int16ObserveNext(parent Uint8Observable, mapper func(uint8) int16) Int16Observable {
	return MapUint82Int16Observable(parent, func(Int16Observer) MappingUint82Int16Func {
		return func(next uint8, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Int16 struct {
	parent Uint8Observable
	mapper func(uint8) Int16Observable
}

func (f *flatMapUint82Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *Uint8Stream) MapInt16(f func(uint8) int16) *Int16Stream {
	return FromInt16Observable(MapUint82Int16ObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapInt16(f func(uint8) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapUint82Int16{s, f}}
}

type MappingUint82Uint32Func func(next uint8, err error, complete bool, observer Uint32Observer)
type MappingUint82Uint32FuncFactory func(observer Uint32Observer) MappingUint82Uint32Func

type MappingUint82Uint32Observable struct {
	parent Uint8Observable
	mapper MappingUint82Uint32FuncFactory
}

func (f *MappingUint82Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82Uint32Observable(parent Uint8Observable, mapper MappingUint82Uint32FuncFactory) Uint32Observable {
	return &MappingUint82Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82Uint32ObserveDirect(parent Uint8Observable, mapper MappingUint82Uint32Func) Uint32Observable {
	return MapUint82Uint32Observable(parent, func(Uint32Observer) MappingUint82Uint32Func {
		return mapper
	})
}

func MapUint82Uint32ObserveNext(parent Uint8Observable, mapper func(uint8) uint32) Uint32Observable {
	return MapUint82Uint32Observable(parent, func(Uint32Observer) MappingUint82Uint32Func {
		return func(next uint8, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Uint32 struct {
	parent Uint8Observable
	mapper func(uint8) Uint32Observable
}

func (f *flatMapUint82Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *Uint8Stream) MapUint32(f func(uint8) uint32) *Uint32Stream {
	return FromUint32Observable(MapUint82Uint32ObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapUint32(f func(uint8) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapUint82Uint32{s, f}}
}

type MappingUint82Int32Func func(next uint8, err error, complete bool, observer Int32Observer)
type MappingUint82Int32FuncFactory func(observer Int32Observer) MappingUint82Int32Func

type MappingUint82Int32Observable struct {
	parent Uint8Observable
	mapper MappingUint82Int32FuncFactory
}

func (f *MappingUint82Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82Int32Observable(parent Uint8Observable, mapper MappingUint82Int32FuncFactory) Int32Observable {
	return &MappingUint82Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82Int32ObserveDirect(parent Uint8Observable, mapper MappingUint82Int32Func) Int32Observable {
	return MapUint82Int32Observable(parent, func(Int32Observer) MappingUint82Int32Func {
		return mapper
	})
}

func MapUint82Int32ObserveNext(parent Uint8Observable, mapper func(uint8) int32) Int32Observable {
	return MapUint82Int32Observable(parent, func(Int32Observer) MappingUint82Int32Func {
		return func(next uint8, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Int32 struct {
	parent Uint8Observable
	mapper func(uint8) Int32Observable
}

func (f *flatMapUint82Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *Uint8Stream) MapInt32(f func(uint8) int32) *Int32Stream {
	return FromInt32Observable(MapUint82Int32ObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapInt32(f func(uint8) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapUint82Int32{s, f}}
}

type MappingUint82Uint64Func func(next uint8, err error, complete bool, observer Uint64Observer)
type MappingUint82Uint64FuncFactory func(observer Uint64Observer) MappingUint82Uint64Func

type MappingUint82Uint64Observable struct {
	parent Uint8Observable
	mapper MappingUint82Uint64FuncFactory
}

func (f *MappingUint82Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82Uint64Observable(parent Uint8Observable, mapper MappingUint82Uint64FuncFactory) Uint64Observable {
	return &MappingUint82Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82Uint64ObserveDirect(parent Uint8Observable, mapper MappingUint82Uint64Func) Uint64Observable {
	return MapUint82Uint64Observable(parent, func(Uint64Observer) MappingUint82Uint64Func {
		return mapper
	})
}

func MapUint82Uint64ObserveNext(parent Uint8Observable, mapper func(uint8) uint64) Uint64Observable {
	return MapUint82Uint64Observable(parent, func(Uint64Observer) MappingUint82Uint64Func {
		return func(next uint8, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Uint64 struct {
	parent Uint8Observable
	mapper func(uint8) Uint64Observable
}

func (f *flatMapUint82Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *Uint8Stream) MapUint64(f func(uint8) uint64) *Uint64Stream {
	return FromUint64Observable(MapUint82Uint64ObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapUint64(f func(uint8) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapUint82Uint64{s, f}}
}

type MappingUint82Int64Func func(next uint8, err error, complete bool, observer Int64Observer)
type MappingUint82Int64FuncFactory func(observer Int64Observer) MappingUint82Int64Func

type MappingUint82Int64Observable struct {
	parent Uint8Observable
	mapper MappingUint82Int64FuncFactory
}

func (f *MappingUint82Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82Int64Observable(parent Uint8Observable, mapper MappingUint82Int64FuncFactory) Int64Observable {
	return &MappingUint82Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82Int64ObserveDirect(parent Uint8Observable, mapper MappingUint82Int64Func) Int64Observable {
	return MapUint82Int64Observable(parent, func(Int64Observer) MappingUint82Int64Func {
		return mapper
	})
}

func MapUint82Int64ObserveNext(parent Uint8Observable, mapper func(uint8) int64) Int64Observable {
	return MapUint82Int64Observable(parent, func(Int64Observer) MappingUint82Int64Func {
		return func(next uint8, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Int64 struct {
	parent Uint8Observable
	mapper func(uint8) Int64Observable
}

func (f *flatMapUint82Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *Uint8Stream) MapInt64(f func(uint8) int64) *Int64Stream {
	return FromInt64Observable(MapUint82Int64ObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapInt64(f func(uint8) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapUint82Int64{s, f}}
}

type MappingUint82Float32Func func(next uint8, err error, complete bool, observer Float32Observer)
type MappingUint82Float32FuncFactory func(observer Float32Observer) MappingUint82Float32Func

type MappingUint82Float32Observable struct {
	parent Uint8Observable
	mapper MappingUint82Float32FuncFactory
}

func (f *MappingUint82Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82Float32Observable(parent Uint8Observable, mapper MappingUint82Float32FuncFactory) Float32Observable {
	return &MappingUint82Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82Float32ObserveDirect(parent Uint8Observable, mapper MappingUint82Float32Func) Float32Observable {
	return MapUint82Float32Observable(parent, func(Float32Observer) MappingUint82Float32Func {
		return mapper
	})
}

func MapUint82Float32ObserveNext(parent Uint8Observable, mapper func(uint8) float32) Float32Observable {
	return MapUint82Float32Observable(parent, func(Float32Observer) MappingUint82Float32Func {
		return func(next uint8, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Float32 struct {
	parent Uint8Observable
	mapper func(uint8) Float32Observable
}

func (f *flatMapUint82Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *Uint8Stream) MapFloat32(f func(uint8) float32) *Float32Stream {
	return FromFloat32Observable(MapUint82Float32ObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapFloat32(f func(uint8) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapUint82Float32{s, f}}
}

type MappingUint82Float64Func func(next uint8, err error, complete bool, observer Float64Observer)
type MappingUint82Float64FuncFactory func(observer Float64Observer) MappingUint82Float64Func

type MappingUint82Float64Observable struct {
	parent Uint8Observable
	mapper MappingUint82Float64FuncFactory
}

func (f *MappingUint82Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82Float64Observable(parent Uint8Observable, mapper MappingUint82Float64FuncFactory) Float64Observable {
	return &MappingUint82Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82Float64ObserveDirect(parent Uint8Observable, mapper MappingUint82Float64Func) Float64Observable {
	return MapUint82Float64Observable(parent, func(Float64Observer) MappingUint82Float64Func {
		return mapper
	})
}

func MapUint82Float64ObserveNext(parent Uint8Observable, mapper func(uint8) float64) Float64Observable {
	return MapUint82Float64Observable(parent, func(Float64Observer) MappingUint82Float64Func {
		return func(next uint8, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Float64 struct {
	parent Uint8Observable
	mapper func(uint8) Float64Observable
}

func (f *flatMapUint82Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *Uint8Stream) MapFloat64(f func(uint8) float64) *Float64Stream {
	return FromFloat64Observable(MapUint82Float64ObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapFloat64(f func(uint8) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapUint82Float64{s, f}}
}

type MappingUint82Complex64Func func(next uint8, err error, complete bool, observer Complex64Observer)
type MappingUint82Complex64FuncFactory func(observer Complex64Observer) MappingUint82Complex64Func

type MappingUint82Complex64Observable struct {
	parent Uint8Observable
	mapper MappingUint82Complex64FuncFactory
}

func (f *MappingUint82Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82Complex64Observable(parent Uint8Observable, mapper MappingUint82Complex64FuncFactory) Complex64Observable {
	return &MappingUint82Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82Complex64ObserveDirect(parent Uint8Observable, mapper MappingUint82Complex64Func) Complex64Observable {
	return MapUint82Complex64Observable(parent, func(Complex64Observer) MappingUint82Complex64Func {
		return mapper
	})
}

func MapUint82Complex64ObserveNext(parent Uint8Observable, mapper func(uint8) complex64) Complex64Observable {
	return MapUint82Complex64Observable(parent, func(Complex64Observer) MappingUint82Complex64Func {
		return func(next uint8, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Complex64 struct {
	parent Uint8Observable
	mapper func(uint8) Complex64Observable
}

func (f *flatMapUint82Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *Uint8Stream) MapComplex64(f func(uint8) complex64) *Complex64Stream {
	return FromComplex64Observable(MapUint82Complex64ObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapComplex64(f func(uint8) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapUint82Complex64{s, f}}
}

type MappingUint82Complex128Func func(next uint8, err error, complete bool, observer Complex128Observer)
type MappingUint82Complex128FuncFactory func(observer Complex128Observer) MappingUint82Complex128Func

type MappingUint82Complex128Observable struct {
	parent Uint8Observable
	mapper MappingUint82Complex128FuncFactory
}

func (f *MappingUint82Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82Complex128Observable(parent Uint8Observable, mapper MappingUint82Complex128FuncFactory) Complex128Observable {
	return &MappingUint82Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82Complex128ObserveDirect(parent Uint8Observable, mapper MappingUint82Complex128Func) Complex128Observable {
	return MapUint82Complex128Observable(parent, func(Complex128Observer) MappingUint82Complex128Func {
		return mapper
	})
}

func MapUint82Complex128ObserveNext(parent Uint8Observable, mapper func(uint8) complex128) Complex128Observable {
	return MapUint82Complex128Observable(parent, func(Complex128Observer) MappingUint82Complex128Func {
		return func(next uint8, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Complex128 struct {
	parent Uint8Observable
	mapper func(uint8) Complex128Observable
}

func (f *flatMapUint82Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *Uint8Stream) MapComplex128(f func(uint8) complex128) *Complex128Stream {
	return FromComplex128Observable(MapUint82Complex128ObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapComplex128(f func(uint8) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapUint82Complex128{s, f}}
}

type MappingUint82TimeFunc func(next uint8, err error, complete bool, observer TimeObserver)
type MappingUint82TimeFuncFactory func(observer TimeObserver) MappingUint82TimeFunc

type MappingUint82TimeObservable struct {
	parent Uint8Observable
	mapper MappingUint82TimeFuncFactory
}

func (f *MappingUint82TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82TimeObservable(parent Uint8Observable, mapper MappingUint82TimeFuncFactory) TimeObservable {
	return &MappingUint82TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82TimeObserveDirect(parent Uint8Observable, mapper MappingUint82TimeFunc) TimeObservable {
	return MapUint82TimeObservable(parent, func(TimeObserver) MappingUint82TimeFunc {
		return mapper
	})
}

func MapUint82TimeObserveNext(parent Uint8Observable, mapper func(uint8) time.Time) TimeObservable {
	return MapUint82TimeObservable(parent, func(TimeObserver) MappingUint82TimeFunc {
		return func(next uint8, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Time struct {
	parent Uint8Observable
	mapper func(uint8) TimeObservable
}

func (f *flatMapUint82Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *Uint8Stream) MapTime(f func(uint8) time.Time) *TimeStream {
	return FromTimeObservable(MapUint82TimeObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapTime(f func(uint8) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapUint82Time{s, f}}
}

type MappingUint82DurationFunc func(next uint8, err error, complete bool, observer DurationObserver)
type MappingUint82DurationFuncFactory func(observer DurationObserver) MappingUint82DurationFunc

type MappingUint82DurationObservable struct {
	parent Uint8Observable
	mapper MappingUint82DurationFuncFactory
}

func (f *MappingUint82DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint82DurationObservable(parent Uint8Observable, mapper MappingUint82DurationFuncFactory) DurationObservable {
	return &MappingUint82DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint82DurationObserveDirect(parent Uint8Observable, mapper MappingUint82DurationFunc) DurationObservable {
	return MapUint82DurationObservable(parent, func(DurationObserver) MappingUint82DurationFunc {
		return mapper
	})
}

func MapUint82DurationObserveNext(parent Uint8Observable, mapper func(uint8) time.Duration) DurationObservable {
	return MapUint82DurationObservable(parent, func(DurationObserver) MappingUint82DurationFunc {
		return func(next uint8, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint82Duration struct {
	parent Uint8Observable
	mapper func(uint8) DurationObservable
}

func (f *flatMapUint82Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint8ObserverFunc(func(next uint8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *Uint8Stream) MapDuration(f func(uint8) time.Duration) *DurationStream {
	return FromDurationObservable(MapUint82DurationObserveNext(s, f))
}

func (s *Uint8Stream) FlatMapDuration(f func(uint8) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapUint82Duration{s, f}}
}

type Int8Observer interface {
	Next(int8)
	TerminationObserver
}

// A Int8Subscriber represents a subscribed Int8Observer.
type Int8Subscriber interface {
	Subscription
	Int8Observer
}

type implInt8Subscriber struct {
	Subscription
	Int8Observer
}

func Int8ObserverAsGenericObserver(observer Int8Observer) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(int8))
		}
	})
}

func GenericObserverAsInt8Observer(observer GenericObserver) Int8Observer {
	return Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type Int8ObservableFactory func(observer Int8Observer, subscription Subscription)

func (f Int8ObservableFactory) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateInt8 calls f(observer, subscription) to produce values for a stream.
func CreateInt8(f func(observer Int8Observer, subscription Subscription)) *Int8Stream {
	return FromInt8Observable(Int8ObservableFactory(f))
}

// Repeat value count times.
func RepeatInt8(value int8, count int) *Int8Stream {
	return CreateInt8(func(observer Int8Observer, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartInt8 is designed to be used with functions that return a
// (int8, error) tuple.
//
// If the error is non-nil the returned Int8Stream will be that error,
// otherwise it will be a single-value stream of int8.
func StartInt8(f func() (int8, error)) *Int8Stream {
	return CreateInt8(func(observer Int8Observer, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughInt8(next int8, err error, complete bool, observer Int8Observer) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroInt8 = *new(int8)

type Int8ObserverFunc func(int8, error, bool)

func (f Int8ObserverFunc) Next(next int8)  { f(next, nil, false) }
func (f Int8ObserverFunc) Error(err error) { f(zeroInt8, err, false) }
func (f Int8ObserverFunc) Complete()       { f(zeroInt8, nil, true) }

type Int8Observable interface {
	Subscribe(Int8Observer) Subscription
}

// Convert a GenericObservableFilter to a Int8Observable
func (f GenericObservableFilterFactory) Int8(parent Int8Observable) Int8Observable {
	return MapInt82Int8Observable(parent, func(observer Int8Observer) MappingInt82Int8Func {
		gobserver := Int8ObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next int8, err error, complete bool, observer Int8Observer) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverInt8() *Int8Stream {
	return CreateInt8(func(observer Int8Observer, subscription Subscription) {})
}

func EmptyInt8() *Int8Stream {
	return CreateInt8(func(observer Int8Observer, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowInt8(err error) *Int8Stream {
	return CreateInt8(func(observer Int8Observer, subscription Subscription) {
		observer.Error(err)
	})
}

func FromInt8Array(array []int8) *Int8Stream {
	return CreateInt8(func(observer Int8Observer, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromInt8s(array ...int8) *Int8Stream {
	return FromInt8Array(array)
}

func JustInt8(element int8) *Int8Stream {
	return FromInt8Array([]int8{element})
}

func MergeInt8(observables ...Int8Observable) *Int8Stream {
	if len(observables) == 0 {
		return EmptyInt8()
	}
	return (&Int8Stream{observables[0]}).Merge(observables[1:]...)
}

func MergeInt8DelayError(observables ...Int8Observable) *Int8Stream {
	if len(observables) == 0 {
		return EmptyInt8()
	}
	return (&Int8Stream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromInt8Channel(ch <-chan int8) *Int8Stream {
	return CreateInt8(func(observer Int8Observer, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type Int8Stream struct {
	Int8Observable
}

func FromInt8Observable(observable Int8Observable) *Int8Stream {
	return &Int8Stream{observable}
}

func (s *Int8Stream) SubscribeFunc(f func(int8, error, bool)) Subscription {
	return s.Subscribe(Int8ObserverFunc(f))
}

func (s *Int8Stream) SubscribeNext(f func(v int8)) Subscription {
	return s.SubscribeFunc(func(next int8, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *Int8Stream) Distinct() *Int8Stream {
	return FromInt8Observable(distinctFilter().Int8(s))
}

// ElementAt yields the Nth element of the stream.
func (s *Int8Stream) ElementAt(n int) *Int8Stream {
	return FromInt8Observable(elementAtFilter(n).Int8(s))
}

// Filter elements in the stream on a function.
func (s *Int8Stream) Filter(f func(int8) bool) *Int8Stream {
	return FromInt8Observable(filterFilter(func(v interface{}) bool { return f(v.(int8)) }).Int8(s))
}

// Last returns just the first element of the stream.
func (s *Int8Stream) First() *Int8Stream {
	return FromInt8Observable(firstFilter().Int8(s))
}

// Last returns just the last element of the stream.
func (s *Int8Stream) Last() *Int8Stream {
	return FromInt8Observable(lastFilter().Int8(s))
}

// SkipLast skips the first N elements of the stream.
func (s *Int8Stream) Skip(n int) *Int8Stream {
	return FromInt8Observable(skipFilter(n).Int8(s))
}

// SkipLast skips the last N elements of the stream.
func (s *Int8Stream) SkipLast(n int) *Int8Stream {
	return FromInt8Observable(skipLastFilter(n).Int8(s))
}

// Take returns just the first N elements of the stream.
func (s *Int8Stream) Take(n int) *Int8Stream {
	return FromInt8Observable(takeFilter(n).Int8(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *Int8Stream) TakeLast(n int) *Int8Stream {
	return FromInt8Observable(takeLastFilter(n).Int8(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *Int8Stream) IgnoreElements() *Int8Stream {
	return FromInt8Observable(ignoreElementsFilter().Int8(s))
}

func (s *Int8Stream) Replay(size int, duration time.Duration) *Int8Stream {
	return FromInt8Observable(replayFilter(size, duration).Int8(s))
}

func (s *Int8Stream) Sample(duration time.Duration) *Int8Stream {
	return FromInt8Observable(sampleFilter(duration).Int8(s))
}

func (s *Int8Stream) Debounce(duration time.Duration) *Int8Stream {
	return FromInt8Observable(debounceFilter(duration).Int8(s))
}

// Wait for completion of the stream and return any error.
func (s *Int8Stream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeInt8Subscriber(observer Int8Observer) Int8Subscriber {
	if subscriber, ok := observer.(Int8Subscriber); ok {
		return subscriber
	}
	return &implInt8Subscriber{NewGenericSubscription(), observer}
}

type concatInt8Subscriber struct {
	observable  int
	observer    Int8Observer
	observables []Int8Observable
	Subscription
}

func (c *concatInt8Subscriber) Next(next int8) {
	c.observer.Next(next)
}

func (c *concatInt8Subscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatInt8Subscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatInt8Observable struct {
	observables []Int8Observable
}

func (m *concatInt8Observable) Subscribe(observer Int8Observer) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatInt8Subscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *Int8Stream) Concat(observables ...Int8Observable) *Int8Stream {
	return &Int8Stream{&concatInt8Observable{append([]Int8Observable{s}, observables...)}}
}

type mergeInt8Observable struct {
	delayError  bool
	observables []Int8Observable
}

func (m *mergeInt8Observable) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next int8, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(Int8ObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *Int8Stream) Merge(other ...Int8Observable) *Int8Stream {
	if len(other) == 0 {
		return s
	}
	return &Int8Stream{&mergeInt8Observable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *Int8Stream) MergeDelayError(other ...Int8Observable) *Int8Stream {
	if len(other) == 0 {
		return s
	}
	return &Int8Stream{&mergeInt8Observable{true, append(other, s)}}
}

type catchInt8Observable struct {
	parent Int8Observable
	catch  Int8Observable
}

func (r *catchInt8Observable) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	run := func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(Int8ObserverFunc(run))
	return subscription
}

func (s *Int8Stream) Catch(catch Int8Observable) *Int8Stream {
	return &Int8Stream{&catchInt8Observable{s, catch}}
}

type retryInt8Observable struct {
	observable Int8Observable
}

type retryInt8Observer struct {
	observable Int8Observable
	observer   Int8Observer
}

func (r *retryInt8Observer) retry(next int8, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(Int8ObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryInt8Observable) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryInt8Observer{r.observable, observer}
	r.observable.Subscribe(Int8ObserverFunc(ro.retry))
	return subscription
}

func (s *Int8Stream) Retry() *Int8Stream {
	return &Int8Stream{&retryInt8Observable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *Int8Stream) Do(f func(next int8)) *Int8Stream {
	return FromInt8Observable(MapInt82Int8ObserveNext(s, func(next int8) int8 {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *Int8Stream) DoOnError(f func(err error)) *Int8Stream {
	return FromInt8Observable(MapInt82Int8ObserveDirect(s, func(next int8, err error, complete bool, observer Int8Observer) {
		if err != nil {
			f(err)
		}
		PassthroughInt8(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *Int8Stream) DoOnComplete(f func()) *Int8Stream {
	return FromInt8Observable(MapInt82Int8ObserveDirect(s, func(next int8, err error, complete bool, observer Int8Observer) {
		if complete {
			f()
		}
		PassthroughInt8(next, err, complete, observer)
	}))
}

func (s *Int8Stream) Reduce(initial int8, reducer func(int8, int8) int8) *Int8Stream {
	value := initial
	return FromInt8Observable(MapInt82Int8ObserveDirect(s, func(next int8, err error, complete bool, observer Int8Observer) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *Int8Stream) Scan(initial int8, f func(int8, int8) int8) *Int8Stream {
	value := initial
	return FromInt8Observable(MapInt82Int8ObserveDirect(s, func(next int8, err error, complete bool, observer Int8Observer) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutInt8 struct {
	parent  Int8Observable
	timeout time.Duration
}

func (t *timeoutInt8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *Int8Stream) Timeout(timeout time.Duration) *Int8Stream {
	return &Int8Stream{&timeoutInt8{s, timeout}}
}

type forkedInt8Stream struct {
	lock      sync.Mutex
	parent    Int8Observable
	observers []Int8Observer
}

func (f *forkedInt8Stream) Subscribe(observer Int8Observer) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *Int8Stream) Fork() *Int8Stream {
	f := &forkedInt8Stream{parent: s}
	go s.Subscribe(Int8ObserverFunc(func(n int8, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &Int8Stream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *Int8Stream) ToOneWithError() (int8, error) {
	valuech := make(chan int8, 1)
	errch := make(chan error, 1)
	FromInt8Observable(oneFilter().Int8(s)).SubscribeFunc(func(next int8, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroInt8, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *Int8Stream) ToOne() int8 {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *Int8Stream) ToArrayWithError() ([]int8, error) {
	array := []int8{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *Int8Stream) ToArray() []int8 {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *Int8Stream) ToChannelWithError() (<-chan int8, <-chan error) {
	ch := make(chan int8, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *Int8Stream) ToChannel() <-chan int8 {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *Int8Stream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapInt82IntObserveDirect(s, func(next int8, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

func (s *Int8Stream) Average() *Int8Stream {
	var sum int8
	var count int8
	return FromInt8Observable(MapInt82Int8ObserveDirect(s, func(next int8, err error, complete bool, observer Int8Observer) {
		switch {
		case err != nil:
			observer.Next(sum / count)
			observer.Error(err)
		case complete:
			observer.Next(sum / count)
			observer.Complete()
		default:
			sum += next
			count++
		}
	}))
}

func (s *Int8Stream) Sum() *Int8Stream {
	var sum int8
	return FromInt8Observable(MapInt82Int8ObserveDirect(s, func(next int8, err error, complete bool, observer Int8Observer) {
		switch {
		case err != nil:
			observer.Next(sum)
			observer.Error(err)
		case complete:
			observer.Next(sum)
			observer.Complete()
		default:
			sum += next
		}
	}))
}

func (s *Int8Stream) Min() *Int8Stream {
	started := false
	var min int8
	return FromInt8Observable(MapInt82Int8ObserveDirect(s, func(next int8, err error, complete bool, observer Int8Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(min)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(min)
			}
			observer.Complete()
		default:
			if started {
				if min > next {
					min = next
				}
			} else {
				min = next
				started = true
			}
		}
	}))
}

func (s *Int8Stream) Max() *Int8Stream {
	started := false
	var max int8
	return FromInt8Observable(MapInt82Int8ObserveDirect(s, func(next int8, err error, complete bool, observer Int8Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(max)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(max)
			}
			observer.Complete()
		default:
			if started {
				if max <= next {
					max = next
				}
			} else {
				max = next
				started = true
			}
		}
	}))
}

type MappingInt82BoolFunc func(next int8, err error, complete bool, observer BoolObserver)
type MappingInt82BoolFuncFactory func(observer BoolObserver) MappingInt82BoolFunc

type MappingInt82BoolObservable struct {
	parent Int8Observable
	mapper MappingInt82BoolFuncFactory
}

func (f *MappingInt82BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82BoolObservable(parent Int8Observable, mapper MappingInt82BoolFuncFactory) BoolObservable {
	return &MappingInt82BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82BoolObserveDirect(parent Int8Observable, mapper MappingInt82BoolFunc) BoolObservable {
	return MapInt82BoolObservable(parent, func(BoolObserver) MappingInt82BoolFunc {
		return mapper
	})
}

func MapInt82BoolObserveNext(parent Int8Observable, mapper func(int8) bool) BoolObservable {
	return MapInt82BoolObservable(parent, func(BoolObserver) MappingInt82BoolFunc {
		return func(next int8, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Bool struct {
	parent Int8Observable
	mapper func(int8) BoolObservable
}

func (f *flatMapInt82Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *Int8Stream) MapBool(f func(int8) bool) *BoolStream {
	return FromBoolObservable(MapInt82BoolObserveNext(s, f))
}

func (s *Int8Stream) FlatMapBool(f func(int8) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapInt82Bool{s, f}}
}

type MappingInt82RuneFunc func(next int8, err error, complete bool, observer RuneObserver)
type MappingInt82RuneFuncFactory func(observer RuneObserver) MappingInt82RuneFunc

type MappingInt82RuneObservable struct {
	parent Int8Observable
	mapper MappingInt82RuneFuncFactory
}

func (f *MappingInt82RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82RuneObservable(parent Int8Observable, mapper MappingInt82RuneFuncFactory) RuneObservable {
	return &MappingInt82RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82RuneObserveDirect(parent Int8Observable, mapper MappingInt82RuneFunc) RuneObservable {
	return MapInt82RuneObservable(parent, func(RuneObserver) MappingInt82RuneFunc {
		return mapper
	})
}

func MapInt82RuneObserveNext(parent Int8Observable, mapper func(int8) rune) RuneObservable {
	return MapInt82RuneObservable(parent, func(RuneObserver) MappingInt82RuneFunc {
		return func(next int8, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Rune struct {
	parent Int8Observable
	mapper func(int8) RuneObservable
}

func (f *flatMapInt82Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *Int8Stream) MapRune(f func(int8) rune) *RuneStream {
	return FromRuneObservable(MapInt82RuneObserveNext(s, f))
}

func (s *Int8Stream) FlatMapRune(f func(int8) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapInt82Rune{s, f}}
}

type MappingInt82ByteFunc func(next int8, err error, complete bool, observer ByteObserver)
type MappingInt82ByteFuncFactory func(observer ByteObserver) MappingInt82ByteFunc

type MappingInt82ByteObservable struct {
	parent Int8Observable
	mapper MappingInt82ByteFuncFactory
}

func (f *MappingInt82ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82ByteObservable(parent Int8Observable, mapper MappingInt82ByteFuncFactory) ByteObservable {
	return &MappingInt82ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82ByteObserveDirect(parent Int8Observable, mapper MappingInt82ByteFunc) ByteObservable {
	return MapInt82ByteObservable(parent, func(ByteObserver) MappingInt82ByteFunc {
		return mapper
	})
}

func MapInt82ByteObserveNext(parent Int8Observable, mapper func(int8) byte) ByteObservable {
	return MapInt82ByteObservable(parent, func(ByteObserver) MappingInt82ByteFunc {
		return func(next int8, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Byte struct {
	parent Int8Observable
	mapper func(int8) ByteObservable
}

func (f *flatMapInt82Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *Int8Stream) MapByte(f func(int8) byte) *ByteStream {
	return FromByteObservable(MapInt82ByteObserveNext(s, f))
}

func (s *Int8Stream) FlatMapByte(f func(int8) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapInt82Byte{s, f}}
}

type MappingInt82StringFunc func(next int8, err error, complete bool, observer StringObserver)
type MappingInt82StringFuncFactory func(observer StringObserver) MappingInt82StringFunc

type MappingInt82StringObservable struct {
	parent Int8Observable
	mapper MappingInt82StringFuncFactory
}

func (f *MappingInt82StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82StringObservable(parent Int8Observable, mapper MappingInt82StringFuncFactory) StringObservable {
	return &MappingInt82StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82StringObserveDirect(parent Int8Observable, mapper MappingInt82StringFunc) StringObservable {
	return MapInt82StringObservable(parent, func(StringObserver) MappingInt82StringFunc {
		return mapper
	})
}

func MapInt82StringObserveNext(parent Int8Observable, mapper func(int8) string) StringObservable {
	return MapInt82StringObservable(parent, func(StringObserver) MappingInt82StringFunc {
		return func(next int8, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82String struct {
	parent Int8Observable
	mapper func(int8) StringObservable
}

func (f *flatMapInt82String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *Int8Stream) MapString(f func(int8) string) *StringStream {
	return FromStringObservable(MapInt82StringObserveNext(s, f))
}

func (s *Int8Stream) FlatMapString(f func(int8) StringObservable) *StringStream {
	return &StringStream{&flatMapInt82String{s, f}}
}

type MappingInt82UintFunc func(next int8, err error, complete bool, observer UintObserver)
type MappingInt82UintFuncFactory func(observer UintObserver) MappingInt82UintFunc

type MappingInt82UintObservable struct {
	parent Int8Observable
	mapper MappingInt82UintFuncFactory
}

func (f *MappingInt82UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82UintObservable(parent Int8Observable, mapper MappingInt82UintFuncFactory) UintObservable {
	return &MappingInt82UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82UintObserveDirect(parent Int8Observable, mapper MappingInt82UintFunc) UintObservable {
	return MapInt82UintObservable(parent, func(UintObserver) MappingInt82UintFunc {
		return mapper
	})
}

func MapInt82UintObserveNext(parent Int8Observable, mapper func(int8) uint) UintObservable {
	return MapInt82UintObservable(parent, func(UintObserver) MappingInt82UintFunc {
		return func(next int8, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Uint struct {
	parent Int8Observable
	mapper func(int8) UintObservable
}

func (f *flatMapInt82Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *Int8Stream) MapUint(f func(int8) uint) *UintStream {
	return FromUintObservable(MapInt82UintObserveNext(s, f))
}

func (s *Int8Stream) FlatMapUint(f func(int8) UintObservable) *UintStream {
	return &UintStream{&flatMapInt82Uint{s, f}}
}

type MappingInt82IntFunc func(next int8, err error, complete bool, observer IntObserver)
type MappingInt82IntFuncFactory func(observer IntObserver) MappingInt82IntFunc

type MappingInt82IntObservable struct {
	parent Int8Observable
	mapper MappingInt82IntFuncFactory
}

func (f *MappingInt82IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82IntObservable(parent Int8Observable, mapper MappingInt82IntFuncFactory) IntObservable {
	return &MappingInt82IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82IntObserveDirect(parent Int8Observable, mapper MappingInt82IntFunc) IntObservable {
	return MapInt82IntObservable(parent, func(IntObserver) MappingInt82IntFunc {
		return mapper
	})
}

func MapInt82IntObserveNext(parent Int8Observable, mapper func(int8) int) IntObservable {
	return MapInt82IntObservable(parent, func(IntObserver) MappingInt82IntFunc {
		return func(next int8, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Int struct {
	parent Int8Observable
	mapper func(int8) IntObservable
}

func (f *flatMapInt82Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *Int8Stream) MapInt(f func(int8) int) *IntStream {
	return FromIntObservable(MapInt82IntObserveNext(s, f))
}

func (s *Int8Stream) FlatMapInt(f func(int8) IntObservable) *IntStream {
	return &IntStream{&flatMapInt82Int{s, f}}
}

type MappingInt82Uint8Func func(next int8, err error, complete bool, observer Uint8Observer)
type MappingInt82Uint8FuncFactory func(observer Uint8Observer) MappingInt82Uint8Func

type MappingInt82Uint8Observable struct {
	parent Int8Observable
	mapper MappingInt82Uint8FuncFactory
}

func (f *MappingInt82Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82Uint8Observable(parent Int8Observable, mapper MappingInt82Uint8FuncFactory) Uint8Observable {
	return &MappingInt82Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82Uint8ObserveDirect(parent Int8Observable, mapper MappingInt82Uint8Func) Uint8Observable {
	return MapInt82Uint8Observable(parent, func(Uint8Observer) MappingInt82Uint8Func {
		return mapper
	})
}

func MapInt82Uint8ObserveNext(parent Int8Observable, mapper func(int8) uint8) Uint8Observable {
	return MapInt82Uint8Observable(parent, func(Uint8Observer) MappingInt82Uint8Func {
		return func(next int8, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Uint8 struct {
	parent Int8Observable
	mapper func(int8) Uint8Observable
}

func (f *flatMapInt82Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *Int8Stream) MapUint8(f func(int8) uint8) *Uint8Stream {
	return FromUint8Observable(MapInt82Uint8ObserveNext(s, f))
}

func (s *Int8Stream) FlatMapUint8(f func(int8) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapInt82Uint8{s, f}}
}

type MappingInt82Int8Func func(next int8, err error, complete bool, observer Int8Observer)
type MappingInt82Int8FuncFactory func(observer Int8Observer) MappingInt82Int8Func

type MappingInt82Int8Observable struct {
	parent Int8Observable
	mapper MappingInt82Int8FuncFactory
}

func (f *MappingInt82Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82Int8Observable(parent Int8Observable, mapper MappingInt82Int8FuncFactory) Int8Observable {
	return &MappingInt82Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82Int8ObserveDirect(parent Int8Observable, mapper MappingInt82Int8Func) Int8Observable {
	return MapInt82Int8Observable(parent, func(Int8Observer) MappingInt82Int8Func {
		return mapper
	})
}

func MapInt82Int8ObserveNext(parent Int8Observable, mapper func(int8) int8) Int8Observable {
	return MapInt82Int8Observable(parent, func(Int8Observer) MappingInt82Int8Func {
		return func(next int8, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Int8 struct {
	parent Int8Observable
	mapper func(int8) Int8Observable
}

func (f *flatMapInt82Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *Int8Stream) Map(f func(int8) int8) *Int8Stream {
	return FromInt8Observable(MapInt82Int8ObserveNext(s, f))
}

func (s *Int8Stream) FlatMap(f func(int8) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapInt82Int8{s, f}}
}

type MappingInt82Uint16Func func(next int8, err error, complete bool, observer Uint16Observer)
type MappingInt82Uint16FuncFactory func(observer Uint16Observer) MappingInt82Uint16Func

type MappingInt82Uint16Observable struct {
	parent Int8Observable
	mapper MappingInt82Uint16FuncFactory
}

func (f *MappingInt82Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82Uint16Observable(parent Int8Observable, mapper MappingInt82Uint16FuncFactory) Uint16Observable {
	return &MappingInt82Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82Uint16ObserveDirect(parent Int8Observable, mapper MappingInt82Uint16Func) Uint16Observable {
	return MapInt82Uint16Observable(parent, func(Uint16Observer) MappingInt82Uint16Func {
		return mapper
	})
}

func MapInt82Uint16ObserveNext(parent Int8Observable, mapper func(int8) uint16) Uint16Observable {
	return MapInt82Uint16Observable(parent, func(Uint16Observer) MappingInt82Uint16Func {
		return func(next int8, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Uint16 struct {
	parent Int8Observable
	mapper func(int8) Uint16Observable
}

func (f *flatMapInt82Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *Int8Stream) MapUint16(f func(int8) uint16) *Uint16Stream {
	return FromUint16Observable(MapInt82Uint16ObserveNext(s, f))
}

func (s *Int8Stream) FlatMapUint16(f func(int8) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapInt82Uint16{s, f}}
}

type MappingInt82Int16Func func(next int8, err error, complete bool, observer Int16Observer)
type MappingInt82Int16FuncFactory func(observer Int16Observer) MappingInt82Int16Func

type MappingInt82Int16Observable struct {
	parent Int8Observable
	mapper MappingInt82Int16FuncFactory
}

func (f *MappingInt82Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82Int16Observable(parent Int8Observable, mapper MappingInt82Int16FuncFactory) Int16Observable {
	return &MappingInt82Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82Int16ObserveDirect(parent Int8Observable, mapper MappingInt82Int16Func) Int16Observable {
	return MapInt82Int16Observable(parent, func(Int16Observer) MappingInt82Int16Func {
		return mapper
	})
}

func MapInt82Int16ObserveNext(parent Int8Observable, mapper func(int8) int16) Int16Observable {
	return MapInt82Int16Observable(parent, func(Int16Observer) MappingInt82Int16Func {
		return func(next int8, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Int16 struct {
	parent Int8Observable
	mapper func(int8) Int16Observable
}

func (f *flatMapInt82Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *Int8Stream) MapInt16(f func(int8) int16) *Int16Stream {
	return FromInt16Observable(MapInt82Int16ObserveNext(s, f))
}

func (s *Int8Stream) FlatMapInt16(f func(int8) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapInt82Int16{s, f}}
}

type MappingInt82Uint32Func func(next int8, err error, complete bool, observer Uint32Observer)
type MappingInt82Uint32FuncFactory func(observer Uint32Observer) MappingInt82Uint32Func

type MappingInt82Uint32Observable struct {
	parent Int8Observable
	mapper MappingInt82Uint32FuncFactory
}

func (f *MappingInt82Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82Uint32Observable(parent Int8Observable, mapper MappingInt82Uint32FuncFactory) Uint32Observable {
	return &MappingInt82Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82Uint32ObserveDirect(parent Int8Observable, mapper MappingInt82Uint32Func) Uint32Observable {
	return MapInt82Uint32Observable(parent, func(Uint32Observer) MappingInt82Uint32Func {
		return mapper
	})
}

func MapInt82Uint32ObserveNext(parent Int8Observable, mapper func(int8) uint32) Uint32Observable {
	return MapInt82Uint32Observable(parent, func(Uint32Observer) MappingInt82Uint32Func {
		return func(next int8, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Uint32 struct {
	parent Int8Observable
	mapper func(int8) Uint32Observable
}

func (f *flatMapInt82Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *Int8Stream) MapUint32(f func(int8) uint32) *Uint32Stream {
	return FromUint32Observable(MapInt82Uint32ObserveNext(s, f))
}

func (s *Int8Stream) FlatMapUint32(f func(int8) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapInt82Uint32{s, f}}
}

type MappingInt82Int32Func func(next int8, err error, complete bool, observer Int32Observer)
type MappingInt82Int32FuncFactory func(observer Int32Observer) MappingInt82Int32Func

type MappingInt82Int32Observable struct {
	parent Int8Observable
	mapper MappingInt82Int32FuncFactory
}

func (f *MappingInt82Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82Int32Observable(parent Int8Observable, mapper MappingInt82Int32FuncFactory) Int32Observable {
	return &MappingInt82Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82Int32ObserveDirect(parent Int8Observable, mapper MappingInt82Int32Func) Int32Observable {
	return MapInt82Int32Observable(parent, func(Int32Observer) MappingInt82Int32Func {
		return mapper
	})
}

func MapInt82Int32ObserveNext(parent Int8Observable, mapper func(int8) int32) Int32Observable {
	return MapInt82Int32Observable(parent, func(Int32Observer) MappingInt82Int32Func {
		return func(next int8, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Int32 struct {
	parent Int8Observable
	mapper func(int8) Int32Observable
}

func (f *flatMapInt82Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *Int8Stream) MapInt32(f func(int8) int32) *Int32Stream {
	return FromInt32Observable(MapInt82Int32ObserveNext(s, f))
}

func (s *Int8Stream) FlatMapInt32(f func(int8) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapInt82Int32{s, f}}
}

type MappingInt82Uint64Func func(next int8, err error, complete bool, observer Uint64Observer)
type MappingInt82Uint64FuncFactory func(observer Uint64Observer) MappingInt82Uint64Func

type MappingInt82Uint64Observable struct {
	parent Int8Observable
	mapper MappingInt82Uint64FuncFactory
}

func (f *MappingInt82Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82Uint64Observable(parent Int8Observable, mapper MappingInt82Uint64FuncFactory) Uint64Observable {
	return &MappingInt82Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82Uint64ObserveDirect(parent Int8Observable, mapper MappingInt82Uint64Func) Uint64Observable {
	return MapInt82Uint64Observable(parent, func(Uint64Observer) MappingInt82Uint64Func {
		return mapper
	})
}

func MapInt82Uint64ObserveNext(parent Int8Observable, mapper func(int8) uint64) Uint64Observable {
	return MapInt82Uint64Observable(parent, func(Uint64Observer) MappingInt82Uint64Func {
		return func(next int8, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Uint64 struct {
	parent Int8Observable
	mapper func(int8) Uint64Observable
}

func (f *flatMapInt82Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *Int8Stream) MapUint64(f func(int8) uint64) *Uint64Stream {
	return FromUint64Observable(MapInt82Uint64ObserveNext(s, f))
}

func (s *Int8Stream) FlatMapUint64(f func(int8) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapInt82Uint64{s, f}}
}

type MappingInt82Int64Func func(next int8, err error, complete bool, observer Int64Observer)
type MappingInt82Int64FuncFactory func(observer Int64Observer) MappingInt82Int64Func

type MappingInt82Int64Observable struct {
	parent Int8Observable
	mapper MappingInt82Int64FuncFactory
}

func (f *MappingInt82Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82Int64Observable(parent Int8Observable, mapper MappingInt82Int64FuncFactory) Int64Observable {
	return &MappingInt82Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82Int64ObserveDirect(parent Int8Observable, mapper MappingInt82Int64Func) Int64Observable {
	return MapInt82Int64Observable(parent, func(Int64Observer) MappingInt82Int64Func {
		return mapper
	})
}

func MapInt82Int64ObserveNext(parent Int8Observable, mapper func(int8) int64) Int64Observable {
	return MapInt82Int64Observable(parent, func(Int64Observer) MappingInt82Int64Func {
		return func(next int8, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Int64 struct {
	parent Int8Observable
	mapper func(int8) Int64Observable
}

func (f *flatMapInt82Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *Int8Stream) MapInt64(f func(int8) int64) *Int64Stream {
	return FromInt64Observable(MapInt82Int64ObserveNext(s, f))
}

func (s *Int8Stream) FlatMapInt64(f func(int8) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapInt82Int64{s, f}}
}

type MappingInt82Float32Func func(next int8, err error, complete bool, observer Float32Observer)
type MappingInt82Float32FuncFactory func(observer Float32Observer) MappingInt82Float32Func

type MappingInt82Float32Observable struct {
	parent Int8Observable
	mapper MappingInt82Float32FuncFactory
}

func (f *MappingInt82Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82Float32Observable(parent Int8Observable, mapper MappingInt82Float32FuncFactory) Float32Observable {
	return &MappingInt82Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82Float32ObserveDirect(parent Int8Observable, mapper MappingInt82Float32Func) Float32Observable {
	return MapInt82Float32Observable(parent, func(Float32Observer) MappingInt82Float32Func {
		return mapper
	})
}

func MapInt82Float32ObserveNext(parent Int8Observable, mapper func(int8) float32) Float32Observable {
	return MapInt82Float32Observable(parent, func(Float32Observer) MappingInt82Float32Func {
		return func(next int8, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Float32 struct {
	parent Int8Observable
	mapper func(int8) Float32Observable
}

func (f *flatMapInt82Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *Int8Stream) MapFloat32(f func(int8) float32) *Float32Stream {
	return FromFloat32Observable(MapInt82Float32ObserveNext(s, f))
}

func (s *Int8Stream) FlatMapFloat32(f func(int8) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapInt82Float32{s, f}}
}

type MappingInt82Float64Func func(next int8, err error, complete bool, observer Float64Observer)
type MappingInt82Float64FuncFactory func(observer Float64Observer) MappingInt82Float64Func

type MappingInt82Float64Observable struct {
	parent Int8Observable
	mapper MappingInt82Float64FuncFactory
}

func (f *MappingInt82Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82Float64Observable(parent Int8Observable, mapper MappingInt82Float64FuncFactory) Float64Observable {
	return &MappingInt82Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82Float64ObserveDirect(parent Int8Observable, mapper MappingInt82Float64Func) Float64Observable {
	return MapInt82Float64Observable(parent, func(Float64Observer) MappingInt82Float64Func {
		return mapper
	})
}

func MapInt82Float64ObserveNext(parent Int8Observable, mapper func(int8) float64) Float64Observable {
	return MapInt82Float64Observable(parent, func(Float64Observer) MappingInt82Float64Func {
		return func(next int8, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Float64 struct {
	parent Int8Observable
	mapper func(int8) Float64Observable
}

func (f *flatMapInt82Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *Int8Stream) MapFloat64(f func(int8) float64) *Float64Stream {
	return FromFloat64Observable(MapInt82Float64ObserveNext(s, f))
}

func (s *Int8Stream) FlatMapFloat64(f func(int8) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapInt82Float64{s, f}}
}

type MappingInt82Complex64Func func(next int8, err error, complete bool, observer Complex64Observer)
type MappingInt82Complex64FuncFactory func(observer Complex64Observer) MappingInt82Complex64Func

type MappingInt82Complex64Observable struct {
	parent Int8Observable
	mapper MappingInt82Complex64FuncFactory
}

func (f *MappingInt82Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82Complex64Observable(parent Int8Observable, mapper MappingInt82Complex64FuncFactory) Complex64Observable {
	return &MappingInt82Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82Complex64ObserveDirect(parent Int8Observable, mapper MappingInt82Complex64Func) Complex64Observable {
	return MapInt82Complex64Observable(parent, func(Complex64Observer) MappingInt82Complex64Func {
		return mapper
	})
}

func MapInt82Complex64ObserveNext(parent Int8Observable, mapper func(int8) complex64) Complex64Observable {
	return MapInt82Complex64Observable(parent, func(Complex64Observer) MappingInt82Complex64Func {
		return func(next int8, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Complex64 struct {
	parent Int8Observable
	mapper func(int8) Complex64Observable
}

func (f *flatMapInt82Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *Int8Stream) MapComplex64(f func(int8) complex64) *Complex64Stream {
	return FromComplex64Observable(MapInt82Complex64ObserveNext(s, f))
}

func (s *Int8Stream) FlatMapComplex64(f func(int8) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapInt82Complex64{s, f}}
}

type MappingInt82Complex128Func func(next int8, err error, complete bool, observer Complex128Observer)
type MappingInt82Complex128FuncFactory func(observer Complex128Observer) MappingInt82Complex128Func

type MappingInt82Complex128Observable struct {
	parent Int8Observable
	mapper MappingInt82Complex128FuncFactory
}

func (f *MappingInt82Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82Complex128Observable(parent Int8Observable, mapper MappingInt82Complex128FuncFactory) Complex128Observable {
	return &MappingInt82Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82Complex128ObserveDirect(parent Int8Observable, mapper MappingInt82Complex128Func) Complex128Observable {
	return MapInt82Complex128Observable(parent, func(Complex128Observer) MappingInt82Complex128Func {
		return mapper
	})
}

func MapInt82Complex128ObserveNext(parent Int8Observable, mapper func(int8) complex128) Complex128Observable {
	return MapInt82Complex128Observable(parent, func(Complex128Observer) MappingInt82Complex128Func {
		return func(next int8, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Complex128 struct {
	parent Int8Observable
	mapper func(int8) Complex128Observable
}

func (f *flatMapInt82Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *Int8Stream) MapComplex128(f func(int8) complex128) *Complex128Stream {
	return FromComplex128Observable(MapInt82Complex128ObserveNext(s, f))
}

func (s *Int8Stream) FlatMapComplex128(f func(int8) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapInt82Complex128{s, f}}
}

type MappingInt82TimeFunc func(next int8, err error, complete bool, observer TimeObserver)
type MappingInt82TimeFuncFactory func(observer TimeObserver) MappingInt82TimeFunc

type MappingInt82TimeObservable struct {
	parent Int8Observable
	mapper MappingInt82TimeFuncFactory
}

func (f *MappingInt82TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82TimeObservable(parent Int8Observable, mapper MappingInt82TimeFuncFactory) TimeObservable {
	return &MappingInt82TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82TimeObserveDirect(parent Int8Observable, mapper MappingInt82TimeFunc) TimeObservable {
	return MapInt82TimeObservable(parent, func(TimeObserver) MappingInt82TimeFunc {
		return mapper
	})
}

func MapInt82TimeObserveNext(parent Int8Observable, mapper func(int8) time.Time) TimeObservable {
	return MapInt82TimeObservable(parent, func(TimeObserver) MappingInt82TimeFunc {
		return func(next int8, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Time struct {
	parent Int8Observable
	mapper func(int8) TimeObservable
}

func (f *flatMapInt82Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *Int8Stream) MapTime(f func(int8) time.Time) *TimeStream {
	return FromTimeObservable(MapInt82TimeObserveNext(s, f))
}

func (s *Int8Stream) FlatMapTime(f func(int8) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapInt82Time{s, f}}
}

type MappingInt82DurationFunc func(next int8, err error, complete bool, observer DurationObserver)
type MappingInt82DurationFuncFactory func(observer DurationObserver) MappingInt82DurationFunc

type MappingInt82DurationObservable struct {
	parent Int8Observable
	mapper MappingInt82DurationFuncFactory
}

func (f *MappingInt82DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt82DurationObservable(parent Int8Observable, mapper MappingInt82DurationFuncFactory) DurationObservable {
	return &MappingInt82DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt82DurationObserveDirect(parent Int8Observable, mapper MappingInt82DurationFunc) DurationObservable {
	return MapInt82DurationObservable(parent, func(DurationObserver) MappingInt82DurationFunc {
		return mapper
	})
}

func MapInt82DurationObserveNext(parent Int8Observable, mapper func(int8) time.Duration) DurationObservable {
	return MapInt82DurationObservable(parent, func(DurationObserver) MappingInt82DurationFunc {
		return func(next int8, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt82Duration struct {
	parent Int8Observable
	mapper func(int8) DurationObservable
}

func (f *flatMapInt82Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int8ObserverFunc(func(next int8, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *Int8Stream) MapDuration(f func(int8) time.Duration) *DurationStream {
	return FromDurationObservable(MapInt82DurationObserveNext(s, f))
}

func (s *Int8Stream) FlatMapDuration(f func(int8) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapInt82Duration{s, f}}
}

type Uint16Observer interface {
	Next(uint16)
	TerminationObserver
}

// A Uint16Subscriber represents a subscribed Uint16Observer.
type Uint16Subscriber interface {
	Subscription
	Uint16Observer
}

type implUint16Subscriber struct {
	Subscription
	Uint16Observer
}

func Uint16ObserverAsGenericObserver(observer Uint16Observer) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(uint16))
		}
	})
}

func GenericObserverAsUint16Observer(observer GenericObserver) Uint16Observer {
	return Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type Uint16ObservableFactory func(observer Uint16Observer, subscription Subscription)

func (f Uint16ObservableFactory) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateUint16 calls f(observer, subscription) to produce values for a stream.
func CreateUint16(f func(observer Uint16Observer, subscription Subscription)) *Uint16Stream {
	return FromUint16Observable(Uint16ObservableFactory(f))
}

// Repeat value count times.
func RepeatUint16(value uint16, count int) *Uint16Stream {
	return CreateUint16(func(observer Uint16Observer, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartUint16 is designed to be used with functions that return a
// (uint16, error) tuple.
//
// If the error is non-nil the returned Uint16Stream will be that error,
// otherwise it will be a single-value stream of uint16.
func StartUint16(f func() (uint16, error)) *Uint16Stream {
	return CreateUint16(func(observer Uint16Observer, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughUint16(next uint16, err error, complete bool, observer Uint16Observer) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroUint16 = *new(uint16)

type Uint16ObserverFunc func(uint16, error, bool)

func (f Uint16ObserverFunc) Next(next uint16) { f(next, nil, false) }
func (f Uint16ObserverFunc) Error(err error)  { f(zeroUint16, err, false) }
func (f Uint16ObserverFunc) Complete()        { f(zeroUint16, nil, true) }

type Uint16Observable interface {
	Subscribe(Uint16Observer) Subscription
}

// Convert a GenericObservableFilter to a Uint16Observable
func (f GenericObservableFilterFactory) Uint16(parent Uint16Observable) Uint16Observable {
	return MapUint162Uint16Observable(parent, func(observer Uint16Observer) MappingUint162Uint16Func {
		gobserver := Uint16ObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next uint16, err error, complete bool, observer Uint16Observer) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverUint16() *Uint16Stream {
	return CreateUint16(func(observer Uint16Observer, subscription Subscription) {})
}

func EmptyUint16() *Uint16Stream {
	return CreateUint16(func(observer Uint16Observer, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowUint16(err error) *Uint16Stream {
	return CreateUint16(func(observer Uint16Observer, subscription Subscription) {
		observer.Error(err)
	})
}

func FromUint16Array(array []uint16) *Uint16Stream {
	return CreateUint16(func(observer Uint16Observer, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromUint16s(array ...uint16) *Uint16Stream {
	return FromUint16Array(array)
}

func JustUint16(element uint16) *Uint16Stream {
	return FromUint16Array([]uint16{element})
}

func MergeUint16(observables ...Uint16Observable) *Uint16Stream {
	if len(observables) == 0 {
		return EmptyUint16()
	}
	return (&Uint16Stream{observables[0]}).Merge(observables[1:]...)
}

func MergeUint16DelayError(observables ...Uint16Observable) *Uint16Stream {
	if len(observables) == 0 {
		return EmptyUint16()
	}
	return (&Uint16Stream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromUint16Channel(ch <-chan uint16) *Uint16Stream {
	return CreateUint16(func(observer Uint16Observer, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type Uint16Stream struct {
	Uint16Observable
}

func FromUint16Observable(observable Uint16Observable) *Uint16Stream {
	return &Uint16Stream{observable}
}

func (s *Uint16Stream) SubscribeFunc(f func(uint16, error, bool)) Subscription {
	return s.Subscribe(Uint16ObserverFunc(f))
}

func (s *Uint16Stream) SubscribeNext(f func(v uint16)) Subscription {
	return s.SubscribeFunc(func(next uint16, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *Uint16Stream) Distinct() *Uint16Stream {
	return FromUint16Observable(distinctFilter().Uint16(s))
}

// ElementAt yields the Nth element of the stream.
func (s *Uint16Stream) ElementAt(n int) *Uint16Stream {
	return FromUint16Observable(elementAtFilter(n).Uint16(s))
}

// Filter elements in the stream on a function.
func (s *Uint16Stream) Filter(f func(uint16) bool) *Uint16Stream {
	return FromUint16Observable(filterFilter(func(v interface{}) bool { return f(v.(uint16)) }).Uint16(s))
}

// Last returns just the first element of the stream.
func (s *Uint16Stream) First() *Uint16Stream {
	return FromUint16Observable(firstFilter().Uint16(s))
}

// Last returns just the last element of the stream.
func (s *Uint16Stream) Last() *Uint16Stream {
	return FromUint16Observable(lastFilter().Uint16(s))
}

// SkipLast skips the first N elements of the stream.
func (s *Uint16Stream) Skip(n int) *Uint16Stream {
	return FromUint16Observable(skipFilter(n).Uint16(s))
}

// SkipLast skips the last N elements of the stream.
func (s *Uint16Stream) SkipLast(n int) *Uint16Stream {
	return FromUint16Observable(skipLastFilter(n).Uint16(s))
}

// Take returns just the first N elements of the stream.
func (s *Uint16Stream) Take(n int) *Uint16Stream {
	return FromUint16Observable(takeFilter(n).Uint16(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *Uint16Stream) TakeLast(n int) *Uint16Stream {
	return FromUint16Observable(takeLastFilter(n).Uint16(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *Uint16Stream) IgnoreElements() *Uint16Stream {
	return FromUint16Observable(ignoreElementsFilter().Uint16(s))
}

func (s *Uint16Stream) Replay(size int, duration time.Duration) *Uint16Stream {
	return FromUint16Observable(replayFilter(size, duration).Uint16(s))
}

func (s *Uint16Stream) Sample(duration time.Duration) *Uint16Stream {
	return FromUint16Observable(sampleFilter(duration).Uint16(s))
}

func (s *Uint16Stream) Debounce(duration time.Duration) *Uint16Stream {
	return FromUint16Observable(debounceFilter(duration).Uint16(s))
}

// Wait for completion of the stream and return any error.
func (s *Uint16Stream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeUint16Subscriber(observer Uint16Observer) Uint16Subscriber {
	if subscriber, ok := observer.(Uint16Subscriber); ok {
		return subscriber
	}
	return &implUint16Subscriber{NewGenericSubscription(), observer}
}

type concatUint16Subscriber struct {
	observable  int
	observer    Uint16Observer
	observables []Uint16Observable
	Subscription
}

func (c *concatUint16Subscriber) Next(next uint16) {
	c.observer.Next(next)
}

func (c *concatUint16Subscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatUint16Subscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatUint16Observable struct {
	observables []Uint16Observable
}

func (m *concatUint16Observable) Subscribe(observer Uint16Observer) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatUint16Subscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *Uint16Stream) Concat(observables ...Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&concatUint16Observable{append([]Uint16Observable{s}, observables...)}}
}

type mergeUint16Observable struct {
	delayError  bool
	observables []Uint16Observable
}

func (m *mergeUint16Observable) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next uint16, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(Uint16ObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *Uint16Stream) Merge(other ...Uint16Observable) *Uint16Stream {
	if len(other) == 0 {
		return s
	}
	return &Uint16Stream{&mergeUint16Observable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *Uint16Stream) MergeDelayError(other ...Uint16Observable) *Uint16Stream {
	if len(other) == 0 {
		return s
	}
	return &Uint16Stream{&mergeUint16Observable{true, append(other, s)}}
}

type catchUint16Observable struct {
	parent Uint16Observable
	catch  Uint16Observable
}

func (r *catchUint16Observable) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	run := func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(Uint16ObserverFunc(run))
	return subscription
}

func (s *Uint16Stream) Catch(catch Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&catchUint16Observable{s, catch}}
}

type retryUint16Observable struct {
	observable Uint16Observable
}

type retryUint16Observer struct {
	observable Uint16Observable
	observer   Uint16Observer
}

func (r *retryUint16Observer) retry(next uint16, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(Uint16ObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryUint16Observable) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryUint16Observer{r.observable, observer}
	r.observable.Subscribe(Uint16ObserverFunc(ro.retry))
	return subscription
}

func (s *Uint16Stream) Retry() *Uint16Stream {
	return &Uint16Stream{&retryUint16Observable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *Uint16Stream) Do(f func(next uint16)) *Uint16Stream {
	return FromUint16Observable(MapUint162Uint16ObserveNext(s, func(next uint16) uint16 {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *Uint16Stream) DoOnError(f func(err error)) *Uint16Stream {
	return FromUint16Observable(MapUint162Uint16ObserveDirect(s, func(next uint16, err error, complete bool, observer Uint16Observer) {
		if err != nil {
			f(err)
		}
		PassthroughUint16(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *Uint16Stream) DoOnComplete(f func()) *Uint16Stream {
	return FromUint16Observable(MapUint162Uint16ObserveDirect(s, func(next uint16, err error, complete bool, observer Uint16Observer) {
		if complete {
			f()
		}
		PassthroughUint16(next, err, complete, observer)
	}))
}

func (s *Uint16Stream) Reduce(initial uint16, reducer func(uint16, uint16) uint16) *Uint16Stream {
	value := initial
	return FromUint16Observable(MapUint162Uint16ObserveDirect(s, func(next uint16, err error, complete bool, observer Uint16Observer) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *Uint16Stream) Scan(initial uint16, f func(uint16, uint16) uint16) *Uint16Stream {
	value := initial
	return FromUint16Observable(MapUint162Uint16ObserveDirect(s, func(next uint16, err error, complete bool, observer Uint16Observer) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutUint16 struct {
	parent  Uint16Observable
	timeout time.Duration
}

func (t *timeoutUint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *Uint16Stream) Timeout(timeout time.Duration) *Uint16Stream {
	return &Uint16Stream{&timeoutUint16{s, timeout}}
}

type forkedUint16Stream struct {
	lock      sync.Mutex
	parent    Uint16Observable
	observers []Uint16Observer
}

func (f *forkedUint16Stream) Subscribe(observer Uint16Observer) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *Uint16Stream) Fork() *Uint16Stream {
	f := &forkedUint16Stream{parent: s}
	go s.Subscribe(Uint16ObserverFunc(func(n uint16, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &Uint16Stream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *Uint16Stream) ToOneWithError() (uint16, error) {
	valuech := make(chan uint16, 1)
	errch := make(chan error, 1)
	FromUint16Observable(oneFilter().Uint16(s)).SubscribeFunc(func(next uint16, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroUint16, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *Uint16Stream) ToOne() uint16 {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *Uint16Stream) ToArrayWithError() ([]uint16, error) {
	array := []uint16{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *Uint16Stream) ToArray() []uint16 {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *Uint16Stream) ToChannelWithError() (<-chan uint16, <-chan error) {
	ch := make(chan uint16, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *Uint16Stream) ToChannel() <-chan uint16 {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *Uint16Stream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapUint162IntObserveDirect(s, func(next uint16, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

func (s *Uint16Stream) Average() *Uint16Stream {
	var sum uint16
	var count uint16
	return FromUint16Observable(MapUint162Uint16ObserveDirect(s, func(next uint16, err error, complete bool, observer Uint16Observer) {
		switch {
		case err != nil:
			observer.Next(sum / count)
			observer.Error(err)
		case complete:
			observer.Next(sum / count)
			observer.Complete()
		default:
			sum += next
			count++
		}
	}))
}

func (s *Uint16Stream) Sum() *Uint16Stream {
	var sum uint16
	return FromUint16Observable(MapUint162Uint16ObserveDirect(s, func(next uint16, err error, complete bool, observer Uint16Observer) {
		switch {
		case err != nil:
			observer.Next(sum)
			observer.Error(err)
		case complete:
			observer.Next(sum)
			observer.Complete()
		default:
			sum += next
		}
	}))
}

func (s *Uint16Stream) Min() *Uint16Stream {
	started := false
	var min uint16
	return FromUint16Observable(MapUint162Uint16ObserveDirect(s, func(next uint16, err error, complete bool, observer Uint16Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(min)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(min)
			}
			observer.Complete()
		default:
			if started {
				if min > next {
					min = next
				}
			} else {
				min = next
				started = true
			}
		}
	}))
}

func (s *Uint16Stream) Max() *Uint16Stream {
	started := false
	var max uint16
	return FromUint16Observable(MapUint162Uint16ObserveDirect(s, func(next uint16, err error, complete bool, observer Uint16Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(max)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(max)
			}
			observer.Complete()
		default:
			if started {
				if max <= next {
					max = next
				}
			} else {
				max = next
				started = true
			}
		}
	}))
}

type MappingUint162BoolFunc func(next uint16, err error, complete bool, observer BoolObserver)
type MappingUint162BoolFuncFactory func(observer BoolObserver) MappingUint162BoolFunc

type MappingUint162BoolObservable struct {
	parent Uint16Observable
	mapper MappingUint162BoolFuncFactory
}

func (f *MappingUint162BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162BoolObservable(parent Uint16Observable, mapper MappingUint162BoolFuncFactory) BoolObservable {
	return &MappingUint162BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162BoolObserveDirect(parent Uint16Observable, mapper MappingUint162BoolFunc) BoolObservable {
	return MapUint162BoolObservable(parent, func(BoolObserver) MappingUint162BoolFunc {
		return mapper
	})
}

func MapUint162BoolObserveNext(parent Uint16Observable, mapper func(uint16) bool) BoolObservable {
	return MapUint162BoolObservable(parent, func(BoolObserver) MappingUint162BoolFunc {
		return func(next uint16, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Bool struct {
	parent Uint16Observable
	mapper func(uint16) BoolObservable
}

func (f *flatMapUint162Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *Uint16Stream) MapBool(f func(uint16) bool) *BoolStream {
	return FromBoolObservable(MapUint162BoolObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapBool(f func(uint16) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapUint162Bool{s, f}}
}

type MappingUint162RuneFunc func(next uint16, err error, complete bool, observer RuneObserver)
type MappingUint162RuneFuncFactory func(observer RuneObserver) MappingUint162RuneFunc

type MappingUint162RuneObservable struct {
	parent Uint16Observable
	mapper MappingUint162RuneFuncFactory
}

func (f *MappingUint162RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162RuneObservable(parent Uint16Observable, mapper MappingUint162RuneFuncFactory) RuneObservable {
	return &MappingUint162RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162RuneObserveDirect(parent Uint16Observable, mapper MappingUint162RuneFunc) RuneObservable {
	return MapUint162RuneObservable(parent, func(RuneObserver) MappingUint162RuneFunc {
		return mapper
	})
}

func MapUint162RuneObserveNext(parent Uint16Observable, mapper func(uint16) rune) RuneObservable {
	return MapUint162RuneObservable(parent, func(RuneObserver) MappingUint162RuneFunc {
		return func(next uint16, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Rune struct {
	parent Uint16Observable
	mapper func(uint16) RuneObservable
}

func (f *flatMapUint162Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *Uint16Stream) MapRune(f func(uint16) rune) *RuneStream {
	return FromRuneObservable(MapUint162RuneObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapRune(f func(uint16) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapUint162Rune{s, f}}
}

type MappingUint162ByteFunc func(next uint16, err error, complete bool, observer ByteObserver)
type MappingUint162ByteFuncFactory func(observer ByteObserver) MappingUint162ByteFunc

type MappingUint162ByteObservable struct {
	parent Uint16Observable
	mapper MappingUint162ByteFuncFactory
}

func (f *MappingUint162ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162ByteObservable(parent Uint16Observable, mapper MappingUint162ByteFuncFactory) ByteObservable {
	return &MappingUint162ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162ByteObserveDirect(parent Uint16Observable, mapper MappingUint162ByteFunc) ByteObservable {
	return MapUint162ByteObservable(parent, func(ByteObserver) MappingUint162ByteFunc {
		return mapper
	})
}

func MapUint162ByteObserveNext(parent Uint16Observable, mapper func(uint16) byte) ByteObservable {
	return MapUint162ByteObservable(parent, func(ByteObserver) MappingUint162ByteFunc {
		return func(next uint16, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Byte struct {
	parent Uint16Observable
	mapper func(uint16) ByteObservable
}

func (f *flatMapUint162Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *Uint16Stream) MapByte(f func(uint16) byte) *ByteStream {
	return FromByteObservable(MapUint162ByteObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapByte(f func(uint16) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapUint162Byte{s, f}}
}

type MappingUint162StringFunc func(next uint16, err error, complete bool, observer StringObserver)
type MappingUint162StringFuncFactory func(observer StringObserver) MappingUint162StringFunc

type MappingUint162StringObservable struct {
	parent Uint16Observable
	mapper MappingUint162StringFuncFactory
}

func (f *MappingUint162StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162StringObservable(parent Uint16Observable, mapper MappingUint162StringFuncFactory) StringObservable {
	return &MappingUint162StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162StringObserveDirect(parent Uint16Observable, mapper MappingUint162StringFunc) StringObservable {
	return MapUint162StringObservable(parent, func(StringObserver) MappingUint162StringFunc {
		return mapper
	})
}

func MapUint162StringObserveNext(parent Uint16Observable, mapper func(uint16) string) StringObservable {
	return MapUint162StringObservable(parent, func(StringObserver) MappingUint162StringFunc {
		return func(next uint16, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162String struct {
	parent Uint16Observable
	mapper func(uint16) StringObservable
}

func (f *flatMapUint162String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *Uint16Stream) MapString(f func(uint16) string) *StringStream {
	return FromStringObservable(MapUint162StringObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapString(f func(uint16) StringObservable) *StringStream {
	return &StringStream{&flatMapUint162String{s, f}}
}

type MappingUint162UintFunc func(next uint16, err error, complete bool, observer UintObserver)
type MappingUint162UintFuncFactory func(observer UintObserver) MappingUint162UintFunc

type MappingUint162UintObservable struct {
	parent Uint16Observable
	mapper MappingUint162UintFuncFactory
}

func (f *MappingUint162UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162UintObservable(parent Uint16Observable, mapper MappingUint162UintFuncFactory) UintObservable {
	return &MappingUint162UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162UintObserveDirect(parent Uint16Observable, mapper MappingUint162UintFunc) UintObservable {
	return MapUint162UintObservable(parent, func(UintObserver) MappingUint162UintFunc {
		return mapper
	})
}

func MapUint162UintObserveNext(parent Uint16Observable, mapper func(uint16) uint) UintObservable {
	return MapUint162UintObservable(parent, func(UintObserver) MappingUint162UintFunc {
		return func(next uint16, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Uint struct {
	parent Uint16Observable
	mapper func(uint16) UintObservable
}

func (f *flatMapUint162Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *Uint16Stream) MapUint(f func(uint16) uint) *UintStream {
	return FromUintObservable(MapUint162UintObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapUint(f func(uint16) UintObservable) *UintStream {
	return &UintStream{&flatMapUint162Uint{s, f}}
}

type MappingUint162IntFunc func(next uint16, err error, complete bool, observer IntObserver)
type MappingUint162IntFuncFactory func(observer IntObserver) MappingUint162IntFunc

type MappingUint162IntObservable struct {
	parent Uint16Observable
	mapper MappingUint162IntFuncFactory
}

func (f *MappingUint162IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162IntObservable(parent Uint16Observable, mapper MappingUint162IntFuncFactory) IntObservable {
	return &MappingUint162IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162IntObserveDirect(parent Uint16Observable, mapper MappingUint162IntFunc) IntObservable {
	return MapUint162IntObservable(parent, func(IntObserver) MappingUint162IntFunc {
		return mapper
	})
}

func MapUint162IntObserveNext(parent Uint16Observable, mapper func(uint16) int) IntObservable {
	return MapUint162IntObservable(parent, func(IntObserver) MappingUint162IntFunc {
		return func(next uint16, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Int struct {
	parent Uint16Observable
	mapper func(uint16) IntObservable
}

func (f *flatMapUint162Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *Uint16Stream) MapInt(f func(uint16) int) *IntStream {
	return FromIntObservable(MapUint162IntObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapInt(f func(uint16) IntObservable) *IntStream {
	return &IntStream{&flatMapUint162Int{s, f}}
}

type MappingUint162Uint8Func func(next uint16, err error, complete bool, observer Uint8Observer)
type MappingUint162Uint8FuncFactory func(observer Uint8Observer) MappingUint162Uint8Func

type MappingUint162Uint8Observable struct {
	parent Uint16Observable
	mapper MappingUint162Uint8FuncFactory
}

func (f *MappingUint162Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162Uint8Observable(parent Uint16Observable, mapper MappingUint162Uint8FuncFactory) Uint8Observable {
	return &MappingUint162Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162Uint8ObserveDirect(parent Uint16Observable, mapper MappingUint162Uint8Func) Uint8Observable {
	return MapUint162Uint8Observable(parent, func(Uint8Observer) MappingUint162Uint8Func {
		return mapper
	})
}

func MapUint162Uint8ObserveNext(parent Uint16Observable, mapper func(uint16) uint8) Uint8Observable {
	return MapUint162Uint8Observable(parent, func(Uint8Observer) MappingUint162Uint8Func {
		return func(next uint16, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Uint8 struct {
	parent Uint16Observable
	mapper func(uint16) Uint8Observable
}

func (f *flatMapUint162Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *Uint16Stream) MapUint8(f func(uint16) uint8) *Uint8Stream {
	return FromUint8Observable(MapUint162Uint8ObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapUint8(f func(uint16) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapUint162Uint8{s, f}}
}

type MappingUint162Int8Func func(next uint16, err error, complete bool, observer Int8Observer)
type MappingUint162Int8FuncFactory func(observer Int8Observer) MappingUint162Int8Func

type MappingUint162Int8Observable struct {
	parent Uint16Observable
	mapper MappingUint162Int8FuncFactory
}

func (f *MappingUint162Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162Int8Observable(parent Uint16Observable, mapper MappingUint162Int8FuncFactory) Int8Observable {
	return &MappingUint162Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162Int8ObserveDirect(parent Uint16Observable, mapper MappingUint162Int8Func) Int8Observable {
	return MapUint162Int8Observable(parent, func(Int8Observer) MappingUint162Int8Func {
		return mapper
	})
}

func MapUint162Int8ObserveNext(parent Uint16Observable, mapper func(uint16) int8) Int8Observable {
	return MapUint162Int8Observable(parent, func(Int8Observer) MappingUint162Int8Func {
		return func(next uint16, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Int8 struct {
	parent Uint16Observable
	mapper func(uint16) Int8Observable
}

func (f *flatMapUint162Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *Uint16Stream) MapInt8(f func(uint16) int8) *Int8Stream {
	return FromInt8Observable(MapUint162Int8ObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapInt8(f func(uint16) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapUint162Int8{s, f}}
}

type MappingUint162Uint16Func func(next uint16, err error, complete bool, observer Uint16Observer)
type MappingUint162Uint16FuncFactory func(observer Uint16Observer) MappingUint162Uint16Func

type MappingUint162Uint16Observable struct {
	parent Uint16Observable
	mapper MappingUint162Uint16FuncFactory
}

func (f *MappingUint162Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162Uint16Observable(parent Uint16Observable, mapper MappingUint162Uint16FuncFactory) Uint16Observable {
	return &MappingUint162Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162Uint16ObserveDirect(parent Uint16Observable, mapper MappingUint162Uint16Func) Uint16Observable {
	return MapUint162Uint16Observable(parent, func(Uint16Observer) MappingUint162Uint16Func {
		return mapper
	})
}

func MapUint162Uint16ObserveNext(parent Uint16Observable, mapper func(uint16) uint16) Uint16Observable {
	return MapUint162Uint16Observable(parent, func(Uint16Observer) MappingUint162Uint16Func {
		return func(next uint16, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Uint16 struct {
	parent Uint16Observable
	mapper func(uint16) Uint16Observable
}

func (f *flatMapUint162Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *Uint16Stream) Map(f func(uint16) uint16) *Uint16Stream {
	return FromUint16Observable(MapUint162Uint16ObserveNext(s, f))
}

func (s *Uint16Stream) FlatMap(f func(uint16) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapUint162Uint16{s, f}}
}

type MappingUint162Int16Func func(next uint16, err error, complete bool, observer Int16Observer)
type MappingUint162Int16FuncFactory func(observer Int16Observer) MappingUint162Int16Func

type MappingUint162Int16Observable struct {
	parent Uint16Observable
	mapper MappingUint162Int16FuncFactory
}

func (f *MappingUint162Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162Int16Observable(parent Uint16Observable, mapper MappingUint162Int16FuncFactory) Int16Observable {
	return &MappingUint162Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162Int16ObserveDirect(parent Uint16Observable, mapper MappingUint162Int16Func) Int16Observable {
	return MapUint162Int16Observable(parent, func(Int16Observer) MappingUint162Int16Func {
		return mapper
	})
}

func MapUint162Int16ObserveNext(parent Uint16Observable, mapper func(uint16) int16) Int16Observable {
	return MapUint162Int16Observable(parent, func(Int16Observer) MappingUint162Int16Func {
		return func(next uint16, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Int16 struct {
	parent Uint16Observable
	mapper func(uint16) Int16Observable
}

func (f *flatMapUint162Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *Uint16Stream) MapInt16(f func(uint16) int16) *Int16Stream {
	return FromInt16Observable(MapUint162Int16ObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapInt16(f func(uint16) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapUint162Int16{s, f}}
}

type MappingUint162Uint32Func func(next uint16, err error, complete bool, observer Uint32Observer)
type MappingUint162Uint32FuncFactory func(observer Uint32Observer) MappingUint162Uint32Func

type MappingUint162Uint32Observable struct {
	parent Uint16Observable
	mapper MappingUint162Uint32FuncFactory
}

func (f *MappingUint162Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162Uint32Observable(parent Uint16Observable, mapper MappingUint162Uint32FuncFactory) Uint32Observable {
	return &MappingUint162Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162Uint32ObserveDirect(parent Uint16Observable, mapper MappingUint162Uint32Func) Uint32Observable {
	return MapUint162Uint32Observable(parent, func(Uint32Observer) MappingUint162Uint32Func {
		return mapper
	})
}

func MapUint162Uint32ObserveNext(parent Uint16Observable, mapper func(uint16) uint32) Uint32Observable {
	return MapUint162Uint32Observable(parent, func(Uint32Observer) MappingUint162Uint32Func {
		return func(next uint16, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Uint32 struct {
	parent Uint16Observable
	mapper func(uint16) Uint32Observable
}

func (f *flatMapUint162Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *Uint16Stream) MapUint32(f func(uint16) uint32) *Uint32Stream {
	return FromUint32Observable(MapUint162Uint32ObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapUint32(f func(uint16) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapUint162Uint32{s, f}}
}

type MappingUint162Int32Func func(next uint16, err error, complete bool, observer Int32Observer)
type MappingUint162Int32FuncFactory func(observer Int32Observer) MappingUint162Int32Func

type MappingUint162Int32Observable struct {
	parent Uint16Observable
	mapper MappingUint162Int32FuncFactory
}

func (f *MappingUint162Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162Int32Observable(parent Uint16Observable, mapper MappingUint162Int32FuncFactory) Int32Observable {
	return &MappingUint162Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162Int32ObserveDirect(parent Uint16Observable, mapper MappingUint162Int32Func) Int32Observable {
	return MapUint162Int32Observable(parent, func(Int32Observer) MappingUint162Int32Func {
		return mapper
	})
}

func MapUint162Int32ObserveNext(parent Uint16Observable, mapper func(uint16) int32) Int32Observable {
	return MapUint162Int32Observable(parent, func(Int32Observer) MappingUint162Int32Func {
		return func(next uint16, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Int32 struct {
	parent Uint16Observable
	mapper func(uint16) Int32Observable
}

func (f *flatMapUint162Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *Uint16Stream) MapInt32(f func(uint16) int32) *Int32Stream {
	return FromInt32Observable(MapUint162Int32ObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapInt32(f func(uint16) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapUint162Int32{s, f}}
}

type MappingUint162Uint64Func func(next uint16, err error, complete bool, observer Uint64Observer)
type MappingUint162Uint64FuncFactory func(observer Uint64Observer) MappingUint162Uint64Func

type MappingUint162Uint64Observable struct {
	parent Uint16Observable
	mapper MappingUint162Uint64FuncFactory
}

func (f *MappingUint162Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162Uint64Observable(parent Uint16Observable, mapper MappingUint162Uint64FuncFactory) Uint64Observable {
	return &MappingUint162Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162Uint64ObserveDirect(parent Uint16Observable, mapper MappingUint162Uint64Func) Uint64Observable {
	return MapUint162Uint64Observable(parent, func(Uint64Observer) MappingUint162Uint64Func {
		return mapper
	})
}

func MapUint162Uint64ObserveNext(parent Uint16Observable, mapper func(uint16) uint64) Uint64Observable {
	return MapUint162Uint64Observable(parent, func(Uint64Observer) MappingUint162Uint64Func {
		return func(next uint16, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Uint64 struct {
	parent Uint16Observable
	mapper func(uint16) Uint64Observable
}

func (f *flatMapUint162Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *Uint16Stream) MapUint64(f func(uint16) uint64) *Uint64Stream {
	return FromUint64Observable(MapUint162Uint64ObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapUint64(f func(uint16) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapUint162Uint64{s, f}}
}

type MappingUint162Int64Func func(next uint16, err error, complete bool, observer Int64Observer)
type MappingUint162Int64FuncFactory func(observer Int64Observer) MappingUint162Int64Func

type MappingUint162Int64Observable struct {
	parent Uint16Observable
	mapper MappingUint162Int64FuncFactory
}

func (f *MappingUint162Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162Int64Observable(parent Uint16Observable, mapper MappingUint162Int64FuncFactory) Int64Observable {
	return &MappingUint162Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162Int64ObserveDirect(parent Uint16Observable, mapper MappingUint162Int64Func) Int64Observable {
	return MapUint162Int64Observable(parent, func(Int64Observer) MappingUint162Int64Func {
		return mapper
	})
}

func MapUint162Int64ObserveNext(parent Uint16Observable, mapper func(uint16) int64) Int64Observable {
	return MapUint162Int64Observable(parent, func(Int64Observer) MappingUint162Int64Func {
		return func(next uint16, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Int64 struct {
	parent Uint16Observable
	mapper func(uint16) Int64Observable
}

func (f *flatMapUint162Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *Uint16Stream) MapInt64(f func(uint16) int64) *Int64Stream {
	return FromInt64Observable(MapUint162Int64ObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapInt64(f func(uint16) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapUint162Int64{s, f}}
}

type MappingUint162Float32Func func(next uint16, err error, complete bool, observer Float32Observer)
type MappingUint162Float32FuncFactory func(observer Float32Observer) MappingUint162Float32Func

type MappingUint162Float32Observable struct {
	parent Uint16Observable
	mapper MappingUint162Float32FuncFactory
}

func (f *MappingUint162Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162Float32Observable(parent Uint16Observable, mapper MappingUint162Float32FuncFactory) Float32Observable {
	return &MappingUint162Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162Float32ObserveDirect(parent Uint16Observable, mapper MappingUint162Float32Func) Float32Observable {
	return MapUint162Float32Observable(parent, func(Float32Observer) MappingUint162Float32Func {
		return mapper
	})
}

func MapUint162Float32ObserveNext(parent Uint16Observable, mapper func(uint16) float32) Float32Observable {
	return MapUint162Float32Observable(parent, func(Float32Observer) MappingUint162Float32Func {
		return func(next uint16, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Float32 struct {
	parent Uint16Observable
	mapper func(uint16) Float32Observable
}

func (f *flatMapUint162Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *Uint16Stream) MapFloat32(f func(uint16) float32) *Float32Stream {
	return FromFloat32Observable(MapUint162Float32ObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapFloat32(f func(uint16) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapUint162Float32{s, f}}
}

type MappingUint162Float64Func func(next uint16, err error, complete bool, observer Float64Observer)
type MappingUint162Float64FuncFactory func(observer Float64Observer) MappingUint162Float64Func

type MappingUint162Float64Observable struct {
	parent Uint16Observable
	mapper MappingUint162Float64FuncFactory
}

func (f *MappingUint162Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162Float64Observable(parent Uint16Observable, mapper MappingUint162Float64FuncFactory) Float64Observable {
	return &MappingUint162Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162Float64ObserveDirect(parent Uint16Observable, mapper MappingUint162Float64Func) Float64Observable {
	return MapUint162Float64Observable(parent, func(Float64Observer) MappingUint162Float64Func {
		return mapper
	})
}

func MapUint162Float64ObserveNext(parent Uint16Observable, mapper func(uint16) float64) Float64Observable {
	return MapUint162Float64Observable(parent, func(Float64Observer) MappingUint162Float64Func {
		return func(next uint16, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Float64 struct {
	parent Uint16Observable
	mapper func(uint16) Float64Observable
}

func (f *flatMapUint162Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *Uint16Stream) MapFloat64(f func(uint16) float64) *Float64Stream {
	return FromFloat64Observable(MapUint162Float64ObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapFloat64(f func(uint16) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapUint162Float64{s, f}}
}

type MappingUint162Complex64Func func(next uint16, err error, complete bool, observer Complex64Observer)
type MappingUint162Complex64FuncFactory func(observer Complex64Observer) MappingUint162Complex64Func

type MappingUint162Complex64Observable struct {
	parent Uint16Observable
	mapper MappingUint162Complex64FuncFactory
}

func (f *MappingUint162Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162Complex64Observable(parent Uint16Observable, mapper MappingUint162Complex64FuncFactory) Complex64Observable {
	return &MappingUint162Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162Complex64ObserveDirect(parent Uint16Observable, mapper MappingUint162Complex64Func) Complex64Observable {
	return MapUint162Complex64Observable(parent, func(Complex64Observer) MappingUint162Complex64Func {
		return mapper
	})
}

func MapUint162Complex64ObserveNext(parent Uint16Observable, mapper func(uint16) complex64) Complex64Observable {
	return MapUint162Complex64Observable(parent, func(Complex64Observer) MappingUint162Complex64Func {
		return func(next uint16, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Complex64 struct {
	parent Uint16Observable
	mapper func(uint16) Complex64Observable
}

func (f *flatMapUint162Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *Uint16Stream) MapComplex64(f func(uint16) complex64) *Complex64Stream {
	return FromComplex64Observable(MapUint162Complex64ObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapComplex64(f func(uint16) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapUint162Complex64{s, f}}
}

type MappingUint162Complex128Func func(next uint16, err error, complete bool, observer Complex128Observer)
type MappingUint162Complex128FuncFactory func(observer Complex128Observer) MappingUint162Complex128Func

type MappingUint162Complex128Observable struct {
	parent Uint16Observable
	mapper MappingUint162Complex128FuncFactory
}

func (f *MappingUint162Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162Complex128Observable(parent Uint16Observable, mapper MappingUint162Complex128FuncFactory) Complex128Observable {
	return &MappingUint162Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162Complex128ObserveDirect(parent Uint16Observable, mapper MappingUint162Complex128Func) Complex128Observable {
	return MapUint162Complex128Observable(parent, func(Complex128Observer) MappingUint162Complex128Func {
		return mapper
	})
}

func MapUint162Complex128ObserveNext(parent Uint16Observable, mapper func(uint16) complex128) Complex128Observable {
	return MapUint162Complex128Observable(parent, func(Complex128Observer) MappingUint162Complex128Func {
		return func(next uint16, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Complex128 struct {
	parent Uint16Observable
	mapper func(uint16) Complex128Observable
}

func (f *flatMapUint162Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *Uint16Stream) MapComplex128(f func(uint16) complex128) *Complex128Stream {
	return FromComplex128Observable(MapUint162Complex128ObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapComplex128(f func(uint16) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapUint162Complex128{s, f}}
}

type MappingUint162TimeFunc func(next uint16, err error, complete bool, observer TimeObserver)
type MappingUint162TimeFuncFactory func(observer TimeObserver) MappingUint162TimeFunc

type MappingUint162TimeObservable struct {
	parent Uint16Observable
	mapper MappingUint162TimeFuncFactory
}

func (f *MappingUint162TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162TimeObservable(parent Uint16Observable, mapper MappingUint162TimeFuncFactory) TimeObservable {
	return &MappingUint162TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162TimeObserveDirect(parent Uint16Observable, mapper MappingUint162TimeFunc) TimeObservable {
	return MapUint162TimeObservable(parent, func(TimeObserver) MappingUint162TimeFunc {
		return mapper
	})
}

func MapUint162TimeObserveNext(parent Uint16Observable, mapper func(uint16) time.Time) TimeObservable {
	return MapUint162TimeObservable(parent, func(TimeObserver) MappingUint162TimeFunc {
		return func(next uint16, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Time struct {
	parent Uint16Observable
	mapper func(uint16) TimeObservable
}

func (f *flatMapUint162Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *Uint16Stream) MapTime(f func(uint16) time.Time) *TimeStream {
	return FromTimeObservable(MapUint162TimeObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapTime(f func(uint16) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapUint162Time{s, f}}
}

type MappingUint162DurationFunc func(next uint16, err error, complete bool, observer DurationObserver)
type MappingUint162DurationFuncFactory func(observer DurationObserver) MappingUint162DurationFunc

type MappingUint162DurationObservable struct {
	parent Uint16Observable
	mapper MappingUint162DurationFuncFactory
}

func (f *MappingUint162DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint162DurationObservable(parent Uint16Observable, mapper MappingUint162DurationFuncFactory) DurationObservable {
	return &MappingUint162DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint162DurationObserveDirect(parent Uint16Observable, mapper MappingUint162DurationFunc) DurationObservable {
	return MapUint162DurationObservable(parent, func(DurationObserver) MappingUint162DurationFunc {
		return mapper
	})
}

func MapUint162DurationObserveNext(parent Uint16Observable, mapper func(uint16) time.Duration) DurationObservable {
	return MapUint162DurationObservable(parent, func(DurationObserver) MappingUint162DurationFunc {
		return func(next uint16, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint162Duration struct {
	parent Uint16Observable
	mapper func(uint16) DurationObservable
}

func (f *flatMapUint162Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint16ObserverFunc(func(next uint16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *Uint16Stream) MapDuration(f func(uint16) time.Duration) *DurationStream {
	return FromDurationObservable(MapUint162DurationObserveNext(s, f))
}

func (s *Uint16Stream) FlatMapDuration(f func(uint16) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapUint162Duration{s, f}}
}

type Int16Observer interface {
	Next(int16)
	TerminationObserver
}

// A Int16Subscriber represents a subscribed Int16Observer.
type Int16Subscriber interface {
	Subscription
	Int16Observer
}

type implInt16Subscriber struct {
	Subscription
	Int16Observer
}

func Int16ObserverAsGenericObserver(observer Int16Observer) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(int16))
		}
	})
}

func GenericObserverAsInt16Observer(observer GenericObserver) Int16Observer {
	return Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type Int16ObservableFactory func(observer Int16Observer, subscription Subscription)

func (f Int16ObservableFactory) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateInt16 calls f(observer, subscription) to produce values for a stream.
func CreateInt16(f func(observer Int16Observer, subscription Subscription)) *Int16Stream {
	return FromInt16Observable(Int16ObservableFactory(f))
}

// Repeat value count times.
func RepeatInt16(value int16, count int) *Int16Stream {
	return CreateInt16(func(observer Int16Observer, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartInt16 is designed to be used with functions that return a
// (int16, error) tuple.
//
// If the error is non-nil the returned Int16Stream will be that error,
// otherwise it will be a single-value stream of int16.
func StartInt16(f func() (int16, error)) *Int16Stream {
	return CreateInt16(func(observer Int16Observer, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughInt16(next int16, err error, complete bool, observer Int16Observer) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroInt16 = *new(int16)

type Int16ObserverFunc func(int16, error, bool)

func (f Int16ObserverFunc) Next(next int16) { f(next, nil, false) }
func (f Int16ObserverFunc) Error(err error) { f(zeroInt16, err, false) }
func (f Int16ObserverFunc) Complete()       { f(zeroInt16, nil, true) }

type Int16Observable interface {
	Subscribe(Int16Observer) Subscription
}

// Convert a GenericObservableFilter to a Int16Observable
func (f GenericObservableFilterFactory) Int16(parent Int16Observable) Int16Observable {
	return MapInt162Int16Observable(parent, func(observer Int16Observer) MappingInt162Int16Func {
		gobserver := Int16ObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next int16, err error, complete bool, observer Int16Observer) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverInt16() *Int16Stream {
	return CreateInt16(func(observer Int16Observer, subscription Subscription) {})
}

func EmptyInt16() *Int16Stream {
	return CreateInt16(func(observer Int16Observer, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowInt16(err error) *Int16Stream {
	return CreateInt16(func(observer Int16Observer, subscription Subscription) {
		observer.Error(err)
	})
}

func FromInt16Array(array []int16) *Int16Stream {
	return CreateInt16(func(observer Int16Observer, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromInt16s(array ...int16) *Int16Stream {
	return FromInt16Array(array)
}

func JustInt16(element int16) *Int16Stream {
	return FromInt16Array([]int16{element})
}

func MergeInt16(observables ...Int16Observable) *Int16Stream {
	if len(observables) == 0 {
		return EmptyInt16()
	}
	return (&Int16Stream{observables[0]}).Merge(observables[1:]...)
}

func MergeInt16DelayError(observables ...Int16Observable) *Int16Stream {
	if len(observables) == 0 {
		return EmptyInt16()
	}
	return (&Int16Stream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromInt16Channel(ch <-chan int16) *Int16Stream {
	return CreateInt16(func(observer Int16Observer, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type Int16Stream struct {
	Int16Observable
}

func FromInt16Observable(observable Int16Observable) *Int16Stream {
	return &Int16Stream{observable}
}

func (s *Int16Stream) SubscribeFunc(f func(int16, error, bool)) Subscription {
	return s.Subscribe(Int16ObserverFunc(f))
}

func (s *Int16Stream) SubscribeNext(f func(v int16)) Subscription {
	return s.SubscribeFunc(func(next int16, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *Int16Stream) Distinct() *Int16Stream {
	return FromInt16Observable(distinctFilter().Int16(s))
}

// ElementAt yields the Nth element of the stream.
func (s *Int16Stream) ElementAt(n int) *Int16Stream {
	return FromInt16Observable(elementAtFilter(n).Int16(s))
}

// Filter elements in the stream on a function.
func (s *Int16Stream) Filter(f func(int16) bool) *Int16Stream {
	return FromInt16Observable(filterFilter(func(v interface{}) bool { return f(v.(int16)) }).Int16(s))
}

// Last returns just the first element of the stream.
func (s *Int16Stream) First() *Int16Stream {
	return FromInt16Observable(firstFilter().Int16(s))
}

// Last returns just the last element of the stream.
func (s *Int16Stream) Last() *Int16Stream {
	return FromInt16Observable(lastFilter().Int16(s))
}

// SkipLast skips the first N elements of the stream.
func (s *Int16Stream) Skip(n int) *Int16Stream {
	return FromInt16Observable(skipFilter(n).Int16(s))
}

// SkipLast skips the last N elements of the stream.
func (s *Int16Stream) SkipLast(n int) *Int16Stream {
	return FromInt16Observable(skipLastFilter(n).Int16(s))
}

// Take returns just the first N elements of the stream.
func (s *Int16Stream) Take(n int) *Int16Stream {
	return FromInt16Observable(takeFilter(n).Int16(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *Int16Stream) TakeLast(n int) *Int16Stream {
	return FromInt16Observable(takeLastFilter(n).Int16(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *Int16Stream) IgnoreElements() *Int16Stream {
	return FromInt16Observable(ignoreElementsFilter().Int16(s))
}

func (s *Int16Stream) Replay(size int, duration time.Duration) *Int16Stream {
	return FromInt16Observable(replayFilter(size, duration).Int16(s))
}

func (s *Int16Stream) Sample(duration time.Duration) *Int16Stream {
	return FromInt16Observable(sampleFilter(duration).Int16(s))
}

func (s *Int16Stream) Debounce(duration time.Duration) *Int16Stream {
	return FromInt16Observable(debounceFilter(duration).Int16(s))
}

// Wait for completion of the stream and return any error.
func (s *Int16Stream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeInt16Subscriber(observer Int16Observer) Int16Subscriber {
	if subscriber, ok := observer.(Int16Subscriber); ok {
		return subscriber
	}
	return &implInt16Subscriber{NewGenericSubscription(), observer}
}

type concatInt16Subscriber struct {
	observable  int
	observer    Int16Observer
	observables []Int16Observable
	Subscription
}

func (c *concatInt16Subscriber) Next(next int16) {
	c.observer.Next(next)
}

func (c *concatInt16Subscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatInt16Subscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatInt16Observable struct {
	observables []Int16Observable
}

func (m *concatInt16Observable) Subscribe(observer Int16Observer) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatInt16Subscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *Int16Stream) Concat(observables ...Int16Observable) *Int16Stream {
	return &Int16Stream{&concatInt16Observable{append([]Int16Observable{s}, observables...)}}
}

type mergeInt16Observable struct {
	delayError  bool
	observables []Int16Observable
}

func (m *mergeInt16Observable) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next int16, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(Int16ObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *Int16Stream) Merge(other ...Int16Observable) *Int16Stream {
	if len(other) == 0 {
		return s
	}
	return &Int16Stream{&mergeInt16Observable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *Int16Stream) MergeDelayError(other ...Int16Observable) *Int16Stream {
	if len(other) == 0 {
		return s
	}
	return &Int16Stream{&mergeInt16Observable{true, append(other, s)}}
}

type catchInt16Observable struct {
	parent Int16Observable
	catch  Int16Observable
}

func (r *catchInt16Observable) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	run := func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(Int16ObserverFunc(run))
	return subscription
}

func (s *Int16Stream) Catch(catch Int16Observable) *Int16Stream {
	return &Int16Stream{&catchInt16Observable{s, catch}}
}

type retryInt16Observable struct {
	observable Int16Observable
}

type retryInt16Observer struct {
	observable Int16Observable
	observer   Int16Observer
}

func (r *retryInt16Observer) retry(next int16, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(Int16ObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryInt16Observable) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryInt16Observer{r.observable, observer}
	r.observable.Subscribe(Int16ObserverFunc(ro.retry))
	return subscription
}

func (s *Int16Stream) Retry() *Int16Stream {
	return &Int16Stream{&retryInt16Observable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *Int16Stream) Do(f func(next int16)) *Int16Stream {
	return FromInt16Observable(MapInt162Int16ObserveNext(s, func(next int16) int16 {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *Int16Stream) DoOnError(f func(err error)) *Int16Stream {
	return FromInt16Observable(MapInt162Int16ObserveDirect(s, func(next int16, err error, complete bool, observer Int16Observer) {
		if err != nil {
			f(err)
		}
		PassthroughInt16(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *Int16Stream) DoOnComplete(f func()) *Int16Stream {
	return FromInt16Observable(MapInt162Int16ObserveDirect(s, func(next int16, err error, complete bool, observer Int16Observer) {
		if complete {
			f()
		}
		PassthroughInt16(next, err, complete, observer)
	}))
}

func (s *Int16Stream) Reduce(initial int16, reducer func(int16, int16) int16) *Int16Stream {
	value := initial
	return FromInt16Observable(MapInt162Int16ObserveDirect(s, func(next int16, err error, complete bool, observer Int16Observer) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *Int16Stream) Scan(initial int16, f func(int16, int16) int16) *Int16Stream {
	value := initial
	return FromInt16Observable(MapInt162Int16ObserveDirect(s, func(next int16, err error, complete bool, observer Int16Observer) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutInt16 struct {
	parent  Int16Observable
	timeout time.Duration
}

func (t *timeoutInt16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *Int16Stream) Timeout(timeout time.Duration) *Int16Stream {
	return &Int16Stream{&timeoutInt16{s, timeout}}
}

type forkedInt16Stream struct {
	lock      sync.Mutex
	parent    Int16Observable
	observers []Int16Observer
}

func (f *forkedInt16Stream) Subscribe(observer Int16Observer) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *Int16Stream) Fork() *Int16Stream {
	f := &forkedInt16Stream{parent: s}
	go s.Subscribe(Int16ObserverFunc(func(n int16, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &Int16Stream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *Int16Stream) ToOneWithError() (int16, error) {
	valuech := make(chan int16, 1)
	errch := make(chan error, 1)
	FromInt16Observable(oneFilter().Int16(s)).SubscribeFunc(func(next int16, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroInt16, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *Int16Stream) ToOne() int16 {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *Int16Stream) ToArrayWithError() ([]int16, error) {
	array := []int16{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *Int16Stream) ToArray() []int16 {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *Int16Stream) ToChannelWithError() (<-chan int16, <-chan error) {
	ch := make(chan int16, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *Int16Stream) ToChannel() <-chan int16 {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *Int16Stream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapInt162IntObserveDirect(s, func(next int16, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

func (s *Int16Stream) Average() *Int16Stream {
	var sum int16
	var count int16
	return FromInt16Observable(MapInt162Int16ObserveDirect(s, func(next int16, err error, complete bool, observer Int16Observer) {
		switch {
		case err != nil:
			observer.Next(sum / count)
			observer.Error(err)
		case complete:
			observer.Next(sum / count)
			observer.Complete()
		default:
			sum += next
			count++
		}
	}))
}

func (s *Int16Stream) Sum() *Int16Stream {
	var sum int16
	return FromInt16Observable(MapInt162Int16ObserveDirect(s, func(next int16, err error, complete bool, observer Int16Observer) {
		switch {
		case err != nil:
			observer.Next(sum)
			observer.Error(err)
		case complete:
			observer.Next(sum)
			observer.Complete()
		default:
			sum += next
		}
	}))
}

func (s *Int16Stream) Min() *Int16Stream {
	started := false
	var min int16
	return FromInt16Observable(MapInt162Int16ObserveDirect(s, func(next int16, err error, complete bool, observer Int16Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(min)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(min)
			}
			observer.Complete()
		default:
			if started {
				if min > next {
					min = next
				}
			} else {
				min = next
				started = true
			}
		}
	}))
}

func (s *Int16Stream) Max() *Int16Stream {
	started := false
	var max int16
	return FromInt16Observable(MapInt162Int16ObserveDirect(s, func(next int16, err error, complete bool, observer Int16Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(max)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(max)
			}
			observer.Complete()
		default:
			if started {
				if max <= next {
					max = next
				}
			} else {
				max = next
				started = true
			}
		}
	}))
}

type MappingInt162BoolFunc func(next int16, err error, complete bool, observer BoolObserver)
type MappingInt162BoolFuncFactory func(observer BoolObserver) MappingInt162BoolFunc

type MappingInt162BoolObservable struct {
	parent Int16Observable
	mapper MappingInt162BoolFuncFactory
}

func (f *MappingInt162BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162BoolObservable(parent Int16Observable, mapper MappingInt162BoolFuncFactory) BoolObservable {
	return &MappingInt162BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162BoolObserveDirect(parent Int16Observable, mapper MappingInt162BoolFunc) BoolObservable {
	return MapInt162BoolObservable(parent, func(BoolObserver) MappingInt162BoolFunc {
		return mapper
	})
}

func MapInt162BoolObserveNext(parent Int16Observable, mapper func(int16) bool) BoolObservable {
	return MapInt162BoolObservable(parent, func(BoolObserver) MappingInt162BoolFunc {
		return func(next int16, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Bool struct {
	parent Int16Observable
	mapper func(int16) BoolObservable
}

func (f *flatMapInt162Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *Int16Stream) MapBool(f func(int16) bool) *BoolStream {
	return FromBoolObservable(MapInt162BoolObserveNext(s, f))
}

func (s *Int16Stream) FlatMapBool(f func(int16) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapInt162Bool{s, f}}
}

type MappingInt162RuneFunc func(next int16, err error, complete bool, observer RuneObserver)
type MappingInt162RuneFuncFactory func(observer RuneObserver) MappingInt162RuneFunc

type MappingInt162RuneObservable struct {
	parent Int16Observable
	mapper MappingInt162RuneFuncFactory
}

func (f *MappingInt162RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162RuneObservable(parent Int16Observable, mapper MappingInt162RuneFuncFactory) RuneObservable {
	return &MappingInt162RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162RuneObserveDirect(parent Int16Observable, mapper MappingInt162RuneFunc) RuneObservable {
	return MapInt162RuneObservable(parent, func(RuneObserver) MappingInt162RuneFunc {
		return mapper
	})
}

func MapInt162RuneObserveNext(parent Int16Observable, mapper func(int16) rune) RuneObservable {
	return MapInt162RuneObservable(parent, func(RuneObserver) MappingInt162RuneFunc {
		return func(next int16, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Rune struct {
	parent Int16Observable
	mapper func(int16) RuneObservable
}

func (f *flatMapInt162Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *Int16Stream) MapRune(f func(int16) rune) *RuneStream {
	return FromRuneObservable(MapInt162RuneObserveNext(s, f))
}

func (s *Int16Stream) FlatMapRune(f func(int16) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapInt162Rune{s, f}}
}

type MappingInt162ByteFunc func(next int16, err error, complete bool, observer ByteObserver)
type MappingInt162ByteFuncFactory func(observer ByteObserver) MappingInt162ByteFunc

type MappingInt162ByteObservable struct {
	parent Int16Observable
	mapper MappingInt162ByteFuncFactory
}

func (f *MappingInt162ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162ByteObservable(parent Int16Observable, mapper MappingInt162ByteFuncFactory) ByteObservable {
	return &MappingInt162ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162ByteObserveDirect(parent Int16Observable, mapper MappingInt162ByteFunc) ByteObservable {
	return MapInt162ByteObservable(parent, func(ByteObserver) MappingInt162ByteFunc {
		return mapper
	})
}

func MapInt162ByteObserveNext(parent Int16Observable, mapper func(int16) byte) ByteObservable {
	return MapInt162ByteObservable(parent, func(ByteObserver) MappingInt162ByteFunc {
		return func(next int16, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Byte struct {
	parent Int16Observable
	mapper func(int16) ByteObservable
}

func (f *flatMapInt162Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *Int16Stream) MapByte(f func(int16) byte) *ByteStream {
	return FromByteObservable(MapInt162ByteObserveNext(s, f))
}

func (s *Int16Stream) FlatMapByte(f func(int16) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapInt162Byte{s, f}}
}

type MappingInt162StringFunc func(next int16, err error, complete bool, observer StringObserver)
type MappingInt162StringFuncFactory func(observer StringObserver) MappingInt162StringFunc

type MappingInt162StringObservable struct {
	parent Int16Observable
	mapper MappingInt162StringFuncFactory
}

func (f *MappingInt162StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162StringObservable(parent Int16Observable, mapper MappingInt162StringFuncFactory) StringObservable {
	return &MappingInt162StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162StringObserveDirect(parent Int16Observable, mapper MappingInt162StringFunc) StringObservable {
	return MapInt162StringObservable(parent, func(StringObserver) MappingInt162StringFunc {
		return mapper
	})
}

func MapInt162StringObserveNext(parent Int16Observable, mapper func(int16) string) StringObservable {
	return MapInt162StringObservable(parent, func(StringObserver) MappingInt162StringFunc {
		return func(next int16, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162String struct {
	parent Int16Observable
	mapper func(int16) StringObservable
}

func (f *flatMapInt162String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *Int16Stream) MapString(f func(int16) string) *StringStream {
	return FromStringObservable(MapInt162StringObserveNext(s, f))
}

func (s *Int16Stream) FlatMapString(f func(int16) StringObservable) *StringStream {
	return &StringStream{&flatMapInt162String{s, f}}
}

type MappingInt162UintFunc func(next int16, err error, complete bool, observer UintObserver)
type MappingInt162UintFuncFactory func(observer UintObserver) MappingInt162UintFunc

type MappingInt162UintObservable struct {
	parent Int16Observable
	mapper MappingInt162UintFuncFactory
}

func (f *MappingInt162UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162UintObservable(parent Int16Observable, mapper MappingInt162UintFuncFactory) UintObservable {
	return &MappingInt162UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162UintObserveDirect(parent Int16Observable, mapper MappingInt162UintFunc) UintObservable {
	return MapInt162UintObservable(parent, func(UintObserver) MappingInt162UintFunc {
		return mapper
	})
}

func MapInt162UintObserveNext(parent Int16Observable, mapper func(int16) uint) UintObservable {
	return MapInt162UintObservable(parent, func(UintObserver) MappingInt162UintFunc {
		return func(next int16, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Uint struct {
	parent Int16Observable
	mapper func(int16) UintObservable
}

func (f *flatMapInt162Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *Int16Stream) MapUint(f func(int16) uint) *UintStream {
	return FromUintObservable(MapInt162UintObserveNext(s, f))
}

func (s *Int16Stream) FlatMapUint(f func(int16) UintObservable) *UintStream {
	return &UintStream{&flatMapInt162Uint{s, f}}
}

type MappingInt162IntFunc func(next int16, err error, complete bool, observer IntObserver)
type MappingInt162IntFuncFactory func(observer IntObserver) MappingInt162IntFunc

type MappingInt162IntObservable struct {
	parent Int16Observable
	mapper MappingInt162IntFuncFactory
}

func (f *MappingInt162IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162IntObservable(parent Int16Observable, mapper MappingInt162IntFuncFactory) IntObservable {
	return &MappingInt162IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162IntObserveDirect(parent Int16Observable, mapper MappingInt162IntFunc) IntObservable {
	return MapInt162IntObservable(parent, func(IntObserver) MappingInt162IntFunc {
		return mapper
	})
}

func MapInt162IntObserveNext(parent Int16Observable, mapper func(int16) int) IntObservable {
	return MapInt162IntObservable(parent, func(IntObserver) MappingInt162IntFunc {
		return func(next int16, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Int struct {
	parent Int16Observable
	mapper func(int16) IntObservable
}

func (f *flatMapInt162Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *Int16Stream) MapInt(f func(int16) int) *IntStream {
	return FromIntObservable(MapInt162IntObserveNext(s, f))
}

func (s *Int16Stream) FlatMapInt(f func(int16) IntObservable) *IntStream {
	return &IntStream{&flatMapInt162Int{s, f}}
}

type MappingInt162Uint8Func func(next int16, err error, complete bool, observer Uint8Observer)
type MappingInt162Uint8FuncFactory func(observer Uint8Observer) MappingInt162Uint8Func

type MappingInt162Uint8Observable struct {
	parent Int16Observable
	mapper MappingInt162Uint8FuncFactory
}

func (f *MappingInt162Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162Uint8Observable(parent Int16Observable, mapper MappingInt162Uint8FuncFactory) Uint8Observable {
	return &MappingInt162Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162Uint8ObserveDirect(parent Int16Observable, mapper MappingInt162Uint8Func) Uint8Observable {
	return MapInt162Uint8Observable(parent, func(Uint8Observer) MappingInt162Uint8Func {
		return mapper
	})
}

func MapInt162Uint8ObserveNext(parent Int16Observable, mapper func(int16) uint8) Uint8Observable {
	return MapInt162Uint8Observable(parent, func(Uint8Observer) MappingInt162Uint8Func {
		return func(next int16, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Uint8 struct {
	parent Int16Observable
	mapper func(int16) Uint8Observable
}

func (f *flatMapInt162Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *Int16Stream) MapUint8(f func(int16) uint8) *Uint8Stream {
	return FromUint8Observable(MapInt162Uint8ObserveNext(s, f))
}

func (s *Int16Stream) FlatMapUint8(f func(int16) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapInt162Uint8{s, f}}
}

type MappingInt162Int8Func func(next int16, err error, complete bool, observer Int8Observer)
type MappingInt162Int8FuncFactory func(observer Int8Observer) MappingInt162Int8Func

type MappingInt162Int8Observable struct {
	parent Int16Observable
	mapper MappingInt162Int8FuncFactory
}

func (f *MappingInt162Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162Int8Observable(parent Int16Observable, mapper MappingInt162Int8FuncFactory) Int8Observable {
	return &MappingInt162Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162Int8ObserveDirect(parent Int16Observable, mapper MappingInt162Int8Func) Int8Observable {
	return MapInt162Int8Observable(parent, func(Int8Observer) MappingInt162Int8Func {
		return mapper
	})
}

func MapInt162Int8ObserveNext(parent Int16Observable, mapper func(int16) int8) Int8Observable {
	return MapInt162Int8Observable(parent, func(Int8Observer) MappingInt162Int8Func {
		return func(next int16, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Int8 struct {
	parent Int16Observable
	mapper func(int16) Int8Observable
}

func (f *flatMapInt162Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *Int16Stream) MapInt8(f func(int16) int8) *Int8Stream {
	return FromInt8Observable(MapInt162Int8ObserveNext(s, f))
}

func (s *Int16Stream) FlatMapInt8(f func(int16) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapInt162Int8{s, f}}
}

type MappingInt162Uint16Func func(next int16, err error, complete bool, observer Uint16Observer)
type MappingInt162Uint16FuncFactory func(observer Uint16Observer) MappingInt162Uint16Func

type MappingInt162Uint16Observable struct {
	parent Int16Observable
	mapper MappingInt162Uint16FuncFactory
}

func (f *MappingInt162Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162Uint16Observable(parent Int16Observable, mapper MappingInt162Uint16FuncFactory) Uint16Observable {
	return &MappingInt162Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162Uint16ObserveDirect(parent Int16Observable, mapper MappingInt162Uint16Func) Uint16Observable {
	return MapInt162Uint16Observable(parent, func(Uint16Observer) MappingInt162Uint16Func {
		return mapper
	})
}

func MapInt162Uint16ObserveNext(parent Int16Observable, mapper func(int16) uint16) Uint16Observable {
	return MapInt162Uint16Observable(parent, func(Uint16Observer) MappingInt162Uint16Func {
		return func(next int16, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Uint16 struct {
	parent Int16Observable
	mapper func(int16) Uint16Observable
}

func (f *flatMapInt162Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *Int16Stream) MapUint16(f func(int16) uint16) *Uint16Stream {
	return FromUint16Observable(MapInt162Uint16ObserveNext(s, f))
}

func (s *Int16Stream) FlatMapUint16(f func(int16) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapInt162Uint16{s, f}}
}

type MappingInt162Int16Func func(next int16, err error, complete bool, observer Int16Observer)
type MappingInt162Int16FuncFactory func(observer Int16Observer) MappingInt162Int16Func

type MappingInt162Int16Observable struct {
	parent Int16Observable
	mapper MappingInt162Int16FuncFactory
}

func (f *MappingInt162Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162Int16Observable(parent Int16Observable, mapper MappingInt162Int16FuncFactory) Int16Observable {
	return &MappingInt162Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162Int16ObserveDirect(parent Int16Observable, mapper MappingInt162Int16Func) Int16Observable {
	return MapInt162Int16Observable(parent, func(Int16Observer) MappingInt162Int16Func {
		return mapper
	})
}

func MapInt162Int16ObserveNext(parent Int16Observable, mapper func(int16) int16) Int16Observable {
	return MapInt162Int16Observable(parent, func(Int16Observer) MappingInt162Int16Func {
		return func(next int16, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Int16 struct {
	parent Int16Observable
	mapper func(int16) Int16Observable
}

func (f *flatMapInt162Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *Int16Stream) Map(f func(int16) int16) *Int16Stream {
	return FromInt16Observable(MapInt162Int16ObserveNext(s, f))
}

func (s *Int16Stream) FlatMap(f func(int16) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapInt162Int16{s, f}}
}

type MappingInt162Uint32Func func(next int16, err error, complete bool, observer Uint32Observer)
type MappingInt162Uint32FuncFactory func(observer Uint32Observer) MappingInt162Uint32Func

type MappingInt162Uint32Observable struct {
	parent Int16Observable
	mapper MappingInt162Uint32FuncFactory
}

func (f *MappingInt162Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162Uint32Observable(parent Int16Observable, mapper MappingInt162Uint32FuncFactory) Uint32Observable {
	return &MappingInt162Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162Uint32ObserveDirect(parent Int16Observable, mapper MappingInt162Uint32Func) Uint32Observable {
	return MapInt162Uint32Observable(parent, func(Uint32Observer) MappingInt162Uint32Func {
		return mapper
	})
}

func MapInt162Uint32ObserveNext(parent Int16Observable, mapper func(int16) uint32) Uint32Observable {
	return MapInt162Uint32Observable(parent, func(Uint32Observer) MappingInt162Uint32Func {
		return func(next int16, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Uint32 struct {
	parent Int16Observable
	mapper func(int16) Uint32Observable
}

func (f *flatMapInt162Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *Int16Stream) MapUint32(f func(int16) uint32) *Uint32Stream {
	return FromUint32Observable(MapInt162Uint32ObserveNext(s, f))
}

func (s *Int16Stream) FlatMapUint32(f func(int16) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapInt162Uint32{s, f}}
}

type MappingInt162Int32Func func(next int16, err error, complete bool, observer Int32Observer)
type MappingInt162Int32FuncFactory func(observer Int32Observer) MappingInt162Int32Func

type MappingInt162Int32Observable struct {
	parent Int16Observable
	mapper MappingInt162Int32FuncFactory
}

func (f *MappingInt162Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162Int32Observable(parent Int16Observable, mapper MappingInt162Int32FuncFactory) Int32Observable {
	return &MappingInt162Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162Int32ObserveDirect(parent Int16Observable, mapper MappingInt162Int32Func) Int32Observable {
	return MapInt162Int32Observable(parent, func(Int32Observer) MappingInt162Int32Func {
		return mapper
	})
}

func MapInt162Int32ObserveNext(parent Int16Observable, mapper func(int16) int32) Int32Observable {
	return MapInt162Int32Observable(parent, func(Int32Observer) MappingInt162Int32Func {
		return func(next int16, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Int32 struct {
	parent Int16Observable
	mapper func(int16) Int32Observable
}

func (f *flatMapInt162Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *Int16Stream) MapInt32(f func(int16) int32) *Int32Stream {
	return FromInt32Observable(MapInt162Int32ObserveNext(s, f))
}

func (s *Int16Stream) FlatMapInt32(f func(int16) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapInt162Int32{s, f}}
}

type MappingInt162Uint64Func func(next int16, err error, complete bool, observer Uint64Observer)
type MappingInt162Uint64FuncFactory func(observer Uint64Observer) MappingInt162Uint64Func

type MappingInt162Uint64Observable struct {
	parent Int16Observable
	mapper MappingInt162Uint64FuncFactory
}

func (f *MappingInt162Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162Uint64Observable(parent Int16Observable, mapper MappingInt162Uint64FuncFactory) Uint64Observable {
	return &MappingInt162Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162Uint64ObserveDirect(parent Int16Observable, mapper MappingInt162Uint64Func) Uint64Observable {
	return MapInt162Uint64Observable(parent, func(Uint64Observer) MappingInt162Uint64Func {
		return mapper
	})
}

func MapInt162Uint64ObserveNext(parent Int16Observable, mapper func(int16) uint64) Uint64Observable {
	return MapInt162Uint64Observable(parent, func(Uint64Observer) MappingInt162Uint64Func {
		return func(next int16, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Uint64 struct {
	parent Int16Observable
	mapper func(int16) Uint64Observable
}

func (f *flatMapInt162Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *Int16Stream) MapUint64(f func(int16) uint64) *Uint64Stream {
	return FromUint64Observable(MapInt162Uint64ObserveNext(s, f))
}

func (s *Int16Stream) FlatMapUint64(f func(int16) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapInt162Uint64{s, f}}
}

type MappingInt162Int64Func func(next int16, err error, complete bool, observer Int64Observer)
type MappingInt162Int64FuncFactory func(observer Int64Observer) MappingInt162Int64Func

type MappingInt162Int64Observable struct {
	parent Int16Observable
	mapper MappingInt162Int64FuncFactory
}

func (f *MappingInt162Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162Int64Observable(parent Int16Observable, mapper MappingInt162Int64FuncFactory) Int64Observable {
	return &MappingInt162Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162Int64ObserveDirect(parent Int16Observable, mapper MappingInt162Int64Func) Int64Observable {
	return MapInt162Int64Observable(parent, func(Int64Observer) MappingInt162Int64Func {
		return mapper
	})
}

func MapInt162Int64ObserveNext(parent Int16Observable, mapper func(int16) int64) Int64Observable {
	return MapInt162Int64Observable(parent, func(Int64Observer) MappingInt162Int64Func {
		return func(next int16, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Int64 struct {
	parent Int16Observable
	mapper func(int16) Int64Observable
}

func (f *flatMapInt162Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *Int16Stream) MapInt64(f func(int16) int64) *Int64Stream {
	return FromInt64Observable(MapInt162Int64ObserveNext(s, f))
}

func (s *Int16Stream) FlatMapInt64(f func(int16) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapInt162Int64{s, f}}
}

type MappingInt162Float32Func func(next int16, err error, complete bool, observer Float32Observer)
type MappingInt162Float32FuncFactory func(observer Float32Observer) MappingInt162Float32Func

type MappingInt162Float32Observable struct {
	parent Int16Observable
	mapper MappingInt162Float32FuncFactory
}

func (f *MappingInt162Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162Float32Observable(parent Int16Observable, mapper MappingInt162Float32FuncFactory) Float32Observable {
	return &MappingInt162Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162Float32ObserveDirect(parent Int16Observable, mapper MappingInt162Float32Func) Float32Observable {
	return MapInt162Float32Observable(parent, func(Float32Observer) MappingInt162Float32Func {
		return mapper
	})
}

func MapInt162Float32ObserveNext(parent Int16Observable, mapper func(int16) float32) Float32Observable {
	return MapInt162Float32Observable(parent, func(Float32Observer) MappingInt162Float32Func {
		return func(next int16, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Float32 struct {
	parent Int16Observable
	mapper func(int16) Float32Observable
}

func (f *flatMapInt162Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *Int16Stream) MapFloat32(f func(int16) float32) *Float32Stream {
	return FromFloat32Observable(MapInt162Float32ObserveNext(s, f))
}

func (s *Int16Stream) FlatMapFloat32(f func(int16) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapInt162Float32{s, f}}
}

type MappingInt162Float64Func func(next int16, err error, complete bool, observer Float64Observer)
type MappingInt162Float64FuncFactory func(observer Float64Observer) MappingInt162Float64Func

type MappingInt162Float64Observable struct {
	parent Int16Observable
	mapper MappingInt162Float64FuncFactory
}

func (f *MappingInt162Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162Float64Observable(parent Int16Observable, mapper MappingInt162Float64FuncFactory) Float64Observable {
	return &MappingInt162Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162Float64ObserveDirect(parent Int16Observable, mapper MappingInt162Float64Func) Float64Observable {
	return MapInt162Float64Observable(parent, func(Float64Observer) MappingInt162Float64Func {
		return mapper
	})
}

func MapInt162Float64ObserveNext(parent Int16Observable, mapper func(int16) float64) Float64Observable {
	return MapInt162Float64Observable(parent, func(Float64Observer) MappingInt162Float64Func {
		return func(next int16, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Float64 struct {
	parent Int16Observable
	mapper func(int16) Float64Observable
}

func (f *flatMapInt162Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *Int16Stream) MapFloat64(f func(int16) float64) *Float64Stream {
	return FromFloat64Observable(MapInt162Float64ObserveNext(s, f))
}

func (s *Int16Stream) FlatMapFloat64(f func(int16) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapInt162Float64{s, f}}
}

type MappingInt162Complex64Func func(next int16, err error, complete bool, observer Complex64Observer)
type MappingInt162Complex64FuncFactory func(observer Complex64Observer) MappingInt162Complex64Func

type MappingInt162Complex64Observable struct {
	parent Int16Observable
	mapper MappingInt162Complex64FuncFactory
}

func (f *MappingInt162Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162Complex64Observable(parent Int16Observable, mapper MappingInt162Complex64FuncFactory) Complex64Observable {
	return &MappingInt162Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162Complex64ObserveDirect(parent Int16Observable, mapper MappingInt162Complex64Func) Complex64Observable {
	return MapInt162Complex64Observable(parent, func(Complex64Observer) MappingInt162Complex64Func {
		return mapper
	})
}

func MapInt162Complex64ObserveNext(parent Int16Observable, mapper func(int16) complex64) Complex64Observable {
	return MapInt162Complex64Observable(parent, func(Complex64Observer) MappingInt162Complex64Func {
		return func(next int16, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Complex64 struct {
	parent Int16Observable
	mapper func(int16) Complex64Observable
}

func (f *flatMapInt162Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *Int16Stream) MapComplex64(f func(int16) complex64) *Complex64Stream {
	return FromComplex64Observable(MapInt162Complex64ObserveNext(s, f))
}

func (s *Int16Stream) FlatMapComplex64(f func(int16) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapInt162Complex64{s, f}}
}

type MappingInt162Complex128Func func(next int16, err error, complete bool, observer Complex128Observer)
type MappingInt162Complex128FuncFactory func(observer Complex128Observer) MappingInt162Complex128Func

type MappingInt162Complex128Observable struct {
	parent Int16Observable
	mapper MappingInt162Complex128FuncFactory
}

func (f *MappingInt162Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162Complex128Observable(parent Int16Observable, mapper MappingInt162Complex128FuncFactory) Complex128Observable {
	return &MappingInt162Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162Complex128ObserveDirect(parent Int16Observable, mapper MappingInt162Complex128Func) Complex128Observable {
	return MapInt162Complex128Observable(parent, func(Complex128Observer) MappingInt162Complex128Func {
		return mapper
	})
}

func MapInt162Complex128ObserveNext(parent Int16Observable, mapper func(int16) complex128) Complex128Observable {
	return MapInt162Complex128Observable(parent, func(Complex128Observer) MappingInt162Complex128Func {
		return func(next int16, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Complex128 struct {
	parent Int16Observable
	mapper func(int16) Complex128Observable
}

func (f *flatMapInt162Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *Int16Stream) MapComplex128(f func(int16) complex128) *Complex128Stream {
	return FromComplex128Observable(MapInt162Complex128ObserveNext(s, f))
}

func (s *Int16Stream) FlatMapComplex128(f func(int16) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapInt162Complex128{s, f}}
}

type MappingInt162TimeFunc func(next int16, err error, complete bool, observer TimeObserver)
type MappingInt162TimeFuncFactory func(observer TimeObserver) MappingInt162TimeFunc

type MappingInt162TimeObservable struct {
	parent Int16Observable
	mapper MappingInt162TimeFuncFactory
}

func (f *MappingInt162TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162TimeObservable(parent Int16Observable, mapper MappingInt162TimeFuncFactory) TimeObservable {
	return &MappingInt162TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162TimeObserveDirect(parent Int16Observable, mapper MappingInt162TimeFunc) TimeObservable {
	return MapInt162TimeObservable(parent, func(TimeObserver) MappingInt162TimeFunc {
		return mapper
	})
}

func MapInt162TimeObserveNext(parent Int16Observable, mapper func(int16) time.Time) TimeObservable {
	return MapInt162TimeObservable(parent, func(TimeObserver) MappingInt162TimeFunc {
		return func(next int16, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Time struct {
	parent Int16Observable
	mapper func(int16) TimeObservable
}

func (f *flatMapInt162Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *Int16Stream) MapTime(f func(int16) time.Time) *TimeStream {
	return FromTimeObservable(MapInt162TimeObserveNext(s, f))
}

func (s *Int16Stream) FlatMapTime(f func(int16) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapInt162Time{s, f}}
}

type MappingInt162DurationFunc func(next int16, err error, complete bool, observer DurationObserver)
type MappingInt162DurationFuncFactory func(observer DurationObserver) MappingInt162DurationFunc

type MappingInt162DurationObservable struct {
	parent Int16Observable
	mapper MappingInt162DurationFuncFactory
}

func (f *MappingInt162DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt162DurationObservable(parent Int16Observable, mapper MappingInt162DurationFuncFactory) DurationObservable {
	return &MappingInt162DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt162DurationObserveDirect(parent Int16Observable, mapper MappingInt162DurationFunc) DurationObservable {
	return MapInt162DurationObservable(parent, func(DurationObserver) MappingInt162DurationFunc {
		return mapper
	})
}

func MapInt162DurationObserveNext(parent Int16Observable, mapper func(int16) time.Duration) DurationObservable {
	return MapInt162DurationObservable(parent, func(DurationObserver) MappingInt162DurationFunc {
		return func(next int16, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt162Duration struct {
	parent Int16Observable
	mapper func(int16) DurationObservable
}

func (f *flatMapInt162Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int16ObserverFunc(func(next int16, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *Int16Stream) MapDuration(f func(int16) time.Duration) *DurationStream {
	return FromDurationObservable(MapInt162DurationObserveNext(s, f))
}

func (s *Int16Stream) FlatMapDuration(f func(int16) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapInt162Duration{s, f}}
}

type Uint32Observer interface {
	Next(uint32)
	TerminationObserver
}

// A Uint32Subscriber represents a subscribed Uint32Observer.
type Uint32Subscriber interface {
	Subscription
	Uint32Observer
}

type implUint32Subscriber struct {
	Subscription
	Uint32Observer
}

func Uint32ObserverAsGenericObserver(observer Uint32Observer) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(uint32))
		}
	})
}

func GenericObserverAsUint32Observer(observer GenericObserver) Uint32Observer {
	return Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type Uint32ObservableFactory func(observer Uint32Observer, subscription Subscription)

func (f Uint32ObservableFactory) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateUint32 calls f(observer, subscription) to produce values for a stream.
func CreateUint32(f func(observer Uint32Observer, subscription Subscription)) *Uint32Stream {
	return FromUint32Observable(Uint32ObservableFactory(f))
}

// Repeat value count times.
func RepeatUint32(value uint32, count int) *Uint32Stream {
	return CreateUint32(func(observer Uint32Observer, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartUint32 is designed to be used with functions that return a
// (uint32, error) tuple.
//
// If the error is non-nil the returned Uint32Stream will be that error,
// otherwise it will be a single-value stream of uint32.
func StartUint32(f func() (uint32, error)) *Uint32Stream {
	return CreateUint32(func(observer Uint32Observer, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughUint32(next uint32, err error, complete bool, observer Uint32Observer) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroUint32 = *new(uint32)

type Uint32ObserverFunc func(uint32, error, bool)

func (f Uint32ObserverFunc) Next(next uint32) { f(next, nil, false) }
func (f Uint32ObserverFunc) Error(err error)  { f(zeroUint32, err, false) }
func (f Uint32ObserverFunc) Complete()        { f(zeroUint32, nil, true) }

type Uint32Observable interface {
	Subscribe(Uint32Observer) Subscription
}

// Convert a GenericObservableFilter to a Uint32Observable
func (f GenericObservableFilterFactory) Uint32(parent Uint32Observable) Uint32Observable {
	return MapUint322Uint32Observable(parent, func(observer Uint32Observer) MappingUint322Uint32Func {
		gobserver := Uint32ObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next uint32, err error, complete bool, observer Uint32Observer) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverUint32() *Uint32Stream {
	return CreateUint32(func(observer Uint32Observer, subscription Subscription) {})
}

func EmptyUint32() *Uint32Stream {
	return CreateUint32(func(observer Uint32Observer, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowUint32(err error) *Uint32Stream {
	return CreateUint32(func(observer Uint32Observer, subscription Subscription) {
		observer.Error(err)
	})
}

func FromUint32Array(array []uint32) *Uint32Stream {
	return CreateUint32(func(observer Uint32Observer, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromUint32s(array ...uint32) *Uint32Stream {
	return FromUint32Array(array)
}

func JustUint32(element uint32) *Uint32Stream {
	return FromUint32Array([]uint32{element})
}

func MergeUint32(observables ...Uint32Observable) *Uint32Stream {
	if len(observables) == 0 {
		return EmptyUint32()
	}
	return (&Uint32Stream{observables[0]}).Merge(observables[1:]...)
}

func MergeUint32DelayError(observables ...Uint32Observable) *Uint32Stream {
	if len(observables) == 0 {
		return EmptyUint32()
	}
	return (&Uint32Stream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromUint32Channel(ch <-chan uint32) *Uint32Stream {
	return CreateUint32(func(observer Uint32Observer, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type Uint32Stream struct {
	Uint32Observable
}

func FromUint32Observable(observable Uint32Observable) *Uint32Stream {
	return &Uint32Stream{observable}
}

func (s *Uint32Stream) SubscribeFunc(f func(uint32, error, bool)) Subscription {
	return s.Subscribe(Uint32ObserverFunc(f))
}

func (s *Uint32Stream) SubscribeNext(f func(v uint32)) Subscription {
	return s.SubscribeFunc(func(next uint32, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *Uint32Stream) Distinct() *Uint32Stream {
	return FromUint32Observable(distinctFilter().Uint32(s))
}

// ElementAt yields the Nth element of the stream.
func (s *Uint32Stream) ElementAt(n int) *Uint32Stream {
	return FromUint32Observable(elementAtFilter(n).Uint32(s))
}

// Filter elements in the stream on a function.
func (s *Uint32Stream) Filter(f func(uint32) bool) *Uint32Stream {
	return FromUint32Observable(filterFilter(func(v interface{}) bool { return f(v.(uint32)) }).Uint32(s))
}

// Last returns just the first element of the stream.
func (s *Uint32Stream) First() *Uint32Stream {
	return FromUint32Observable(firstFilter().Uint32(s))
}

// Last returns just the last element of the stream.
func (s *Uint32Stream) Last() *Uint32Stream {
	return FromUint32Observable(lastFilter().Uint32(s))
}

// SkipLast skips the first N elements of the stream.
func (s *Uint32Stream) Skip(n int) *Uint32Stream {
	return FromUint32Observable(skipFilter(n).Uint32(s))
}

// SkipLast skips the last N elements of the stream.
func (s *Uint32Stream) SkipLast(n int) *Uint32Stream {
	return FromUint32Observable(skipLastFilter(n).Uint32(s))
}

// Take returns just the first N elements of the stream.
func (s *Uint32Stream) Take(n int) *Uint32Stream {
	return FromUint32Observable(takeFilter(n).Uint32(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *Uint32Stream) TakeLast(n int) *Uint32Stream {
	return FromUint32Observable(takeLastFilter(n).Uint32(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *Uint32Stream) IgnoreElements() *Uint32Stream {
	return FromUint32Observable(ignoreElementsFilter().Uint32(s))
}

func (s *Uint32Stream) Replay(size int, duration time.Duration) *Uint32Stream {
	return FromUint32Observable(replayFilter(size, duration).Uint32(s))
}

func (s *Uint32Stream) Sample(duration time.Duration) *Uint32Stream {
	return FromUint32Observable(sampleFilter(duration).Uint32(s))
}

func (s *Uint32Stream) Debounce(duration time.Duration) *Uint32Stream {
	return FromUint32Observable(debounceFilter(duration).Uint32(s))
}

// Wait for completion of the stream and return any error.
func (s *Uint32Stream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeUint32Subscriber(observer Uint32Observer) Uint32Subscriber {
	if subscriber, ok := observer.(Uint32Subscriber); ok {
		return subscriber
	}
	return &implUint32Subscriber{NewGenericSubscription(), observer}
}

type concatUint32Subscriber struct {
	observable  int
	observer    Uint32Observer
	observables []Uint32Observable
	Subscription
}

func (c *concatUint32Subscriber) Next(next uint32) {
	c.observer.Next(next)
}

func (c *concatUint32Subscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatUint32Subscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatUint32Observable struct {
	observables []Uint32Observable
}

func (m *concatUint32Observable) Subscribe(observer Uint32Observer) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatUint32Subscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *Uint32Stream) Concat(observables ...Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&concatUint32Observable{append([]Uint32Observable{s}, observables...)}}
}

type mergeUint32Observable struct {
	delayError  bool
	observables []Uint32Observable
}

func (m *mergeUint32Observable) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next uint32, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(Uint32ObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *Uint32Stream) Merge(other ...Uint32Observable) *Uint32Stream {
	if len(other) == 0 {
		return s
	}
	return &Uint32Stream{&mergeUint32Observable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *Uint32Stream) MergeDelayError(other ...Uint32Observable) *Uint32Stream {
	if len(other) == 0 {
		return s
	}
	return &Uint32Stream{&mergeUint32Observable{true, append(other, s)}}
}

type catchUint32Observable struct {
	parent Uint32Observable
	catch  Uint32Observable
}

func (r *catchUint32Observable) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	run := func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(Uint32ObserverFunc(run))
	return subscription
}

func (s *Uint32Stream) Catch(catch Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&catchUint32Observable{s, catch}}
}

type retryUint32Observable struct {
	observable Uint32Observable
}

type retryUint32Observer struct {
	observable Uint32Observable
	observer   Uint32Observer
}

func (r *retryUint32Observer) retry(next uint32, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(Uint32ObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryUint32Observable) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryUint32Observer{r.observable, observer}
	r.observable.Subscribe(Uint32ObserverFunc(ro.retry))
	return subscription
}

func (s *Uint32Stream) Retry() *Uint32Stream {
	return &Uint32Stream{&retryUint32Observable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *Uint32Stream) Do(f func(next uint32)) *Uint32Stream {
	return FromUint32Observable(MapUint322Uint32ObserveNext(s, func(next uint32) uint32 {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *Uint32Stream) DoOnError(f func(err error)) *Uint32Stream {
	return FromUint32Observable(MapUint322Uint32ObserveDirect(s, func(next uint32, err error, complete bool, observer Uint32Observer) {
		if err != nil {
			f(err)
		}
		PassthroughUint32(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *Uint32Stream) DoOnComplete(f func()) *Uint32Stream {
	return FromUint32Observable(MapUint322Uint32ObserveDirect(s, func(next uint32, err error, complete bool, observer Uint32Observer) {
		if complete {
			f()
		}
		PassthroughUint32(next, err, complete, observer)
	}))
}

func (s *Uint32Stream) Reduce(initial uint32, reducer func(uint32, uint32) uint32) *Uint32Stream {
	value := initial
	return FromUint32Observable(MapUint322Uint32ObserveDirect(s, func(next uint32, err error, complete bool, observer Uint32Observer) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *Uint32Stream) Scan(initial uint32, f func(uint32, uint32) uint32) *Uint32Stream {
	value := initial
	return FromUint32Observable(MapUint322Uint32ObserveDirect(s, func(next uint32, err error, complete bool, observer Uint32Observer) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutUint32 struct {
	parent  Uint32Observable
	timeout time.Duration
}

func (t *timeoutUint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *Uint32Stream) Timeout(timeout time.Duration) *Uint32Stream {
	return &Uint32Stream{&timeoutUint32{s, timeout}}
}

type forkedUint32Stream struct {
	lock      sync.Mutex
	parent    Uint32Observable
	observers []Uint32Observer
}

func (f *forkedUint32Stream) Subscribe(observer Uint32Observer) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *Uint32Stream) Fork() *Uint32Stream {
	f := &forkedUint32Stream{parent: s}
	go s.Subscribe(Uint32ObserverFunc(func(n uint32, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &Uint32Stream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *Uint32Stream) ToOneWithError() (uint32, error) {
	valuech := make(chan uint32, 1)
	errch := make(chan error, 1)
	FromUint32Observable(oneFilter().Uint32(s)).SubscribeFunc(func(next uint32, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroUint32, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *Uint32Stream) ToOne() uint32 {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *Uint32Stream) ToArrayWithError() ([]uint32, error) {
	array := []uint32{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *Uint32Stream) ToArray() []uint32 {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *Uint32Stream) ToChannelWithError() (<-chan uint32, <-chan error) {
	ch := make(chan uint32, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *Uint32Stream) ToChannel() <-chan uint32 {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *Uint32Stream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapUint322IntObserveDirect(s, func(next uint32, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

func (s *Uint32Stream) Average() *Uint32Stream {
	var sum uint32
	var count uint32
	return FromUint32Observable(MapUint322Uint32ObserveDirect(s, func(next uint32, err error, complete bool, observer Uint32Observer) {
		switch {
		case err != nil:
			observer.Next(sum / count)
			observer.Error(err)
		case complete:
			observer.Next(sum / count)
			observer.Complete()
		default:
			sum += next
			count++
		}
	}))
}

func (s *Uint32Stream) Sum() *Uint32Stream {
	var sum uint32
	return FromUint32Observable(MapUint322Uint32ObserveDirect(s, func(next uint32, err error, complete bool, observer Uint32Observer) {
		switch {
		case err != nil:
			observer.Next(sum)
			observer.Error(err)
		case complete:
			observer.Next(sum)
			observer.Complete()
		default:
			sum += next
		}
	}))
}

func (s *Uint32Stream) Min() *Uint32Stream {
	started := false
	var min uint32
	return FromUint32Observable(MapUint322Uint32ObserveDirect(s, func(next uint32, err error, complete bool, observer Uint32Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(min)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(min)
			}
			observer.Complete()
		default:
			if started {
				if min > next {
					min = next
				}
			} else {
				min = next
				started = true
			}
		}
	}))
}

func (s *Uint32Stream) Max() *Uint32Stream {
	started := false
	var max uint32
	return FromUint32Observable(MapUint322Uint32ObserveDirect(s, func(next uint32, err error, complete bool, observer Uint32Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(max)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(max)
			}
			observer.Complete()
		default:
			if started {
				if max <= next {
					max = next
				}
			} else {
				max = next
				started = true
			}
		}
	}))
}

type MappingUint322BoolFunc func(next uint32, err error, complete bool, observer BoolObserver)
type MappingUint322BoolFuncFactory func(observer BoolObserver) MappingUint322BoolFunc

type MappingUint322BoolObservable struct {
	parent Uint32Observable
	mapper MappingUint322BoolFuncFactory
}

func (f *MappingUint322BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322BoolObservable(parent Uint32Observable, mapper MappingUint322BoolFuncFactory) BoolObservable {
	return &MappingUint322BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322BoolObserveDirect(parent Uint32Observable, mapper MappingUint322BoolFunc) BoolObservable {
	return MapUint322BoolObservable(parent, func(BoolObserver) MappingUint322BoolFunc {
		return mapper
	})
}

func MapUint322BoolObserveNext(parent Uint32Observable, mapper func(uint32) bool) BoolObservable {
	return MapUint322BoolObservable(parent, func(BoolObserver) MappingUint322BoolFunc {
		return func(next uint32, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Bool struct {
	parent Uint32Observable
	mapper func(uint32) BoolObservable
}

func (f *flatMapUint322Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *Uint32Stream) MapBool(f func(uint32) bool) *BoolStream {
	return FromBoolObservable(MapUint322BoolObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapBool(f func(uint32) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapUint322Bool{s, f}}
}

type MappingUint322RuneFunc func(next uint32, err error, complete bool, observer RuneObserver)
type MappingUint322RuneFuncFactory func(observer RuneObserver) MappingUint322RuneFunc

type MappingUint322RuneObservable struct {
	parent Uint32Observable
	mapper MappingUint322RuneFuncFactory
}

func (f *MappingUint322RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322RuneObservable(parent Uint32Observable, mapper MappingUint322RuneFuncFactory) RuneObservable {
	return &MappingUint322RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322RuneObserveDirect(parent Uint32Observable, mapper MappingUint322RuneFunc) RuneObservable {
	return MapUint322RuneObservable(parent, func(RuneObserver) MappingUint322RuneFunc {
		return mapper
	})
}

func MapUint322RuneObserveNext(parent Uint32Observable, mapper func(uint32) rune) RuneObservable {
	return MapUint322RuneObservable(parent, func(RuneObserver) MappingUint322RuneFunc {
		return func(next uint32, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Rune struct {
	parent Uint32Observable
	mapper func(uint32) RuneObservable
}

func (f *flatMapUint322Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *Uint32Stream) MapRune(f func(uint32) rune) *RuneStream {
	return FromRuneObservable(MapUint322RuneObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapRune(f func(uint32) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapUint322Rune{s, f}}
}

type MappingUint322ByteFunc func(next uint32, err error, complete bool, observer ByteObserver)
type MappingUint322ByteFuncFactory func(observer ByteObserver) MappingUint322ByteFunc

type MappingUint322ByteObservable struct {
	parent Uint32Observable
	mapper MappingUint322ByteFuncFactory
}

func (f *MappingUint322ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322ByteObservable(parent Uint32Observable, mapper MappingUint322ByteFuncFactory) ByteObservable {
	return &MappingUint322ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322ByteObserveDirect(parent Uint32Observable, mapper MappingUint322ByteFunc) ByteObservable {
	return MapUint322ByteObservable(parent, func(ByteObserver) MappingUint322ByteFunc {
		return mapper
	})
}

func MapUint322ByteObserveNext(parent Uint32Observable, mapper func(uint32) byte) ByteObservable {
	return MapUint322ByteObservable(parent, func(ByteObserver) MappingUint322ByteFunc {
		return func(next uint32, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Byte struct {
	parent Uint32Observable
	mapper func(uint32) ByteObservable
}

func (f *flatMapUint322Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *Uint32Stream) MapByte(f func(uint32) byte) *ByteStream {
	return FromByteObservable(MapUint322ByteObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapByte(f func(uint32) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapUint322Byte{s, f}}
}

type MappingUint322StringFunc func(next uint32, err error, complete bool, observer StringObserver)
type MappingUint322StringFuncFactory func(observer StringObserver) MappingUint322StringFunc

type MappingUint322StringObservable struct {
	parent Uint32Observable
	mapper MappingUint322StringFuncFactory
}

func (f *MappingUint322StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322StringObservable(parent Uint32Observable, mapper MappingUint322StringFuncFactory) StringObservable {
	return &MappingUint322StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322StringObserveDirect(parent Uint32Observable, mapper MappingUint322StringFunc) StringObservable {
	return MapUint322StringObservable(parent, func(StringObserver) MappingUint322StringFunc {
		return mapper
	})
}

func MapUint322StringObserveNext(parent Uint32Observable, mapper func(uint32) string) StringObservable {
	return MapUint322StringObservable(parent, func(StringObserver) MappingUint322StringFunc {
		return func(next uint32, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322String struct {
	parent Uint32Observable
	mapper func(uint32) StringObservable
}

func (f *flatMapUint322String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *Uint32Stream) MapString(f func(uint32) string) *StringStream {
	return FromStringObservable(MapUint322StringObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapString(f func(uint32) StringObservable) *StringStream {
	return &StringStream{&flatMapUint322String{s, f}}
}

type MappingUint322UintFunc func(next uint32, err error, complete bool, observer UintObserver)
type MappingUint322UintFuncFactory func(observer UintObserver) MappingUint322UintFunc

type MappingUint322UintObservable struct {
	parent Uint32Observable
	mapper MappingUint322UintFuncFactory
}

func (f *MappingUint322UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322UintObservable(parent Uint32Observable, mapper MappingUint322UintFuncFactory) UintObservable {
	return &MappingUint322UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322UintObserveDirect(parent Uint32Observable, mapper MappingUint322UintFunc) UintObservable {
	return MapUint322UintObservable(parent, func(UintObserver) MappingUint322UintFunc {
		return mapper
	})
}

func MapUint322UintObserveNext(parent Uint32Observable, mapper func(uint32) uint) UintObservable {
	return MapUint322UintObservable(parent, func(UintObserver) MappingUint322UintFunc {
		return func(next uint32, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Uint struct {
	parent Uint32Observable
	mapper func(uint32) UintObservable
}

func (f *flatMapUint322Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *Uint32Stream) MapUint(f func(uint32) uint) *UintStream {
	return FromUintObservable(MapUint322UintObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapUint(f func(uint32) UintObservable) *UintStream {
	return &UintStream{&flatMapUint322Uint{s, f}}
}

type MappingUint322IntFunc func(next uint32, err error, complete bool, observer IntObserver)
type MappingUint322IntFuncFactory func(observer IntObserver) MappingUint322IntFunc

type MappingUint322IntObservable struct {
	parent Uint32Observable
	mapper MappingUint322IntFuncFactory
}

func (f *MappingUint322IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322IntObservable(parent Uint32Observable, mapper MappingUint322IntFuncFactory) IntObservable {
	return &MappingUint322IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322IntObserveDirect(parent Uint32Observable, mapper MappingUint322IntFunc) IntObservable {
	return MapUint322IntObservable(parent, func(IntObserver) MappingUint322IntFunc {
		return mapper
	})
}

func MapUint322IntObserveNext(parent Uint32Observable, mapper func(uint32) int) IntObservable {
	return MapUint322IntObservable(parent, func(IntObserver) MappingUint322IntFunc {
		return func(next uint32, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Int struct {
	parent Uint32Observable
	mapper func(uint32) IntObservable
}

func (f *flatMapUint322Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *Uint32Stream) MapInt(f func(uint32) int) *IntStream {
	return FromIntObservable(MapUint322IntObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapInt(f func(uint32) IntObservable) *IntStream {
	return &IntStream{&flatMapUint322Int{s, f}}
}

type MappingUint322Uint8Func func(next uint32, err error, complete bool, observer Uint8Observer)
type MappingUint322Uint8FuncFactory func(observer Uint8Observer) MappingUint322Uint8Func

type MappingUint322Uint8Observable struct {
	parent Uint32Observable
	mapper MappingUint322Uint8FuncFactory
}

func (f *MappingUint322Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322Uint8Observable(parent Uint32Observable, mapper MappingUint322Uint8FuncFactory) Uint8Observable {
	return &MappingUint322Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322Uint8ObserveDirect(parent Uint32Observable, mapper MappingUint322Uint8Func) Uint8Observable {
	return MapUint322Uint8Observable(parent, func(Uint8Observer) MappingUint322Uint8Func {
		return mapper
	})
}

func MapUint322Uint8ObserveNext(parent Uint32Observable, mapper func(uint32) uint8) Uint8Observable {
	return MapUint322Uint8Observable(parent, func(Uint8Observer) MappingUint322Uint8Func {
		return func(next uint32, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Uint8 struct {
	parent Uint32Observable
	mapper func(uint32) Uint8Observable
}

func (f *flatMapUint322Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *Uint32Stream) MapUint8(f func(uint32) uint8) *Uint8Stream {
	return FromUint8Observable(MapUint322Uint8ObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapUint8(f func(uint32) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapUint322Uint8{s, f}}
}

type MappingUint322Int8Func func(next uint32, err error, complete bool, observer Int8Observer)
type MappingUint322Int8FuncFactory func(observer Int8Observer) MappingUint322Int8Func

type MappingUint322Int8Observable struct {
	parent Uint32Observable
	mapper MappingUint322Int8FuncFactory
}

func (f *MappingUint322Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322Int8Observable(parent Uint32Observable, mapper MappingUint322Int8FuncFactory) Int8Observable {
	return &MappingUint322Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322Int8ObserveDirect(parent Uint32Observable, mapper MappingUint322Int8Func) Int8Observable {
	return MapUint322Int8Observable(parent, func(Int8Observer) MappingUint322Int8Func {
		return mapper
	})
}

func MapUint322Int8ObserveNext(parent Uint32Observable, mapper func(uint32) int8) Int8Observable {
	return MapUint322Int8Observable(parent, func(Int8Observer) MappingUint322Int8Func {
		return func(next uint32, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Int8 struct {
	parent Uint32Observable
	mapper func(uint32) Int8Observable
}

func (f *flatMapUint322Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *Uint32Stream) MapInt8(f func(uint32) int8) *Int8Stream {
	return FromInt8Observable(MapUint322Int8ObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapInt8(f func(uint32) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapUint322Int8{s, f}}
}

type MappingUint322Uint16Func func(next uint32, err error, complete bool, observer Uint16Observer)
type MappingUint322Uint16FuncFactory func(observer Uint16Observer) MappingUint322Uint16Func

type MappingUint322Uint16Observable struct {
	parent Uint32Observable
	mapper MappingUint322Uint16FuncFactory
}

func (f *MappingUint322Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322Uint16Observable(parent Uint32Observable, mapper MappingUint322Uint16FuncFactory) Uint16Observable {
	return &MappingUint322Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322Uint16ObserveDirect(parent Uint32Observable, mapper MappingUint322Uint16Func) Uint16Observable {
	return MapUint322Uint16Observable(parent, func(Uint16Observer) MappingUint322Uint16Func {
		return mapper
	})
}

func MapUint322Uint16ObserveNext(parent Uint32Observable, mapper func(uint32) uint16) Uint16Observable {
	return MapUint322Uint16Observable(parent, func(Uint16Observer) MappingUint322Uint16Func {
		return func(next uint32, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Uint16 struct {
	parent Uint32Observable
	mapper func(uint32) Uint16Observable
}

func (f *flatMapUint322Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *Uint32Stream) MapUint16(f func(uint32) uint16) *Uint16Stream {
	return FromUint16Observable(MapUint322Uint16ObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapUint16(f func(uint32) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapUint322Uint16{s, f}}
}

type MappingUint322Int16Func func(next uint32, err error, complete bool, observer Int16Observer)
type MappingUint322Int16FuncFactory func(observer Int16Observer) MappingUint322Int16Func

type MappingUint322Int16Observable struct {
	parent Uint32Observable
	mapper MappingUint322Int16FuncFactory
}

func (f *MappingUint322Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322Int16Observable(parent Uint32Observable, mapper MappingUint322Int16FuncFactory) Int16Observable {
	return &MappingUint322Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322Int16ObserveDirect(parent Uint32Observable, mapper MappingUint322Int16Func) Int16Observable {
	return MapUint322Int16Observable(parent, func(Int16Observer) MappingUint322Int16Func {
		return mapper
	})
}

func MapUint322Int16ObserveNext(parent Uint32Observable, mapper func(uint32) int16) Int16Observable {
	return MapUint322Int16Observable(parent, func(Int16Observer) MappingUint322Int16Func {
		return func(next uint32, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Int16 struct {
	parent Uint32Observable
	mapper func(uint32) Int16Observable
}

func (f *flatMapUint322Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *Uint32Stream) MapInt16(f func(uint32) int16) *Int16Stream {
	return FromInt16Observable(MapUint322Int16ObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapInt16(f func(uint32) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapUint322Int16{s, f}}
}

type MappingUint322Uint32Func func(next uint32, err error, complete bool, observer Uint32Observer)
type MappingUint322Uint32FuncFactory func(observer Uint32Observer) MappingUint322Uint32Func

type MappingUint322Uint32Observable struct {
	parent Uint32Observable
	mapper MappingUint322Uint32FuncFactory
}

func (f *MappingUint322Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322Uint32Observable(parent Uint32Observable, mapper MappingUint322Uint32FuncFactory) Uint32Observable {
	return &MappingUint322Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322Uint32ObserveDirect(parent Uint32Observable, mapper MappingUint322Uint32Func) Uint32Observable {
	return MapUint322Uint32Observable(parent, func(Uint32Observer) MappingUint322Uint32Func {
		return mapper
	})
}

func MapUint322Uint32ObserveNext(parent Uint32Observable, mapper func(uint32) uint32) Uint32Observable {
	return MapUint322Uint32Observable(parent, func(Uint32Observer) MappingUint322Uint32Func {
		return func(next uint32, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Uint32 struct {
	parent Uint32Observable
	mapper func(uint32) Uint32Observable
}

func (f *flatMapUint322Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *Uint32Stream) Map(f func(uint32) uint32) *Uint32Stream {
	return FromUint32Observable(MapUint322Uint32ObserveNext(s, f))
}

func (s *Uint32Stream) FlatMap(f func(uint32) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapUint322Uint32{s, f}}
}

type MappingUint322Int32Func func(next uint32, err error, complete bool, observer Int32Observer)
type MappingUint322Int32FuncFactory func(observer Int32Observer) MappingUint322Int32Func

type MappingUint322Int32Observable struct {
	parent Uint32Observable
	mapper MappingUint322Int32FuncFactory
}

func (f *MappingUint322Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322Int32Observable(parent Uint32Observable, mapper MappingUint322Int32FuncFactory) Int32Observable {
	return &MappingUint322Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322Int32ObserveDirect(parent Uint32Observable, mapper MappingUint322Int32Func) Int32Observable {
	return MapUint322Int32Observable(parent, func(Int32Observer) MappingUint322Int32Func {
		return mapper
	})
}

func MapUint322Int32ObserveNext(parent Uint32Observable, mapper func(uint32) int32) Int32Observable {
	return MapUint322Int32Observable(parent, func(Int32Observer) MappingUint322Int32Func {
		return func(next uint32, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Int32 struct {
	parent Uint32Observable
	mapper func(uint32) Int32Observable
}

func (f *flatMapUint322Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *Uint32Stream) MapInt32(f func(uint32) int32) *Int32Stream {
	return FromInt32Observable(MapUint322Int32ObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapInt32(f func(uint32) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapUint322Int32{s, f}}
}

type MappingUint322Uint64Func func(next uint32, err error, complete bool, observer Uint64Observer)
type MappingUint322Uint64FuncFactory func(observer Uint64Observer) MappingUint322Uint64Func

type MappingUint322Uint64Observable struct {
	parent Uint32Observable
	mapper MappingUint322Uint64FuncFactory
}

func (f *MappingUint322Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322Uint64Observable(parent Uint32Observable, mapper MappingUint322Uint64FuncFactory) Uint64Observable {
	return &MappingUint322Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322Uint64ObserveDirect(parent Uint32Observable, mapper MappingUint322Uint64Func) Uint64Observable {
	return MapUint322Uint64Observable(parent, func(Uint64Observer) MappingUint322Uint64Func {
		return mapper
	})
}

func MapUint322Uint64ObserveNext(parent Uint32Observable, mapper func(uint32) uint64) Uint64Observable {
	return MapUint322Uint64Observable(parent, func(Uint64Observer) MappingUint322Uint64Func {
		return func(next uint32, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Uint64 struct {
	parent Uint32Observable
	mapper func(uint32) Uint64Observable
}

func (f *flatMapUint322Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *Uint32Stream) MapUint64(f func(uint32) uint64) *Uint64Stream {
	return FromUint64Observable(MapUint322Uint64ObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapUint64(f func(uint32) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapUint322Uint64{s, f}}
}

type MappingUint322Int64Func func(next uint32, err error, complete bool, observer Int64Observer)
type MappingUint322Int64FuncFactory func(observer Int64Observer) MappingUint322Int64Func

type MappingUint322Int64Observable struct {
	parent Uint32Observable
	mapper MappingUint322Int64FuncFactory
}

func (f *MappingUint322Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322Int64Observable(parent Uint32Observable, mapper MappingUint322Int64FuncFactory) Int64Observable {
	return &MappingUint322Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322Int64ObserveDirect(parent Uint32Observable, mapper MappingUint322Int64Func) Int64Observable {
	return MapUint322Int64Observable(parent, func(Int64Observer) MappingUint322Int64Func {
		return mapper
	})
}

func MapUint322Int64ObserveNext(parent Uint32Observable, mapper func(uint32) int64) Int64Observable {
	return MapUint322Int64Observable(parent, func(Int64Observer) MappingUint322Int64Func {
		return func(next uint32, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Int64 struct {
	parent Uint32Observable
	mapper func(uint32) Int64Observable
}

func (f *flatMapUint322Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *Uint32Stream) MapInt64(f func(uint32) int64) *Int64Stream {
	return FromInt64Observable(MapUint322Int64ObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapInt64(f func(uint32) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapUint322Int64{s, f}}
}

type MappingUint322Float32Func func(next uint32, err error, complete bool, observer Float32Observer)
type MappingUint322Float32FuncFactory func(observer Float32Observer) MappingUint322Float32Func

type MappingUint322Float32Observable struct {
	parent Uint32Observable
	mapper MappingUint322Float32FuncFactory
}

func (f *MappingUint322Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322Float32Observable(parent Uint32Observable, mapper MappingUint322Float32FuncFactory) Float32Observable {
	return &MappingUint322Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322Float32ObserveDirect(parent Uint32Observable, mapper MappingUint322Float32Func) Float32Observable {
	return MapUint322Float32Observable(parent, func(Float32Observer) MappingUint322Float32Func {
		return mapper
	})
}

func MapUint322Float32ObserveNext(parent Uint32Observable, mapper func(uint32) float32) Float32Observable {
	return MapUint322Float32Observable(parent, func(Float32Observer) MappingUint322Float32Func {
		return func(next uint32, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Float32 struct {
	parent Uint32Observable
	mapper func(uint32) Float32Observable
}

func (f *flatMapUint322Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *Uint32Stream) MapFloat32(f func(uint32) float32) *Float32Stream {
	return FromFloat32Observable(MapUint322Float32ObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapFloat32(f func(uint32) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapUint322Float32{s, f}}
}

type MappingUint322Float64Func func(next uint32, err error, complete bool, observer Float64Observer)
type MappingUint322Float64FuncFactory func(observer Float64Observer) MappingUint322Float64Func

type MappingUint322Float64Observable struct {
	parent Uint32Observable
	mapper MappingUint322Float64FuncFactory
}

func (f *MappingUint322Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322Float64Observable(parent Uint32Observable, mapper MappingUint322Float64FuncFactory) Float64Observable {
	return &MappingUint322Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322Float64ObserveDirect(parent Uint32Observable, mapper MappingUint322Float64Func) Float64Observable {
	return MapUint322Float64Observable(parent, func(Float64Observer) MappingUint322Float64Func {
		return mapper
	})
}

func MapUint322Float64ObserveNext(parent Uint32Observable, mapper func(uint32) float64) Float64Observable {
	return MapUint322Float64Observable(parent, func(Float64Observer) MappingUint322Float64Func {
		return func(next uint32, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Float64 struct {
	parent Uint32Observable
	mapper func(uint32) Float64Observable
}

func (f *flatMapUint322Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *Uint32Stream) MapFloat64(f func(uint32) float64) *Float64Stream {
	return FromFloat64Observable(MapUint322Float64ObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapFloat64(f func(uint32) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapUint322Float64{s, f}}
}

type MappingUint322Complex64Func func(next uint32, err error, complete bool, observer Complex64Observer)
type MappingUint322Complex64FuncFactory func(observer Complex64Observer) MappingUint322Complex64Func

type MappingUint322Complex64Observable struct {
	parent Uint32Observable
	mapper MappingUint322Complex64FuncFactory
}

func (f *MappingUint322Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322Complex64Observable(parent Uint32Observable, mapper MappingUint322Complex64FuncFactory) Complex64Observable {
	return &MappingUint322Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322Complex64ObserveDirect(parent Uint32Observable, mapper MappingUint322Complex64Func) Complex64Observable {
	return MapUint322Complex64Observable(parent, func(Complex64Observer) MappingUint322Complex64Func {
		return mapper
	})
}

func MapUint322Complex64ObserveNext(parent Uint32Observable, mapper func(uint32) complex64) Complex64Observable {
	return MapUint322Complex64Observable(parent, func(Complex64Observer) MappingUint322Complex64Func {
		return func(next uint32, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Complex64 struct {
	parent Uint32Observable
	mapper func(uint32) Complex64Observable
}

func (f *flatMapUint322Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *Uint32Stream) MapComplex64(f func(uint32) complex64) *Complex64Stream {
	return FromComplex64Observable(MapUint322Complex64ObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapComplex64(f func(uint32) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapUint322Complex64{s, f}}
}

type MappingUint322Complex128Func func(next uint32, err error, complete bool, observer Complex128Observer)
type MappingUint322Complex128FuncFactory func(observer Complex128Observer) MappingUint322Complex128Func

type MappingUint322Complex128Observable struct {
	parent Uint32Observable
	mapper MappingUint322Complex128FuncFactory
}

func (f *MappingUint322Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322Complex128Observable(parent Uint32Observable, mapper MappingUint322Complex128FuncFactory) Complex128Observable {
	return &MappingUint322Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322Complex128ObserveDirect(parent Uint32Observable, mapper MappingUint322Complex128Func) Complex128Observable {
	return MapUint322Complex128Observable(parent, func(Complex128Observer) MappingUint322Complex128Func {
		return mapper
	})
}

func MapUint322Complex128ObserveNext(parent Uint32Observable, mapper func(uint32) complex128) Complex128Observable {
	return MapUint322Complex128Observable(parent, func(Complex128Observer) MappingUint322Complex128Func {
		return func(next uint32, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Complex128 struct {
	parent Uint32Observable
	mapper func(uint32) Complex128Observable
}

func (f *flatMapUint322Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *Uint32Stream) MapComplex128(f func(uint32) complex128) *Complex128Stream {
	return FromComplex128Observable(MapUint322Complex128ObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapComplex128(f func(uint32) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapUint322Complex128{s, f}}
}

type MappingUint322TimeFunc func(next uint32, err error, complete bool, observer TimeObserver)
type MappingUint322TimeFuncFactory func(observer TimeObserver) MappingUint322TimeFunc

type MappingUint322TimeObservable struct {
	parent Uint32Observable
	mapper MappingUint322TimeFuncFactory
}

func (f *MappingUint322TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322TimeObservable(parent Uint32Observable, mapper MappingUint322TimeFuncFactory) TimeObservable {
	return &MappingUint322TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322TimeObserveDirect(parent Uint32Observable, mapper MappingUint322TimeFunc) TimeObservable {
	return MapUint322TimeObservable(parent, func(TimeObserver) MappingUint322TimeFunc {
		return mapper
	})
}

func MapUint322TimeObserveNext(parent Uint32Observable, mapper func(uint32) time.Time) TimeObservable {
	return MapUint322TimeObservable(parent, func(TimeObserver) MappingUint322TimeFunc {
		return func(next uint32, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Time struct {
	parent Uint32Observable
	mapper func(uint32) TimeObservable
}

func (f *flatMapUint322Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *Uint32Stream) MapTime(f func(uint32) time.Time) *TimeStream {
	return FromTimeObservable(MapUint322TimeObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapTime(f func(uint32) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapUint322Time{s, f}}
}

type MappingUint322DurationFunc func(next uint32, err error, complete bool, observer DurationObserver)
type MappingUint322DurationFuncFactory func(observer DurationObserver) MappingUint322DurationFunc

type MappingUint322DurationObservable struct {
	parent Uint32Observable
	mapper MappingUint322DurationFuncFactory
}

func (f *MappingUint322DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint322DurationObservable(parent Uint32Observable, mapper MappingUint322DurationFuncFactory) DurationObservable {
	return &MappingUint322DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint322DurationObserveDirect(parent Uint32Observable, mapper MappingUint322DurationFunc) DurationObservable {
	return MapUint322DurationObservable(parent, func(DurationObserver) MappingUint322DurationFunc {
		return mapper
	})
}

func MapUint322DurationObserveNext(parent Uint32Observable, mapper func(uint32) time.Duration) DurationObservable {
	return MapUint322DurationObservable(parent, func(DurationObserver) MappingUint322DurationFunc {
		return func(next uint32, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint322Duration struct {
	parent Uint32Observable
	mapper func(uint32) DurationObservable
}

func (f *flatMapUint322Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint32ObserverFunc(func(next uint32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *Uint32Stream) MapDuration(f func(uint32) time.Duration) *DurationStream {
	return FromDurationObservable(MapUint322DurationObserveNext(s, f))
}

func (s *Uint32Stream) FlatMapDuration(f func(uint32) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapUint322Duration{s, f}}
}

type Int32Observer interface {
	Next(int32)
	TerminationObserver
}

// A Int32Subscriber represents a subscribed Int32Observer.
type Int32Subscriber interface {
	Subscription
	Int32Observer
}

type implInt32Subscriber struct {
	Subscription
	Int32Observer
}

func Int32ObserverAsGenericObserver(observer Int32Observer) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(int32))
		}
	})
}

func GenericObserverAsInt32Observer(observer GenericObserver) Int32Observer {
	return Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type Int32ObservableFactory func(observer Int32Observer, subscription Subscription)

func (f Int32ObservableFactory) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateInt32 calls f(observer, subscription) to produce values for a stream.
func CreateInt32(f func(observer Int32Observer, subscription Subscription)) *Int32Stream {
	return FromInt32Observable(Int32ObservableFactory(f))
}

// Repeat value count times.
func RepeatInt32(value int32, count int) *Int32Stream {
	return CreateInt32(func(observer Int32Observer, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartInt32 is designed to be used with functions that return a
// (int32, error) tuple.
//
// If the error is non-nil the returned Int32Stream will be that error,
// otherwise it will be a single-value stream of int32.
func StartInt32(f func() (int32, error)) *Int32Stream {
	return CreateInt32(func(observer Int32Observer, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughInt32(next int32, err error, complete bool, observer Int32Observer) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroInt32 = *new(int32)

type Int32ObserverFunc func(int32, error, bool)

func (f Int32ObserverFunc) Next(next int32) { f(next, nil, false) }
func (f Int32ObserverFunc) Error(err error) { f(zeroInt32, err, false) }
func (f Int32ObserverFunc) Complete()       { f(zeroInt32, nil, true) }

type Int32Observable interface {
	Subscribe(Int32Observer) Subscription
}

// Convert a GenericObservableFilter to a Int32Observable
func (f GenericObservableFilterFactory) Int32(parent Int32Observable) Int32Observable {
	return MapInt322Int32Observable(parent, func(observer Int32Observer) MappingInt322Int32Func {
		gobserver := Int32ObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next int32, err error, complete bool, observer Int32Observer) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverInt32() *Int32Stream {
	return CreateInt32(func(observer Int32Observer, subscription Subscription) {})
}

func EmptyInt32() *Int32Stream {
	return CreateInt32(func(observer Int32Observer, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowInt32(err error) *Int32Stream {
	return CreateInt32(func(observer Int32Observer, subscription Subscription) {
		observer.Error(err)
	})
}

func FromInt32Array(array []int32) *Int32Stream {
	return CreateInt32(func(observer Int32Observer, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromInt32s(array ...int32) *Int32Stream {
	return FromInt32Array(array)
}

func JustInt32(element int32) *Int32Stream {
	return FromInt32Array([]int32{element})
}

func MergeInt32(observables ...Int32Observable) *Int32Stream {
	if len(observables) == 0 {
		return EmptyInt32()
	}
	return (&Int32Stream{observables[0]}).Merge(observables[1:]...)
}

func MergeInt32DelayError(observables ...Int32Observable) *Int32Stream {
	if len(observables) == 0 {
		return EmptyInt32()
	}
	return (&Int32Stream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromInt32Channel(ch <-chan int32) *Int32Stream {
	return CreateInt32(func(observer Int32Observer, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type Int32Stream struct {
	Int32Observable
}

func FromInt32Observable(observable Int32Observable) *Int32Stream {
	return &Int32Stream{observable}
}

func (s *Int32Stream) SubscribeFunc(f func(int32, error, bool)) Subscription {
	return s.Subscribe(Int32ObserverFunc(f))
}

func (s *Int32Stream) SubscribeNext(f func(v int32)) Subscription {
	return s.SubscribeFunc(func(next int32, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *Int32Stream) Distinct() *Int32Stream {
	return FromInt32Observable(distinctFilter().Int32(s))
}

// ElementAt yields the Nth element of the stream.
func (s *Int32Stream) ElementAt(n int) *Int32Stream {
	return FromInt32Observable(elementAtFilter(n).Int32(s))
}

// Filter elements in the stream on a function.
func (s *Int32Stream) Filter(f func(int32) bool) *Int32Stream {
	return FromInt32Observable(filterFilter(func(v interface{}) bool { return f(v.(int32)) }).Int32(s))
}

// Last returns just the first element of the stream.
func (s *Int32Stream) First() *Int32Stream {
	return FromInt32Observable(firstFilter().Int32(s))
}

// Last returns just the last element of the stream.
func (s *Int32Stream) Last() *Int32Stream {
	return FromInt32Observable(lastFilter().Int32(s))
}

// SkipLast skips the first N elements of the stream.
func (s *Int32Stream) Skip(n int) *Int32Stream {
	return FromInt32Observable(skipFilter(n).Int32(s))
}

// SkipLast skips the last N elements of the stream.
func (s *Int32Stream) SkipLast(n int) *Int32Stream {
	return FromInt32Observable(skipLastFilter(n).Int32(s))
}

// Take returns just the first N elements of the stream.
func (s *Int32Stream) Take(n int) *Int32Stream {
	return FromInt32Observable(takeFilter(n).Int32(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *Int32Stream) TakeLast(n int) *Int32Stream {
	return FromInt32Observable(takeLastFilter(n).Int32(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *Int32Stream) IgnoreElements() *Int32Stream {
	return FromInt32Observable(ignoreElementsFilter().Int32(s))
}

func (s *Int32Stream) Replay(size int, duration time.Duration) *Int32Stream {
	return FromInt32Observable(replayFilter(size, duration).Int32(s))
}

func (s *Int32Stream) Sample(duration time.Duration) *Int32Stream {
	return FromInt32Observable(sampleFilter(duration).Int32(s))
}

func (s *Int32Stream) Debounce(duration time.Duration) *Int32Stream {
	return FromInt32Observable(debounceFilter(duration).Int32(s))
}

// Wait for completion of the stream and return any error.
func (s *Int32Stream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeInt32Subscriber(observer Int32Observer) Int32Subscriber {
	if subscriber, ok := observer.(Int32Subscriber); ok {
		return subscriber
	}
	return &implInt32Subscriber{NewGenericSubscription(), observer}
}

type concatInt32Subscriber struct {
	observable  int
	observer    Int32Observer
	observables []Int32Observable
	Subscription
}

func (c *concatInt32Subscriber) Next(next int32) {
	c.observer.Next(next)
}

func (c *concatInt32Subscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatInt32Subscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatInt32Observable struct {
	observables []Int32Observable
}

func (m *concatInt32Observable) Subscribe(observer Int32Observer) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatInt32Subscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *Int32Stream) Concat(observables ...Int32Observable) *Int32Stream {
	return &Int32Stream{&concatInt32Observable{append([]Int32Observable{s}, observables...)}}
}

type mergeInt32Observable struct {
	delayError  bool
	observables []Int32Observable
}

func (m *mergeInt32Observable) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next int32, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(Int32ObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *Int32Stream) Merge(other ...Int32Observable) *Int32Stream {
	if len(other) == 0 {
		return s
	}
	return &Int32Stream{&mergeInt32Observable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *Int32Stream) MergeDelayError(other ...Int32Observable) *Int32Stream {
	if len(other) == 0 {
		return s
	}
	return &Int32Stream{&mergeInt32Observable{true, append(other, s)}}
}

type catchInt32Observable struct {
	parent Int32Observable
	catch  Int32Observable
}

func (r *catchInt32Observable) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	run := func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(Int32ObserverFunc(run))
	return subscription
}

func (s *Int32Stream) Catch(catch Int32Observable) *Int32Stream {
	return &Int32Stream{&catchInt32Observable{s, catch}}
}

type retryInt32Observable struct {
	observable Int32Observable
}

type retryInt32Observer struct {
	observable Int32Observable
	observer   Int32Observer
}

func (r *retryInt32Observer) retry(next int32, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(Int32ObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryInt32Observable) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryInt32Observer{r.observable, observer}
	r.observable.Subscribe(Int32ObserverFunc(ro.retry))
	return subscription
}

func (s *Int32Stream) Retry() *Int32Stream {
	return &Int32Stream{&retryInt32Observable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *Int32Stream) Do(f func(next int32)) *Int32Stream {
	return FromInt32Observable(MapInt322Int32ObserveNext(s, func(next int32) int32 {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *Int32Stream) DoOnError(f func(err error)) *Int32Stream {
	return FromInt32Observable(MapInt322Int32ObserveDirect(s, func(next int32, err error, complete bool, observer Int32Observer) {
		if err != nil {
			f(err)
		}
		PassthroughInt32(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *Int32Stream) DoOnComplete(f func()) *Int32Stream {
	return FromInt32Observable(MapInt322Int32ObserveDirect(s, func(next int32, err error, complete bool, observer Int32Observer) {
		if complete {
			f()
		}
		PassthroughInt32(next, err, complete, observer)
	}))
}

func (s *Int32Stream) Reduce(initial int32, reducer func(int32, int32) int32) *Int32Stream {
	value := initial
	return FromInt32Observable(MapInt322Int32ObserveDirect(s, func(next int32, err error, complete bool, observer Int32Observer) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *Int32Stream) Scan(initial int32, f func(int32, int32) int32) *Int32Stream {
	value := initial
	return FromInt32Observable(MapInt322Int32ObserveDirect(s, func(next int32, err error, complete bool, observer Int32Observer) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutInt32 struct {
	parent  Int32Observable
	timeout time.Duration
}

func (t *timeoutInt32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *Int32Stream) Timeout(timeout time.Duration) *Int32Stream {
	return &Int32Stream{&timeoutInt32{s, timeout}}
}

type forkedInt32Stream struct {
	lock      sync.Mutex
	parent    Int32Observable
	observers []Int32Observer
}

func (f *forkedInt32Stream) Subscribe(observer Int32Observer) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *Int32Stream) Fork() *Int32Stream {
	f := &forkedInt32Stream{parent: s}
	go s.Subscribe(Int32ObserverFunc(func(n int32, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &Int32Stream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *Int32Stream) ToOneWithError() (int32, error) {
	valuech := make(chan int32, 1)
	errch := make(chan error, 1)
	FromInt32Observable(oneFilter().Int32(s)).SubscribeFunc(func(next int32, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroInt32, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *Int32Stream) ToOne() int32 {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *Int32Stream) ToArrayWithError() ([]int32, error) {
	array := []int32{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *Int32Stream) ToArray() []int32 {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *Int32Stream) ToChannelWithError() (<-chan int32, <-chan error) {
	ch := make(chan int32, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *Int32Stream) ToChannel() <-chan int32 {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *Int32Stream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapInt322IntObserveDirect(s, func(next int32, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

func (s *Int32Stream) Average() *Int32Stream {
	var sum int32
	var count int32
	return FromInt32Observable(MapInt322Int32ObserveDirect(s, func(next int32, err error, complete bool, observer Int32Observer) {
		switch {
		case err != nil:
			observer.Next(sum / count)
			observer.Error(err)
		case complete:
			observer.Next(sum / count)
			observer.Complete()
		default:
			sum += next
			count++
		}
	}))
}

func (s *Int32Stream) Sum() *Int32Stream {
	var sum int32
	return FromInt32Observable(MapInt322Int32ObserveDirect(s, func(next int32, err error, complete bool, observer Int32Observer) {
		switch {
		case err != nil:
			observer.Next(sum)
			observer.Error(err)
		case complete:
			observer.Next(sum)
			observer.Complete()
		default:
			sum += next
		}
	}))
}

func (s *Int32Stream) Min() *Int32Stream {
	started := false
	var min int32
	return FromInt32Observable(MapInt322Int32ObserveDirect(s, func(next int32, err error, complete bool, observer Int32Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(min)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(min)
			}
			observer.Complete()
		default:
			if started {
				if min > next {
					min = next
				}
			} else {
				min = next
				started = true
			}
		}
	}))
}

func (s *Int32Stream) Max() *Int32Stream {
	started := false
	var max int32
	return FromInt32Observable(MapInt322Int32ObserveDirect(s, func(next int32, err error, complete bool, observer Int32Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(max)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(max)
			}
			observer.Complete()
		default:
			if started {
				if max <= next {
					max = next
				}
			} else {
				max = next
				started = true
			}
		}
	}))
}

type MappingInt322BoolFunc func(next int32, err error, complete bool, observer BoolObserver)
type MappingInt322BoolFuncFactory func(observer BoolObserver) MappingInt322BoolFunc

type MappingInt322BoolObservable struct {
	parent Int32Observable
	mapper MappingInt322BoolFuncFactory
}

func (f *MappingInt322BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322BoolObservable(parent Int32Observable, mapper MappingInt322BoolFuncFactory) BoolObservable {
	return &MappingInt322BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322BoolObserveDirect(parent Int32Observable, mapper MappingInt322BoolFunc) BoolObservable {
	return MapInt322BoolObservable(parent, func(BoolObserver) MappingInt322BoolFunc {
		return mapper
	})
}

func MapInt322BoolObserveNext(parent Int32Observable, mapper func(int32) bool) BoolObservable {
	return MapInt322BoolObservable(parent, func(BoolObserver) MappingInt322BoolFunc {
		return func(next int32, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Bool struct {
	parent Int32Observable
	mapper func(int32) BoolObservable
}

func (f *flatMapInt322Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *Int32Stream) MapBool(f func(int32) bool) *BoolStream {
	return FromBoolObservable(MapInt322BoolObserveNext(s, f))
}

func (s *Int32Stream) FlatMapBool(f func(int32) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapInt322Bool{s, f}}
}

type MappingInt322RuneFunc func(next int32, err error, complete bool, observer RuneObserver)
type MappingInt322RuneFuncFactory func(observer RuneObserver) MappingInt322RuneFunc

type MappingInt322RuneObservable struct {
	parent Int32Observable
	mapper MappingInt322RuneFuncFactory
}

func (f *MappingInt322RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322RuneObservable(parent Int32Observable, mapper MappingInt322RuneFuncFactory) RuneObservable {
	return &MappingInt322RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322RuneObserveDirect(parent Int32Observable, mapper MappingInt322RuneFunc) RuneObservable {
	return MapInt322RuneObservable(parent, func(RuneObserver) MappingInt322RuneFunc {
		return mapper
	})
}

func MapInt322RuneObserveNext(parent Int32Observable, mapper func(int32) rune) RuneObservable {
	return MapInt322RuneObservable(parent, func(RuneObserver) MappingInt322RuneFunc {
		return func(next int32, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Rune struct {
	parent Int32Observable
	mapper func(int32) RuneObservable
}

func (f *flatMapInt322Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *Int32Stream) MapRune(f func(int32) rune) *RuneStream {
	return FromRuneObservable(MapInt322RuneObserveNext(s, f))
}

func (s *Int32Stream) FlatMapRune(f func(int32) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapInt322Rune{s, f}}
}

type MappingInt322ByteFunc func(next int32, err error, complete bool, observer ByteObserver)
type MappingInt322ByteFuncFactory func(observer ByteObserver) MappingInt322ByteFunc

type MappingInt322ByteObservable struct {
	parent Int32Observable
	mapper MappingInt322ByteFuncFactory
}

func (f *MappingInt322ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322ByteObservable(parent Int32Observable, mapper MappingInt322ByteFuncFactory) ByteObservable {
	return &MappingInt322ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322ByteObserveDirect(parent Int32Observable, mapper MappingInt322ByteFunc) ByteObservable {
	return MapInt322ByteObservable(parent, func(ByteObserver) MappingInt322ByteFunc {
		return mapper
	})
}

func MapInt322ByteObserveNext(parent Int32Observable, mapper func(int32) byte) ByteObservable {
	return MapInt322ByteObservable(parent, func(ByteObserver) MappingInt322ByteFunc {
		return func(next int32, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Byte struct {
	parent Int32Observable
	mapper func(int32) ByteObservable
}

func (f *flatMapInt322Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *Int32Stream) MapByte(f func(int32) byte) *ByteStream {
	return FromByteObservable(MapInt322ByteObserveNext(s, f))
}

func (s *Int32Stream) FlatMapByte(f func(int32) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapInt322Byte{s, f}}
}

type MappingInt322StringFunc func(next int32, err error, complete bool, observer StringObserver)
type MappingInt322StringFuncFactory func(observer StringObserver) MappingInt322StringFunc

type MappingInt322StringObservable struct {
	parent Int32Observable
	mapper MappingInt322StringFuncFactory
}

func (f *MappingInt322StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322StringObservable(parent Int32Observable, mapper MappingInt322StringFuncFactory) StringObservable {
	return &MappingInt322StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322StringObserveDirect(parent Int32Observable, mapper MappingInt322StringFunc) StringObservable {
	return MapInt322StringObservable(parent, func(StringObserver) MappingInt322StringFunc {
		return mapper
	})
}

func MapInt322StringObserveNext(parent Int32Observable, mapper func(int32) string) StringObservable {
	return MapInt322StringObservable(parent, func(StringObserver) MappingInt322StringFunc {
		return func(next int32, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322String struct {
	parent Int32Observable
	mapper func(int32) StringObservable
}

func (f *flatMapInt322String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *Int32Stream) MapString(f func(int32) string) *StringStream {
	return FromStringObservable(MapInt322StringObserveNext(s, f))
}

func (s *Int32Stream) FlatMapString(f func(int32) StringObservable) *StringStream {
	return &StringStream{&flatMapInt322String{s, f}}
}

type MappingInt322UintFunc func(next int32, err error, complete bool, observer UintObserver)
type MappingInt322UintFuncFactory func(observer UintObserver) MappingInt322UintFunc

type MappingInt322UintObservable struct {
	parent Int32Observable
	mapper MappingInt322UintFuncFactory
}

func (f *MappingInt322UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322UintObservable(parent Int32Observable, mapper MappingInt322UintFuncFactory) UintObservable {
	return &MappingInt322UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322UintObserveDirect(parent Int32Observable, mapper MappingInt322UintFunc) UintObservable {
	return MapInt322UintObservable(parent, func(UintObserver) MappingInt322UintFunc {
		return mapper
	})
}

func MapInt322UintObserveNext(parent Int32Observable, mapper func(int32) uint) UintObservable {
	return MapInt322UintObservable(parent, func(UintObserver) MappingInt322UintFunc {
		return func(next int32, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Uint struct {
	parent Int32Observable
	mapper func(int32) UintObservable
}

func (f *flatMapInt322Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *Int32Stream) MapUint(f func(int32) uint) *UintStream {
	return FromUintObservable(MapInt322UintObserveNext(s, f))
}

func (s *Int32Stream) FlatMapUint(f func(int32) UintObservable) *UintStream {
	return &UintStream{&flatMapInt322Uint{s, f}}
}

type MappingInt322IntFunc func(next int32, err error, complete bool, observer IntObserver)
type MappingInt322IntFuncFactory func(observer IntObserver) MappingInt322IntFunc

type MappingInt322IntObservable struct {
	parent Int32Observable
	mapper MappingInt322IntFuncFactory
}

func (f *MappingInt322IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322IntObservable(parent Int32Observable, mapper MappingInt322IntFuncFactory) IntObservable {
	return &MappingInt322IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322IntObserveDirect(parent Int32Observable, mapper MappingInt322IntFunc) IntObservable {
	return MapInt322IntObservable(parent, func(IntObserver) MappingInt322IntFunc {
		return mapper
	})
}

func MapInt322IntObserveNext(parent Int32Observable, mapper func(int32) int) IntObservable {
	return MapInt322IntObservable(parent, func(IntObserver) MappingInt322IntFunc {
		return func(next int32, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Int struct {
	parent Int32Observable
	mapper func(int32) IntObservable
}

func (f *flatMapInt322Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *Int32Stream) MapInt(f func(int32) int) *IntStream {
	return FromIntObservable(MapInt322IntObserveNext(s, f))
}

func (s *Int32Stream) FlatMapInt(f func(int32) IntObservable) *IntStream {
	return &IntStream{&flatMapInt322Int{s, f}}
}

type MappingInt322Uint8Func func(next int32, err error, complete bool, observer Uint8Observer)
type MappingInt322Uint8FuncFactory func(observer Uint8Observer) MappingInt322Uint8Func

type MappingInt322Uint8Observable struct {
	parent Int32Observable
	mapper MappingInt322Uint8FuncFactory
}

func (f *MappingInt322Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322Uint8Observable(parent Int32Observable, mapper MappingInt322Uint8FuncFactory) Uint8Observable {
	return &MappingInt322Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322Uint8ObserveDirect(parent Int32Observable, mapper MappingInt322Uint8Func) Uint8Observable {
	return MapInt322Uint8Observable(parent, func(Uint8Observer) MappingInt322Uint8Func {
		return mapper
	})
}

func MapInt322Uint8ObserveNext(parent Int32Observable, mapper func(int32) uint8) Uint8Observable {
	return MapInt322Uint8Observable(parent, func(Uint8Observer) MappingInt322Uint8Func {
		return func(next int32, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Uint8 struct {
	parent Int32Observable
	mapper func(int32) Uint8Observable
}

func (f *flatMapInt322Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *Int32Stream) MapUint8(f func(int32) uint8) *Uint8Stream {
	return FromUint8Observable(MapInt322Uint8ObserveNext(s, f))
}

func (s *Int32Stream) FlatMapUint8(f func(int32) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapInt322Uint8{s, f}}
}

type MappingInt322Int8Func func(next int32, err error, complete bool, observer Int8Observer)
type MappingInt322Int8FuncFactory func(observer Int8Observer) MappingInt322Int8Func

type MappingInt322Int8Observable struct {
	parent Int32Observable
	mapper MappingInt322Int8FuncFactory
}

func (f *MappingInt322Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322Int8Observable(parent Int32Observable, mapper MappingInt322Int8FuncFactory) Int8Observable {
	return &MappingInt322Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322Int8ObserveDirect(parent Int32Observable, mapper MappingInt322Int8Func) Int8Observable {
	return MapInt322Int8Observable(parent, func(Int8Observer) MappingInt322Int8Func {
		return mapper
	})
}

func MapInt322Int8ObserveNext(parent Int32Observable, mapper func(int32) int8) Int8Observable {
	return MapInt322Int8Observable(parent, func(Int8Observer) MappingInt322Int8Func {
		return func(next int32, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Int8 struct {
	parent Int32Observable
	mapper func(int32) Int8Observable
}

func (f *flatMapInt322Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *Int32Stream) MapInt8(f func(int32) int8) *Int8Stream {
	return FromInt8Observable(MapInt322Int8ObserveNext(s, f))
}

func (s *Int32Stream) FlatMapInt8(f func(int32) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapInt322Int8{s, f}}
}

type MappingInt322Uint16Func func(next int32, err error, complete bool, observer Uint16Observer)
type MappingInt322Uint16FuncFactory func(observer Uint16Observer) MappingInt322Uint16Func

type MappingInt322Uint16Observable struct {
	parent Int32Observable
	mapper MappingInt322Uint16FuncFactory
}

func (f *MappingInt322Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322Uint16Observable(parent Int32Observable, mapper MappingInt322Uint16FuncFactory) Uint16Observable {
	return &MappingInt322Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322Uint16ObserveDirect(parent Int32Observable, mapper MappingInt322Uint16Func) Uint16Observable {
	return MapInt322Uint16Observable(parent, func(Uint16Observer) MappingInt322Uint16Func {
		return mapper
	})
}

func MapInt322Uint16ObserveNext(parent Int32Observable, mapper func(int32) uint16) Uint16Observable {
	return MapInt322Uint16Observable(parent, func(Uint16Observer) MappingInt322Uint16Func {
		return func(next int32, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Uint16 struct {
	parent Int32Observable
	mapper func(int32) Uint16Observable
}

func (f *flatMapInt322Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *Int32Stream) MapUint16(f func(int32) uint16) *Uint16Stream {
	return FromUint16Observable(MapInt322Uint16ObserveNext(s, f))
}

func (s *Int32Stream) FlatMapUint16(f func(int32) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapInt322Uint16{s, f}}
}

type MappingInt322Int16Func func(next int32, err error, complete bool, observer Int16Observer)
type MappingInt322Int16FuncFactory func(observer Int16Observer) MappingInt322Int16Func

type MappingInt322Int16Observable struct {
	parent Int32Observable
	mapper MappingInt322Int16FuncFactory
}

func (f *MappingInt322Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322Int16Observable(parent Int32Observable, mapper MappingInt322Int16FuncFactory) Int16Observable {
	return &MappingInt322Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322Int16ObserveDirect(parent Int32Observable, mapper MappingInt322Int16Func) Int16Observable {
	return MapInt322Int16Observable(parent, func(Int16Observer) MappingInt322Int16Func {
		return mapper
	})
}

func MapInt322Int16ObserveNext(parent Int32Observable, mapper func(int32) int16) Int16Observable {
	return MapInt322Int16Observable(parent, func(Int16Observer) MappingInt322Int16Func {
		return func(next int32, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Int16 struct {
	parent Int32Observable
	mapper func(int32) Int16Observable
}

func (f *flatMapInt322Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *Int32Stream) MapInt16(f func(int32) int16) *Int16Stream {
	return FromInt16Observable(MapInt322Int16ObserveNext(s, f))
}

func (s *Int32Stream) FlatMapInt16(f func(int32) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapInt322Int16{s, f}}
}

type MappingInt322Uint32Func func(next int32, err error, complete bool, observer Uint32Observer)
type MappingInt322Uint32FuncFactory func(observer Uint32Observer) MappingInt322Uint32Func

type MappingInt322Uint32Observable struct {
	parent Int32Observable
	mapper MappingInt322Uint32FuncFactory
}

func (f *MappingInt322Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322Uint32Observable(parent Int32Observable, mapper MappingInt322Uint32FuncFactory) Uint32Observable {
	return &MappingInt322Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322Uint32ObserveDirect(parent Int32Observable, mapper MappingInt322Uint32Func) Uint32Observable {
	return MapInt322Uint32Observable(parent, func(Uint32Observer) MappingInt322Uint32Func {
		return mapper
	})
}

func MapInt322Uint32ObserveNext(parent Int32Observable, mapper func(int32) uint32) Uint32Observable {
	return MapInt322Uint32Observable(parent, func(Uint32Observer) MappingInt322Uint32Func {
		return func(next int32, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Uint32 struct {
	parent Int32Observable
	mapper func(int32) Uint32Observable
}

func (f *flatMapInt322Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *Int32Stream) MapUint32(f func(int32) uint32) *Uint32Stream {
	return FromUint32Observable(MapInt322Uint32ObserveNext(s, f))
}

func (s *Int32Stream) FlatMapUint32(f func(int32) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapInt322Uint32{s, f}}
}

type MappingInt322Int32Func func(next int32, err error, complete bool, observer Int32Observer)
type MappingInt322Int32FuncFactory func(observer Int32Observer) MappingInt322Int32Func

type MappingInt322Int32Observable struct {
	parent Int32Observable
	mapper MappingInt322Int32FuncFactory
}

func (f *MappingInt322Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322Int32Observable(parent Int32Observable, mapper MappingInt322Int32FuncFactory) Int32Observable {
	return &MappingInt322Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322Int32ObserveDirect(parent Int32Observable, mapper MappingInt322Int32Func) Int32Observable {
	return MapInt322Int32Observable(parent, func(Int32Observer) MappingInt322Int32Func {
		return mapper
	})
}

func MapInt322Int32ObserveNext(parent Int32Observable, mapper func(int32) int32) Int32Observable {
	return MapInt322Int32Observable(parent, func(Int32Observer) MappingInt322Int32Func {
		return func(next int32, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Int32 struct {
	parent Int32Observable
	mapper func(int32) Int32Observable
}

func (f *flatMapInt322Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *Int32Stream) Map(f func(int32) int32) *Int32Stream {
	return FromInt32Observable(MapInt322Int32ObserveNext(s, f))
}

func (s *Int32Stream) FlatMap(f func(int32) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapInt322Int32{s, f}}
}

type MappingInt322Uint64Func func(next int32, err error, complete bool, observer Uint64Observer)
type MappingInt322Uint64FuncFactory func(observer Uint64Observer) MappingInt322Uint64Func

type MappingInt322Uint64Observable struct {
	parent Int32Observable
	mapper MappingInt322Uint64FuncFactory
}

func (f *MappingInt322Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322Uint64Observable(parent Int32Observable, mapper MappingInt322Uint64FuncFactory) Uint64Observable {
	return &MappingInt322Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322Uint64ObserveDirect(parent Int32Observable, mapper MappingInt322Uint64Func) Uint64Observable {
	return MapInt322Uint64Observable(parent, func(Uint64Observer) MappingInt322Uint64Func {
		return mapper
	})
}

func MapInt322Uint64ObserveNext(parent Int32Observable, mapper func(int32) uint64) Uint64Observable {
	return MapInt322Uint64Observable(parent, func(Uint64Observer) MappingInt322Uint64Func {
		return func(next int32, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Uint64 struct {
	parent Int32Observable
	mapper func(int32) Uint64Observable
}

func (f *flatMapInt322Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *Int32Stream) MapUint64(f func(int32) uint64) *Uint64Stream {
	return FromUint64Observable(MapInt322Uint64ObserveNext(s, f))
}

func (s *Int32Stream) FlatMapUint64(f func(int32) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapInt322Uint64{s, f}}
}

type MappingInt322Int64Func func(next int32, err error, complete bool, observer Int64Observer)
type MappingInt322Int64FuncFactory func(observer Int64Observer) MappingInt322Int64Func

type MappingInt322Int64Observable struct {
	parent Int32Observable
	mapper MappingInt322Int64FuncFactory
}

func (f *MappingInt322Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322Int64Observable(parent Int32Observable, mapper MappingInt322Int64FuncFactory) Int64Observable {
	return &MappingInt322Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322Int64ObserveDirect(parent Int32Observable, mapper MappingInt322Int64Func) Int64Observable {
	return MapInt322Int64Observable(parent, func(Int64Observer) MappingInt322Int64Func {
		return mapper
	})
}

func MapInt322Int64ObserveNext(parent Int32Observable, mapper func(int32) int64) Int64Observable {
	return MapInt322Int64Observable(parent, func(Int64Observer) MappingInt322Int64Func {
		return func(next int32, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Int64 struct {
	parent Int32Observable
	mapper func(int32) Int64Observable
}

func (f *flatMapInt322Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *Int32Stream) MapInt64(f func(int32) int64) *Int64Stream {
	return FromInt64Observable(MapInt322Int64ObserveNext(s, f))
}

func (s *Int32Stream) FlatMapInt64(f func(int32) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapInt322Int64{s, f}}
}

type MappingInt322Float32Func func(next int32, err error, complete bool, observer Float32Observer)
type MappingInt322Float32FuncFactory func(observer Float32Observer) MappingInt322Float32Func

type MappingInt322Float32Observable struct {
	parent Int32Observable
	mapper MappingInt322Float32FuncFactory
}

func (f *MappingInt322Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322Float32Observable(parent Int32Observable, mapper MappingInt322Float32FuncFactory) Float32Observable {
	return &MappingInt322Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322Float32ObserveDirect(parent Int32Observable, mapper MappingInt322Float32Func) Float32Observable {
	return MapInt322Float32Observable(parent, func(Float32Observer) MappingInt322Float32Func {
		return mapper
	})
}

func MapInt322Float32ObserveNext(parent Int32Observable, mapper func(int32) float32) Float32Observable {
	return MapInt322Float32Observable(parent, func(Float32Observer) MappingInt322Float32Func {
		return func(next int32, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Float32 struct {
	parent Int32Observable
	mapper func(int32) Float32Observable
}

func (f *flatMapInt322Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *Int32Stream) MapFloat32(f func(int32) float32) *Float32Stream {
	return FromFloat32Observable(MapInt322Float32ObserveNext(s, f))
}

func (s *Int32Stream) FlatMapFloat32(f func(int32) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapInt322Float32{s, f}}
}

type MappingInt322Float64Func func(next int32, err error, complete bool, observer Float64Observer)
type MappingInt322Float64FuncFactory func(observer Float64Observer) MappingInt322Float64Func

type MappingInt322Float64Observable struct {
	parent Int32Observable
	mapper MappingInt322Float64FuncFactory
}

func (f *MappingInt322Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322Float64Observable(parent Int32Observable, mapper MappingInt322Float64FuncFactory) Float64Observable {
	return &MappingInt322Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322Float64ObserveDirect(parent Int32Observable, mapper MappingInt322Float64Func) Float64Observable {
	return MapInt322Float64Observable(parent, func(Float64Observer) MappingInt322Float64Func {
		return mapper
	})
}

func MapInt322Float64ObserveNext(parent Int32Observable, mapper func(int32) float64) Float64Observable {
	return MapInt322Float64Observable(parent, func(Float64Observer) MappingInt322Float64Func {
		return func(next int32, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Float64 struct {
	parent Int32Observable
	mapper func(int32) Float64Observable
}

func (f *flatMapInt322Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *Int32Stream) MapFloat64(f func(int32) float64) *Float64Stream {
	return FromFloat64Observable(MapInt322Float64ObserveNext(s, f))
}

func (s *Int32Stream) FlatMapFloat64(f func(int32) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapInt322Float64{s, f}}
}

type MappingInt322Complex64Func func(next int32, err error, complete bool, observer Complex64Observer)
type MappingInt322Complex64FuncFactory func(observer Complex64Observer) MappingInt322Complex64Func

type MappingInt322Complex64Observable struct {
	parent Int32Observable
	mapper MappingInt322Complex64FuncFactory
}

func (f *MappingInt322Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322Complex64Observable(parent Int32Observable, mapper MappingInt322Complex64FuncFactory) Complex64Observable {
	return &MappingInt322Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322Complex64ObserveDirect(parent Int32Observable, mapper MappingInt322Complex64Func) Complex64Observable {
	return MapInt322Complex64Observable(parent, func(Complex64Observer) MappingInt322Complex64Func {
		return mapper
	})
}

func MapInt322Complex64ObserveNext(parent Int32Observable, mapper func(int32) complex64) Complex64Observable {
	return MapInt322Complex64Observable(parent, func(Complex64Observer) MappingInt322Complex64Func {
		return func(next int32, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Complex64 struct {
	parent Int32Observable
	mapper func(int32) Complex64Observable
}

func (f *flatMapInt322Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *Int32Stream) MapComplex64(f func(int32) complex64) *Complex64Stream {
	return FromComplex64Observable(MapInt322Complex64ObserveNext(s, f))
}

func (s *Int32Stream) FlatMapComplex64(f func(int32) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapInt322Complex64{s, f}}
}

type MappingInt322Complex128Func func(next int32, err error, complete bool, observer Complex128Observer)
type MappingInt322Complex128FuncFactory func(observer Complex128Observer) MappingInt322Complex128Func

type MappingInt322Complex128Observable struct {
	parent Int32Observable
	mapper MappingInt322Complex128FuncFactory
}

func (f *MappingInt322Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322Complex128Observable(parent Int32Observable, mapper MappingInt322Complex128FuncFactory) Complex128Observable {
	return &MappingInt322Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322Complex128ObserveDirect(parent Int32Observable, mapper MappingInt322Complex128Func) Complex128Observable {
	return MapInt322Complex128Observable(parent, func(Complex128Observer) MappingInt322Complex128Func {
		return mapper
	})
}

func MapInt322Complex128ObserveNext(parent Int32Observable, mapper func(int32) complex128) Complex128Observable {
	return MapInt322Complex128Observable(parent, func(Complex128Observer) MappingInt322Complex128Func {
		return func(next int32, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Complex128 struct {
	parent Int32Observable
	mapper func(int32) Complex128Observable
}

func (f *flatMapInt322Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *Int32Stream) MapComplex128(f func(int32) complex128) *Complex128Stream {
	return FromComplex128Observable(MapInt322Complex128ObserveNext(s, f))
}

func (s *Int32Stream) FlatMapComplex128(f func(int32) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapInt322Complex128{s, f}}
}

type MappingInt322TimeFunc func(next int32, err error, complete bool, observer TimeObserver)
type MappingInt322TimeFuncFactory func(observer TimeObserver) MappingInt322TimeFunc

type MappingInt322TimeObservable struct {
	parent Int32Observable
	mapper MappingInt322TimeFuncFactory
}

func (f *MappingInt322TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322TimeObservable(parent Int32Observable, mapper MappingInt322TimeFuncFactory) TimeObservable {
	return &MappingInt322TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322TimeObserveDirect(parent Int32Observable, mapper MappingInt322TimeFunc) TimeObservable {
	return MapInt322TimeObservable(parent, func(TimeObserver) MappingInt322TimeFunc {
		return mapper
	})
}

func MapInt322TimeObserveNext(parent Int32Observable, mapper func(int32) time.Time) TimeObservable {
	return MapInt322TimeObservable(parent, func(TimeObserver) MappingInt322TimeFunc {
		return func(next int32, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Time struct {
	parent Int32Observable
	mapper func(int32) TimeObservable
}

func (f *flatMapInt322Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *Int32Stream) MapTime(f func(int32) time.Time) *TimeStream {
	return FromTimeObservable(MapInt322TimeObserveNext(s, f))
}

func (s *Int32Stream) FlatMapTime(f func(int32) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapInt322Time{s, f}}
}

type MappingInt322DurationFunc func(next int32, err error, complete bool, observer DurationObserver)
type MappingInt322DurationFuncFactory func(observer DurationObserver) MappingInt322DurationFunc

type MappingInt322DurationObservable struct {
	parent Int32Observable
	mapper MappingInt322DurationFuncFactory
}

func (f *MappingInt322DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt322DurationObservable(parent Int32Observable, mapper MappingInt322DurationFuncFactory) DurationObservable {
	return &MappingInt322DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt322DurationObserveDirect(parent Int32Observable, mapper MappingInt322DurationFunc) DurationObservable {
	return MapInt322DurationObservable(parent, func(DurationObserver) MappingInt322DurationFunc {
		return mapper
	})
}

func MapInt322DurationObserveNext(parent Int32Observable, mapper func(int32) time.Duration) DurationObservable {
	return MapInt322DurationObservable(parent, func(DurationObserver) MappingInt322DurationFunc {
		return func(next int32, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt322Duration struct {
	parent Int32Observable
	mapper func(int32) DurationObservable
}

func (f *flatMapInt322Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int32ObserverFunc(func(next int32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *Int32Stream) MapDuration(f func(int32) time.Duration) *DurationStream {
	return FromDurationObservable(MapInt322DurationObserveNext(s, f))
}

func (s *Int32Stream) FlatMapDuration(f func(int32) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapInt322Duration{s, f}}
}

type Uint64Observer interface {
	Next(uint64)
	TerminationObserver
}

// A Uint64Subscriber represents a subscribed Uint64Observer.
type Uint64Subscriber interface {
	Subscription
	Uint64Observer
}

type implUint64Subscriber struct {
	Subscription
	Uint64Observer
}

func Uint64ObserverAsGenericObserver(observer Uint64Observer) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(uint64))
		}
	})
}

func GenericObserverAsUint64Observer(observer GenericObserver) Uint64Observer {
	return Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type Uint64ObservableFactory func(observer Uint64Observer, subscription Subscription)

func (f Uint64ObservableFactory) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateUint64 calls f(observer, subscription) to produce values for a stream.
func CreateUint64(f func(observer Uint64Observer, subscription Subscription)) *Uint64Stream {
	return FromUint64Observable(Uint64ObservableFactory(f))
}

// Repeat value count times.
func RepeatUint64(value uint64, count int) *Uint64Stream {
	return CreateUint64(func(observer Uint64Observer, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartUint64 is designed to be used with functions that return a
// (uint64, error) tuple.
//
// If the error is non-nil the returned Uint64Stream will be that error,
// otherwise it will be a single-value stream of uint64.
func StartUint64(f func() (uint64, error)) *Uint64Stream {
	return CreateUint64(func(observer Uint64Observer, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughUint64(next uint64, err error, complete bool, observer Uint64Observer) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroUint64 = *new(uint64)

type Uint64ObserverFunc func(uint64, error, bool)

func (f Uint64ObserverFunc) Next(next uint64) { f(next, nil, false) }
func (f Uint64ObserverFunc) Error(err error)  { f(zeroUint64, err, false) }
func (f Uint64ObserverFunc) Complete()        { f(zeroUint64, nil, true) }

type Uint64Observable interface {
	Subscribe(Uint64Observer) Subscription
}

// Convert a GenericObservableFilter to a Uint64Observable
func (f GenericObservableFilterFactory) Uint64(parent Uint64Observable) Uint64Observable {
	return MapUint642Uint64Observable(parent, func(observer Uint64Observer) MappingUint642Uint64Func {
		gobserver := Uint64ObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next uint64, err error, complete bool, observer Uint64Observer) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverUint64() *Uint64Stream {
	return CreateUint64(func(observer Uint64Observer, subscription Subscription) {})
}

func EmptyUint64() *Uint64Stream {
	return CreateUint64(func(observer Uint64Observer, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowUint64(err error) *Uint64Stream {
	return CreateUint64(func(observer Uint64Observer, subscription Subscription) {
		observer.Error(err)
	})
}

func FromUint64Array(array []uint64) *Uint64Stream {
	return CreateUint64(func(observer Uint64Observer, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromUint64s(array ...uint64) *Uint64Stream {
	return FromUint64Array(array)
}

func JustUint64(element uint64) *Uint64Stream {
	return FromUint64Array([]uint64{element})
}

func MergeUint64(observables ...Uint64Observable) *Uint64Stream {
	if len(observables) == 0 {
		return EmptyUint64()
	}
	return (&Uint64Stream{observables[0]}).Merge(observables[1:]...)
}

func MergeUint64DelayError(observables ...Uint64Observable) *Uint64Stream {
	if len(observables) == 0 {
		return EmptyUint64()
	}
	return (&Uint64Stream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromUint64Channel(ch <-chan uint64) *Uint64Stream {
	return CreateUint64(func(observer Uint64Observer, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type Uint64Stream struct {
	Uint64Observable
}

func FromUint64Observable(observable Uint64Observable) *Uint64Stream {
	return &Uint64Stream{observable}
}

func (s *Uint64Stream) SubscribeFunc(f func(uint64, error, bool)) Subscription {
	return s.Subscribe(Uint64ObserverFunc(f))
}

func (s *Uint64Stream) SubscribeNext(f func(v uint64)) Subscription {
	return s.SubscribeFunc(func(next uint64, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *Uint64Stream) Distinct() *Uint64Stream {
	return FromUint64Observable(distinctFilter().Uint64(s))
}

// ElementAt yields the Nth element of the stream.
func (s *Uint64Stream) ElementAt(n int) *Uint64Stream {
	return FromUint64Observable(elementAtFilter(n).Uint64(s))
}

// Filter elements in the stream on a function.
func (s *Uint64Stream) Filter(f func(uint64) bool) *Uint64Stream {
	return FromUint64Observable(filterFilter(func(v interface{}) bool { return f(v.(uint64)) }).Uint64(s))
}

// Last returns just the first element of the stream.
func (s *Uint64Stream) First() *Uint64Stream {
	return FromUint64Observable(firstFilter().Uint64(s))
}

// Last returns just the last element of the stream.
func (s *Uint64Stream) Last() *Uint64Stream {
	return FromUint64Observable(lastFilter().Uint64(s))
}

// SkipLast skips the first N elements of the stream.
func (s *Uint64Stream) Skip(n int) *Uint64Stream {
	return FromUint64Observable(skipFilter(n).Uint64(s))
}

// SkipLast skips the last N elements of the stream.
func (s *Uint64Stream) SkipLast(n int) *Uint64Stream {
	return FromUint64Observable(skipLastFilter(n).Uint64(s))
}

// Take returns just the first N elements of the stream.
func (s *Uint64Stream) Take(n int) *Uint64Stream {
	return FromUint64Observable(takeFilter(n).Uint64(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *Uint64Stream) TakeLast(n int) *Uint64Stream {
	return FromUint64Observable(takeLastFilter(n).Uint64(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *Uint64Stream) IgnoreElements() *Uint64Stream {
	return FromUint64Observable(ignoreElementsFilter().Uint64(s))
}

func (s *Uint64Stream) Replay(size int, duration time.Duration) *Uint64Stream {
	return FromUint64Observable(replayFilter(size, duration).Uint64(s))
}

func (s *Uint64Stream) Sample(duration time.Duration) *Uint64Stream {
	return FromUint64Observable(sampleFilter(duration).Uint64(s))
}

func (s *Uint64Stream) Debounce(duration time.Duration) *Uint64Stream {
	return FromUint64Observable(debounceFilter(duration).Uint64(s))
}

// Wait for completion of the stream and return any error.
func (s *Uint64Stream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeUint64Subscriber(observer Uint64Observer) Uint64Subscriber {
	if subscriber, ok := observer.(Uint64Subscriber); ok {
		return subscriber
	}
	return &implUint64Subscriber{NewGenericSubscription(), observer}
}

type concatUint64Subscriber struct {
	observable  int
	observer    Uint64Observer
	observables []Uint64Observable
	Subscription
}

func (c *concatUint64Subscriber) Next(next uint64) {
	c.observer.Next(next)
}

func (c *concatUint64Subscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatUint64Subscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatUint64Observable struct {
	observables []Uint64Observable
}

func (m *concatUint64Observable) Subscribe(observer Uint64Observer) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatUint64Subscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *Uint64Stream) Concat(observables ...Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&concatUint64Observable{append([]Uint64Observable{s}, observables...)}}
}

type mergeUint64Observable struct {
	delayError  bool
	observables []Uint64Observable
}

func (m *mergeUint64Observable) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next uint64, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(Uint64ObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *Uint64Stream) Merge(other ...Uint64Observable) *Uint64Stream {
	if len(other) == 0 {
		return s
	}
	return &Uint64Stream{&mergeUint64Observable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *Uint64Stream) MergeDelayError(other ...Uint64Observable) *Uint64Stream {
	if len(other) == 0 {
		return s
	}
	return &Uint64Stream{&mergeUint64Observable{true, append(other, s)}}
}

type catchUint64Observable struct {
	parent Uint64Observable
	catch  Uint64Observable
}

func (r *catchUint64Observable) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	run := func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(Uint64ObserverFunc(run))
	return subscription
}

func (s *Uint64Stream) Catch(catch Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&catchUint64Observable{s, catch}}
}

type retryUint64Observable struct {
	observable Uint64Observable
}

type retryUint64Observer struct {
	observable Uint64Observable
	observer   Uint64Observer
}

func (r *retryUint64Observer) retry(next uint64, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(Uint64ObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryUint64Observable) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryUint64Observer{r.observable, observer}
	r.observable.Subscribe(Uint64ObserverFunc(ro.retry))
	return subscription
}

func (s *Uint64Stream) Retry() *Uint64Stream {
	return &Uint64Stream{&retryUint64Observable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *Uint64Stream) Do(f func(next uint64)) *Uint64Stream {
	return FromUint64Observable(MapUint642Uint64ObserveNext(s, func(next uint64) uint64 {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *Uint64Stream) DoOnError(f func(err error)) *Uint64Stream {
	return FromUint64Observable(MapUint642Uint64ObserveDirect(s, func(next uint64, err error, complete bool, observer Uint64Observer) {
		if err != nil {
			f(err)
		}
		PassthroughUint64(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *Uint64Stream) DoOnComplete(f func()) *Uint64Stream {
	return FromUint64Observable(MapUint642Uint64ObserveDirect(s, func(next uint64, err error, complete bool, observer Uint64Observer) {
		if complete {
			f()
		}
		PassthroughUint64(next, err, complete, observer)
	}))
}

func (s *Uint64Stream) Reduce(initial uint64, reducer func(uint64, uint64) uint64) *Uint64Stream {
	value := initial
	return FromUint64Observable(MapUint642Uint64ObserveDirect(s, func(next uint64, err error, complete bool, observer Uint64Observer) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *Uint64Stream) Scan(initial uint64, f func(uint64, uint64) uint64) *Uint64Stream {
	value := initial
	return FromUint64Observable(MapUint642Uint64ObserveDirect(s, func(next uint64, err error, complete bool, observer Uint64Observer) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutUint64 struct {
	parent  Uint64Observable
	timeout time.Duration
}

func (t *timeoutUint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *Uint64Stream) Timeout(timeout time.Duration) *Uint64Stream {
	return &Uint64Stream{&timeoutUint64{s, timeout}}
}

type forkedUint64Stream struct {
	lock      sync.Mutex
	parent    Uint64Observable
	observers []Uint64Observer
}

func (f *forkedUint64Stream) Subscribe(observer Uint64Observer) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *Uint64Stream) Fork() *Uint64Stream {
	f := &forkedUint64Stream{parent: s}
	go s.Subscribe(Uint64ObserverFunc(func(n uint64, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &Uint64Stream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *Uint64Stream) ToOneWithError() (uint64, error) {
	valuech := make(chan uint64, 1)
	errch := make(chan error, 1)
	FromUint64Observable(oneFilter().Uint64(s)).SubscribeFunc(func(next uint64, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroUint64, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *Uint64Stream) ToOne() uint64 {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *Uint64Stream) ToArrayWithError() ([]uint64, error) {
	array := []uint64{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *Uint64Stream) ToArray() []uint64 {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *Uint64Stream) ToChannelWithError() (<-chan uint64, <-chan error) {
	ch := make(chan uint64, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *Uint64Stream) ToChannel() <-chan uint64 {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *Uint64Stream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapUint642IntObserveDirect(s, func(next uint64, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

func (s *Uint64Stream) Average() *Uint64Stream {
	var sum uint64
	var count uint64
	return FromUint64Observable(MapUint642Uint64ObserveDirect(s, func(next uint64, err error, complete bool, observer Uint64Observer) {
		switch {
		case err != nil:
			observer.Next(sum / count)
			observer.Error(err)
		case complete:
			observer.Next(sum / count)
			observer.Complete()
		default:
			sum += next
			count++
		}
	}))
}

func (s *Uint64Stream) Sum() *Uint64Stream {
	var sum uint64
	return FromUint64Observable(MapUint642Uint64ObserveDirect(s, func(next uint64, err error, complete bool, observer Uint64Observer) {
		switch {
		case err != nil:
			observer.Next(sum)
			observer.Error(err)
		case complete:
			observer.Next(sum)
			observer.Complete()
		default:
			sum += next
		}
	}))
}

func (s *Uint64Stream) Min() *Uint64Stream {
	started := false
	var min uint64
	return FromUint64Observable(MapUint642Uint64ObserveDirect(s, func(next uint64, err error, complete bool, observer Uint64Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(min)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(min)
			}
			observer.Complete()
		default:
			if started {
				if min > next {
					min = next
				}
			} else {
				min = next
				started = true
			}
		}
	}))
}

func (s *Uint64Stream) Max() *Uint64Stream {
	started := false
	var max uint64
	return FromUint64Observable(MapUint642Uint64ObserveDirect(s, func(next uint64, err error, complete bool, observer Uint64Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(max)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(max)
			}
			observer.Complete()
		default:
			if started {
				if max <= next {
					max = next
				}
			} else {
				max = next
				started = true
			}
		}
	}))
}

type MappingUint642BoolFunc func(next uint64, err error, complete bool, observer BoolObserver)
type MappingUint642BoolFuncFactory func(observer BoolObserver) MappingUint642BoolFunc

type MappingUint642BoolObservable struct {
	parent Uint64Observable
	mapper MappingUint642BoolFuncFactory
}

func (f *MappingUint642BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642BoolObservable(parent Uint64Observable, mapper MappingUint642BoolFuncFactory) BoolObservable {
	return &MappingUint642BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642BoolObserveDirect(parent Uint64Observable, mapper MappingUint642BoolFunc) BoolObservable {
	return MapUint642BoolObservable(parent, func(BoolObserver) MappingUint642BoolFunc {
		return mapper
	})
}

func MapUint642BoolObserveNext(parent Uint64Observable, mapper func(uint64) bool) BoolObservable {
	return MapUint642BoolObservable(parent, func(BoolObserver) MappingUint642BoolFunc {
		return func(next uint64, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Bool struct {
	parent Uint64Observable
	mapper func(uint64) BoolObservable
}

func (f *flatMapUint642Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *Uint64Stream) MapBool(f func(uint64) bool) *BoolStream {
	return FromBoolObservable(MapUint642BoolObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapBool(f func(uint64) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapUint642Bool{s, f}}
}

type MappingUint642RuneFunc func(next uint64, err error, complete bool, observer RuneObserver)
type MappingUint642RuneFuncFactory func(observer RuneObserver) MappingUint642RuneFunc

type MappingUint642RuneObservable struct {
	parent Uint64Observable
	mapper MappingUint642RuneFuncFactory
}

func (f *MappingUint642RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642RuneObservable(parent Uint64Observable, mapper MappingUint642RuneFuncFactory) RuneObservable {
	return &MappingUint642RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642RuneObserveDirect(parent Uint64Observable, mapper MappingUint642RuneFunc) RuneObservable {
	return MapUint642RuneObservable(parent, func(RuneObserver) MappingUint642RuneFunc {
		return mapper
	})
}

func MapUint642RuneObserveNext(parent Uint64Observable, mapper func(uint64) rune) RuneObservable {
	return MapUint642RuneObservable(parent, func(RuneObserver) MappingUint642RuneFunc {
		return func(next uint64, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Rune struct {
	parent Uint64Observable
	mapper func(uint64) RuneObservable
}

func (f *flatMapUint642Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *Uint64Stream) MapRune(f func(uint64) rune) *RuneStream {
	return FromRuneObservable(MapUint642RuneObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapRune(f func(uint64) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapUint642Rune{s, f}}
}

type MappingUint642ByteFunc func(next uint64, err error, complete bool, observer ByteObserver)
type MappingUint642ByteFuncFactory func(observer ByteObserver) MappingUint642ByteFunc

type MappingUint642ByteObservable struct {
	parent Uint64Observable
	mapper MappingUint642ByteFuncFactory
}

func (f *MappingUint642ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642ByteObservable(parent Uint64Observable, mapper MappingUint642ByteFuncFactory) ByteObservable {
	return &MappingUint642ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642ByteObserveDirect(parent Uint64Observable, mapper MappingUint642ByteFunc) ByteObservable {
	return MapUint642ByteObservable(parent, func(ByteObserver) MappingUint642ByteFunc {
		return mapper
	})
}

func MapUint642ByteObserveNext(parent Uint64Observable, mapper func(uint64) byte) ByteObservable {
	return MapUint642ByteObservable(parent, func(ByteObserver) MappingUint642ByteFunc {
		return func(next uint64, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Byte struct {
	parent Uint64Observable
	mapper func(uint64) ByteObservable
}

func (f *flatMapUint642Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *Uint64Stream) MapByte(f func(uint64) byte) *ByteStream {
	return FromByteObservable(MapUint642ByteObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapByte(f func(uint64) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapUint642Byte{s, f}}
}

type MappingUint642StringFunc func(next uint64, err error, complete bool, observer StringObserver)
type MappingUint642StringFuncFactory func(observer StringObserver) MappingUint642StringFunc

type MappingUint642StringObservable struct {
	parent Uint64Observable
	mapper MappingUint642StringFuncFactory
}

func (f *MappingUint642StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642StringObservable(parent Uint64Observable, mapper MappingUint642StringFuncFactory) StringObservable {
	return &MappingUint642StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642StringObserveDirect(parent Uint64Observable, mapper MappingUint642StringFunc) StringObservable {
	return MapUint642StringObservable(parent, func(StringObserver) MappingUint642StringFunc {
		return mapper
	})
}

func MapUint642StringObserveNext(parent Uint64Observable, mapper func(uint64) string) StringObservable {
	return MapUint642StringObservable(parent, func(StringObserver) MappingUint642StringFunc {
		return func(next uint64, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642String struct {
	parent Uint64Observable
	mapper func(uint64) StringObservable
}

func (f *flatMapUint642String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *Uint64Stream) MapString(f func(uint64) string) *StringStream {
	return FromStringObservable(MapUint642StringObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapString(f func(uint64) StringObservable) *StringStream {
	return &StringStream{&flatMapUint642String{s, f}}
}

type MappingUint642UintFunc func(next uint64, err error, complete bool, observer UintObserver)
type MappingUint642UintFuncFactory func(observer UintObserver) MappingUint642UintFunc

type MappingUint642UintObservable struct {
	parent Uint64Observable
	mapper MappingUint642UintFuncFactory
}

func (f *MappingUint642UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642UintObservable(parent Uint64Observable, mapper MappingUint642UintFuncFactory) UintObservable {
	return &MappingUint642UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642UintObserveDirect(parent Uint64Observable, mapper MappingUint642UintFunc) UintObservable {
	return MapUint642UintObservable(parent, func(UintObserver) MappingUint642UintFunc {
		return mapper
	})
}

func MapUint642UintObserveNext(parent Uint64Observable, mapper func(uint64) uint) UintObservable {
	return MapUint642UintObservable(parent, func(UintObserver) MappingUint642UintFunc {
		return func(next uint64, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Uint struct {
	parent Uint64Observable
	mapper func(uint64) UintObservable
}

func (f *flatMapUint642Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *Uint64Stream) MapUint(f func(uint64) uint) *UintStream {
	return FromUintObservable(MapUint642UintObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapUint(f func(uint64) UintObservable) *UintStream {
	return &UintStream{&flatMapUint642Uint{s, f}}
}

type MappingUint642IntFunc func(next uint64, err error, complete bool, observer IntObserver)
type MappingUint642IntFuncFactory func(observer IntObserver) MappingUint642IntFunc

type MappingUint642IntObservable struct {
	parent Uint64Observable
	mapper MappingUint642IntFuncFactory
}

func (f *MappingUint642IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642IntObservable(parent Uint64Observable, mapper MappingUint642IntFuncFactory) IntObservable {
	return &MappingUint642IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642IntObserveDirect(parent Uint64Observable, mapper MappingUint642IntFunc) IntObservable {
	return MapUint642IntObservable(parent, func(IntObserver) MappingUint642IntFunc {
		return mapper
	})
}

func MapUint642IntObserveNext(parent Uint64Observable, mapper func(uint64) int) IntObservable {
	return MapUint642IntObservable(parent, func(IntObserver) MappingUint642IntFunc {
		return func(next uint64, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Int struct {
	parent Uint64Observable
	mapper func(uint64) IntObservable
}

func (f *flatMapUint642Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *Uint64Stream) MapInt(f func(uint64) int) *IntStream {
	return FromIntObservable(MapUint642IntObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapInt(f func(uint64) IntObservable) *IntStream {
	return &IntStream{&flatMapUint642Int{s, f}}
}

type MappingUint642Uint8Func func(next uint64, err error, complete bool, observer Uint8Observer)
type MappingUint642Uint8FuncFactory func(observer Uint8Observer) MappingUint642Uint8Func

type MappingUint642Uint8Observable struct {
	parent Uint64Observable
	mapper MappingUint642Uint8FuncFactory
}

func (f *MappingUint642Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642Uint8Observable(parent Uint64Observable, mapper MappingUint642Uint8FuncFactory) Uint8Observable {
	return &MappingUint642Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642Uint8ObserveDirect(parent Uint64Observable, mapper MappingUint642Uint8Func) Uint8Observable {
	return MapUint642Uint8Observable(parent, func(Uint8Observer) MappingUint642Uint8Func {
		return mapper
	})
}

func MapUint642Uint8ObserveNext(parent Uint64Observable, mapper func(uint64) uint8) Uint8Observable {
	return MapUint642Uint8Observable(parent, func(Uint8Observer) MappingUint642Uint8Func {
		return func(next uint64, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Uint8 struct {
	parent Uint64Observable
	mapper func(uint64) Uint8Observable
}

func (f *flatMapUint642Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *Uint64Stream) MapUint8(f func(uint64) uint8) *Uint8Stream {
	return FromUint8Observable(MapUint642Uint8ObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapUint8(f func(uint64) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapUint642Uint8{s, f}}
}

type MappingUint642Int8Func func(next uint64, err error, complete bool, observer Int8Observer)
type MappingUint642Int8FuncFactory func(observer Int8Observer) MappingUint642Int8Func

type MappingUint642Int8Observable struct {
	parent Uint64Observable
	mapper MappingUint642Int8FuncFactory
}

func (f *MappingUint642Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642Int8Observable(parent Uint64Observable, mapper MappingUint642Int8FuncFactory) Int8Observable {
	return &MappingUint642Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642Int8ObserveDirect(parent Uint64Observable, mapper MappingUint642Int8Func) Int8Observable {
	return MapUint642Int8Observable(parent, func(Int8Observer) MappingUint642Int8Func {
		return mapper
	})
}

func MapUint642Int8ObserveNext(parent Uint64Observable, mapper func(uint64) int8) Int8Observable {
	return MapUint642Int8Observable(parent, func(Int8Observer) MappingUint642Int8Func {
		return func(next uint64, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Int8 struct {
	parent Uint64Observable
	mapper func(uint64) Int8Observable
}

func (f *flatMapUint642Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *Uint64Stream) MapInt8(f func(uint64) int8) *Int8Stream {
	return FromInt8Observable(MapUint642Int8ObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapInt8(f func(uint64) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapUint642Int8{s, f}}
}

type MappingUint642Uint16Func func(next uint64, err error, complete bool, observer Uint16Observer)
type MappingUint642Uint16FuncFactory func(observer Uint16Observer) MappingUint642Uint16Func

type MappingUint642Uint16Observable struct {
	parent Uint64Observable
	mapper MappingUint642Uint16FuncFactory
}

func (f *MappingUint642Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642Uint16Observable(parent Uint64Observable, mapper MappingUint642Uint16FuncFactory) Uint16Observable {
	return &MappingUint642Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642Uint16ObserveDirect(parent Uint64Observable, mapper MappingUint642Uint16Func) Uint16Observable {
	return MapUint642Uint16Observable(parent, func(Uint16Observer) MappingUint642Uint16Func {
		return mapper
	})
}

func MapUint642Uint16ObserveNext(parent Uint64Observable, mapper func(uint64) uint16) Uint16Observable {
	return MapUint642Uint16Observable(parent, func(Uint16Observer) MappingUint642Uint16Func {
		return func(next uint64, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Uint16 struct {
	parent Uint64Observable
	mapper func(uint64) Uint16Observable
}

func (f *flatMapUint642Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *Uint64Stream) MapUint16(f func(uint64) uint16) *Uint16Stream {
	return FromUint16Observable(MapUint642Uint16ObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapUint16(f func(uint64) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapUint642Uint16{s, f}}
}

type MappingUint642Int16Func func(next uint64, err error, complete bool, observer Int16Observer)
type MappingUint642Int16FuncFactory func(observer Int16Observer) MappingUint642Int16Func

type MappingUint642Int16Observable struct {
	parent Uint64Observable
	mapper MappingUint642Int16FuncFactory
}

func (f *MappingUint642Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642Int16Observable(parent Uint64Observable, mapper MappingUint642Int16FuncFactory) Int16Observable {
	return &MappingUint642Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642Int16ObserveDirect(parent Uint64Observable, mapper MappingUint642Int16Func) Int16Observable {
	return MapUint642Int16Observable(parent, func(Int16Observer) MappingUint642Int16Func {
		return mapper
	})
}

func MapUint642Int16ObserveNext(parent Uint64Observable, mapper func(uint64) int16) Int16Observable {
	return MapUint642Int16Observable(parent, func(Int16Observer) MappingUint642Int16Func {
		return func(next uint64, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Int16 struct {
	parent Uint64Observable
	mapper func(uint64) Int16Observable
}

func (f *flatMapUint642Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *Uint64Stream) MapInt16(f func(uint64) int16) *Int16Stream {
	return FromInt16Observable(MapUint642Int16ObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapInt16(f func(uint64) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapUint642Int16{s, f}}
}

type MappingUint642Uint32Func func(next uint64, err error, complete bool, observer Uint32Observer)
type MappingUint642Uint32FuncFactory func(observer Uint32Observer) MappingUint642Uint32Func

type MappingUint642Uint32Observable struct {
	parent Uint64Observable
	mapper MappingUint642Uint32FuncFactory
}

func (f *MappingUint642Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642Uint32Observable(parent Uint64Observable, mapper MappingUint642Uint32FuncFactory) Uint32Observable {
	return &MappingUint642Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642Uint32ObserveDirect(parent Uint64Observable, mapper MappingUint642Uint32Func) Uint32Observable {
	return MapUint642Uint32Observable(parent, func(Uint32Observer) MappingUint642Uint32Func {
		return mapper
	})
}

func MapUint642Uint32ObserveNext(parent Uint64Observable, mapper func(uint64) uint32) Uint32Observable {
	return MapUint642Uint32Observable(parent, func(Uint32Observer) MappingUint642Uint32Func {
		return func(next uint64, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Uint32 struct {
	parent Uint64Observable
	mapper func(uint64) Uint32Observable
}

func (f *flatMapUint642Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *Uint64Stream) MapUint32(f func(uint64) uint32) *Uint32Stream {
	return FromUint32Observable(MapUint642Uint32ObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapUint32(f func(uint64) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapUint642Uint32{s, f}}
}

type MappingUint642Int32Func func(next uint64, err error, complete bool, observer Int32Observer)
type MappingUint642Int32FuncFactory func(observer Int32Observer) MappingUint642Int32Func

type MappingUint642Int32Observable struct {
	parent Uint64Observable
	mapper MappingUint642Int32FuncFactory
}

func (f *MappingUint642Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642Int32Observable(parent Uint64Observable, mapper MappingUint642Int32FuncFactory) Int32Observable {
	return &MappingUint642Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642Int32ObserveDirect(parent Uint64Observable, mapper MappingUint642Int32Func) Int32Observable {
	return MapUint642Int32Observable(parent, func(Int32Observer) MappingUint642Int32Func {
		return mapper
	})
}

func MapUint642Int32ObserveNext(parent Uint64Observable, mapper func(uint64) int32) Int32Observable {
	return MapUint642Int32Observable(parent, func(Int32Observer) MappingUint642Int32Func {
		return func(next uint64, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Int32 struct {
	parent Uint64Observable
	mapper func(uint64) Int32Observable
}

func (f *flatMapUint642Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *Uint64Stream) MapInt32(f func(uint64) int32) *Int32Stream {
	return FromInt32Observable(MapUint642Int32ObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapInt32(f func(uint64) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapUint642Int32{s, f}}
}

type MappingUint642Uint64Func func(next uint64, err error, complete bool, observer Uint64Observer)
type MappingUint642Uint64FuncFactory func(observer Uint64Observer) MappingUint642Uint64Func

type MappingUint642Uint64Observable struct {
	parent Uint64Observable
	mapper MappingUint642Uint64FuncFactory
}

func (f *MappingUint642Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642Uint64Observable(parent Uint64Observable, mapper MappingUint642Uint64FuncFactory) Uint64Observable {
	return &MappingUint642Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642Uint64ObserveDirect(parent Uint64Observable, mapper MappingUint642Uint64Func) Uint64Observable {
	return MapUint642Uint64Observable(parent, func(Uint64Observer) MappingUint642Uint64Func {
		return mapper
	})
}

func MapUint642Uint64ObserveNext(parent Uint64Observable, mapper func(uint64) uint64) Uint64Observable {
	return MapUint642Uint64Observable(parent, func(Uint64Observer) MappingUint642Uint64Func {
		return func(next uint64, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Uint64 struct {
	parent Uint64Observable
	mapper func(uint64) Uint64Observable
}

func (f *flatMapUint642Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *Uint64Stream) Map(f func(uint64) uint64) *Uint64Stream {
	return FromUint64Observable(MapUint642Uint64ObserveNext(s, f))
}

func (s *Uint64Stream) FlatMap(f func(uint64) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapUint642Uint64{s, f}}
}

type MappingUint642Int64Func func(next uint64, err error, complete bool, observer Int64Observer)
type MappingUint642Int64FuncFactory func(observer Int64Observer) MappingUint642Int64Func

type MappingUint642Int64Observable struct {
	parent Uint64Observable
	mapper MappingUint642Int64FuncFactory
}

func (f *MappingUint642Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642Int64Observable(parent Uint64Observable, mapper MappingUint642Int64FuncFactory) Int64Observable {
	return &MappingUint642Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642Int64ObserveDirect(parent Uint64Observable, mapper MappingUint642Int64Func) Int64Observable {
	return MapUint642Int64Observable(parent, func(Int64Observer) MappingUint642Int64Func {
		return mapper
	})
}

func MapUint642Int64ObserveNext(parent Uint64Observable, mapper func(uint64) int64) Int64Observable {
	return MapUint642Int64Observable(parent, func(Int64Observer) MappingUint642Int64Func {
		return func(next uint64, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Int64 struct {
	parent Uint64Observable
	mapper func(uint64) Int64Observable
}

func (f *flatMapUint642Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *Uint64Stream) MapInt64(f func(uint64) int64) *Int64Stream {
	return FromInt64Observable(MapUint642Int64ObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapInt64(f func(uint64) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapUint642Int64{s, f}}
}

type MappingUint642Float32Func func(next uint64, err error, complete bool, observer Float32Observer)
type MappingUint642Float32FuncFactory func(observer Float32Observer) MappingUint642Float32Func

type MappingUint642Float32Observable struct {
	parent Uint64Observable
	mapper MappingUint642Float32FuncFactory
}

func (f *MappingUint642Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642Float32Observable(parent Uint64Observable, mapper MappingUint642Float32FuncFactory) Float32Observable {
	return &MappingUint642Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642Float32ObserveDirect(parent Uint64Observable, mapper MappingUint642Float32Func) Float32Observable {
	return MapUint642Float32Observable(parent, func(Float32Observer) MappingUint642Float32Func {
		return mapper
	})
}

func MapUint642Float32ObserveNext(parent Uint64Observable, mapper func(uint64) float32) Float32Observable {
	return MapUint642Float32Observable(parent, func(Float32Observer) MappingUint642Float32Func {
		return func(next uint64, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Float32 struct {
	parent Uint64Observable
	mapper func(uint64) Float32Observable
}

func (f *flatMapUint642Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *Uint64Stream) MapFloat32(f func(uint64) float32) *Float32Stream {
	return FromFloat32Observable(MapUint642Float32ObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapFloat32(f func(uint64) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapUint642Float32{s, f}}
}

type MappingUint642Float64Func func(next uint64, err error, complete bool, observer Float64Observer)
type MappingUint642Float64FuncFactory func(observer Float64Observer) MappingUint642Float64Func

type MappingUint642Float64Observable struct {
	parent Uint64Observable
	mapper MappingUint642Float64FuncFactory
}

func (f *MappingUint642Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642Float64Observable(parent Uint64Observable, mapper MappingUint642Float64FuncFactory) Float64Observable {
	return &MappingUint642Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642Float64ObserveDirect(parent Uint64Observable, mapper MappingUint642Float64Func) Float64Observable {
	return MapUint642Float64Observable(parent, func(Float64Observer) MappingUint642Float64Func {
		return mapper
	})
}

func MapUint642Float64ObserveNext(parent Uint64Observable, mapper func(uint64) float64) Float64Observable {
	return MapUint642Float64Observable(parent, func(Float64Observer) MappingUint642Float64Func {
		return func(next uint64, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Float64 struct {
	parent Uint64Observable
	mapper func(uint64) Float64Observable
}

func (f *flatMapUint642Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *Uint64Stream) MapFloat64(f func(uint64) float64) *Float64Stream {
	return FromFloat64Observable(MapUint642Float64ObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapFloat64(f func(uint64) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapUint642Float64{s, f}}
}

type MappingUint642Complex64Func func(next uint64, err error, complete bool, observer Complex64Observer)
type MappingUint642Complex64FuncFactory func(observer Complex64Observer) MappingUint642Complex64Func

type MappingUint642Complex64Observable struct {
	parent Uint64Observable
	mapper MappingUint642Complex64FuncFactory
}

func (f *MappingUint642Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642Complex64Observable(parent Uint64Observable, mapper MappingUint642Complex64FuncFactory) Complex64Observable {
	return &MappingUint642Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642Complex64ObserveDirect(parent Uint64Observable, mapper MappingUint642Complex64Func) Complex64Observable {
	return MapUint642Complex64Observable(parent, func(Complex64Observer) MappingUint642Complex64Func {
		return mapper
	})
}

func MapUint642Complex64ObserveNext(parent Uint64Observable, mapper func(uint64) complex64) Complex64Observable {
	return MapUint642Complex64Observable(parent, func(Complex64Observer) MappingUint642Complex64Func {
		return func(next uint64, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Complex64 struct {
	parent Uint64Observable
	mapper func(uint64) Complex64Observable
}

func (f *flatMapUint642Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *Uint64Stream) MapComplex64(f func(uint64) complex64) *Complex64Stream {
	return FromComplex64Observable(MapUint642Complex64ObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapComplex64(f func(uint64) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapUint642Complex64{s, f}}
}

type MappingUint642Complex128Func func(next uint64, err error, complete bool, observer Complex128Observer)
type MappingUint642Complex128FuncFactory func(observer Complex128Observer) MappingUint642Complex128Func

type MappingUint642Complex128Observable struct {
	parent Uint64Observable
	mapper MappingUint642Complex128FuncFactory
}

func (f *MappingUint642Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642Complex128Observable(parent Uint64Observable, mapper MappingUint642Complex128FuncFactory) Complex128Observable {
	return &MappingUint642Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642Complex128ObserveDirect(parent Uint64Observable, mapper MappingUint642Complex128Func) Complex128Observable {
	return MapUint642Complex128Observable(parent, func(Complex128Observer) MappingUint642Complex128Func {
		return mapper
	})
}

func MapUint642Complex128ObserveNext(parent Uint64Observable, mapper func(uint64) complex128) Complex128Observable {
	return MapUint642Complex128Observable(parent, func(Complex128Observer) MappingUint642Complex128Func {
		return func(next uint64, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Complex128 struct {
	parent Uint64Observable
	mapper func(uint64) Complex128Observable
}

func (f *flatMapUint642Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *Uint64Stream) MapComplex128(f func(uint64) complex128) *Complex128Stream {
	return FromComplex128Observable(MapUint642Complex128ObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapComplex128(f func(uint64) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapUint642Complex128{s, f}}
}

type MappingUint642TimeFunc func(next uint64, err error, complete bool, observer TimeObserver)
type MappingUint642TimeFuncFactory func(observer TimeObserver) MappingUint642TimeFunc

type MappingUint642TimeObservable struct {
	parent Uint64Observable
	mapper MappingUint642TimeFuncFactory
}

func (f *MappingUint642TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642TimeObservable(parent Uint64Observable, mapper MappingUint642TimeFuncFactory) TimeObservable {
	return &MappingUint642TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642TimeObserveDirect(parent Uint64Observable, mapper MappingUint642TimeFunc) TimeObservable {
	return MapUint642TimeObservable(parent, func(TimeObserver) MappingUint642TimeFunc {
		return mapper
	})
}

func MapUint642TimeObserveNext(parent Uint64Observable, mapper func(uint64) time.Time) TimeObservable {
	return MapUint642TimeObservable(parent, func(TimeObserver) MappingUint642TimeFunc {
		return func(next uint64, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Time struct {
	parent Uint64Observable
	mapper func(uint64) TimeObservable
}

func (f *flatMapUint642Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *Uint64Stream) MapTime(f func(uint64) time.Time) *TimeStream {
	return FromTimeObservable(MapUint642TimeObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapTime(f func(uint64) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapUint642Time{s, f}}
}

type MappingUint642DurationFunc func(next uint64, err error, complete bool, observer DurationObserver)
type MappingUint642DurationFuncFactory func(observer DurationObserver) MappingUint642DurationFunc

type MappingUint642DurationObservable struct {
	parent Uint64Observable
	mapper MappingUint642DurationFuncFactory
}

func (f *MappingUint642DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapUint642DurationObservable(parent Uint64Observable, mapper MappingUint642DurationFuncFactory) DurationObservable {
	return &MappingUint642DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapUint642DurationObserveDirect(parent Uint64Observable, mapper MappingUint642DurationFunc) DurationObservable {
	return MapUint642DurationObservable(parent, func(DurationObserver) MappingUint642DurationFunc {
		return mapper
	})
}

func MapUint642DurationObserveNext(parent Uint64Observable, mapper func(uint64) time.Duration) DurationObservable {
	return MapUint642DurationObservable(parent, func(DurationObserver) MappingUint642DurationFunc {
		return func(next uint64, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapUint642Duration struct {
	parent Uint64Observable
	mapper func(uint64) DurationObservable
}

func (f *flatMapUint642Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Uint64ObserverFunc(func(next uint64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *Uint64Stream) MapDuration(f func(uint64) time.Duration) *DurationStream {
	return FromDurationObservable(MapUint642DurationObserveNext(s, f))
}

func (s *Uint64Stream) FlatMapDuration(f func(uint64) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapUint642Duration{s, f}}
}

type Int64Observer interface {
	Next(int64)
	TerminationObserver
}

// A Int64Subscriber represents a subscribed Int64Observer.
type Int64Subscriber interface {
	Subscription
	Int64Observer
}

type implInt64Subscriber struct {
	Subscription
	Int64Observer
}

func Int64ObserverAsGenericObserver(observer Int64Observer) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(int64))
		}
	})
}

func GenericObserverAsInt64Observer(observer GenericObserver) Int64Observer {
	return Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type Int64ObservableFactory func(observer Int64Observer, subscription Subscription)

func (f Int64ObservableFactory) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateInt64 calls f(observer, subscription) to produce values for a stream.
func CreateInt64(f func(observer Int64Observer, subscription Subscription)) *Int64Stream {
	return FromInt64Observable(Int64ObservableFactory(f))
}

// Repeat value count times.
func RepeatInt64(value int64, count int) *Int64Stream {
	return CreateInt64(func(observer Int64Observer, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartInt64 is designed to be used with functions that return a
// (int64, error) tuple.
//
// If the error is non-nil the returned Int64Stream will be that error,
// otherwise it will be a single-value stream of int64.
func StartInt64(f func() (int64, error)) *Int64Stream {
	return CreateInt64(func(observer Int64Observer, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughInt64(next int64, err error, complete bool, observer Int64Observer) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroInt64 = *new(int64)

type Int64ObserverFunc func(int64, error, bool)

func (f Int64ObserverFunc) Next(next int64) { f(next, nil, false) }
func (f Int64ObserverFunc) Error(err error) { f(zeroInt64, err, false) }
func (f Int64ObserverFunc) Complete()       { f(zeroInt64, nil, true) }

type Int64Observable interface {
	Subscribe(Int64Observer) Subscription
}

// Convert a GenericObservableFilter to a Int64Observable
func (f GenericObservableFilterFactory) Int64(parent Int64Observable) Int64Observable {
	return MapInt642Int64Observable(parent, func(observer Int64Observer) MappingInt642Int64Func {
		gobserver := Int64ObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next int64, err error, complete bool, observer Int64Observer) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverInt64() *Int64Stream {
	return CreateInt64(func(observer Int64Observer, subscription Subscription) {})
}

func EmptyInt64() *Int64Stream {
	return CreateInt64(func(observer Int64Observer, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowInt64(err error) *Int64Stream {
	return CreateInt64(func(observer Int64Observer, subscription Subscription) {
		observer.Error(err)
	})
}

func FromInt64Array(array []int64) *Int64Stream {
	return CreateInt64(func(observer Int64Observer, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromInt64s(array ...int64) *Int64Stream {
	return FromInt64Array(array)
}

func JustInt64(element int64) *Int64Stream {
	return FromInt64Array([]int64{element})
}

func MergeInt64(observables ...Int64Observable) *Int64Stream {
	if len(observables) == 0 {
		return EmptyInt64()
	}
	return (&Int64Stream{observables[0]}).Merge(observables[1:]...)
}

func MergeInt64DelayError(observables ...Int64Observable) *Int64Stream {
	if len(observables) == 0 {
		return EmptyInt64()
	}
	return (&Int64Stream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromInt64Channel(ch <-chan int64) *Int64Stream {
	return CreateInt64(func(observer Int64Observer, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type Int64Stream struct {
	Int64Observable
}

func FromInt64Observable(observable Int64Observable) *Int64Stream {
	return &Int64Stream{observable}
}

func (s *Int64Stream) SubscribeFunc(f func(int64, error, bool)) Subscription {
	return s.Subscribe(Int64ObserverFunc(f))
}

func (s *Int64Stream) SubscribeNext(f func(v int64)) Subscription {
	return s.SubscribeFunc(func(next int64, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *Int64Stream) Distinct() *Int64Stream {
	return FromInt64Observable(distinctFilter().Int64(s))
}

// ElementAt yields the Nth element of the stream.
func (s *Int64Stream) ElementAt(n int) *Int64Stream {
	return FromInt64Observable(elementAtFilter(n).Int64(s))
}

// Filter elements in the stream on a function.
func (s *Int64Stream) Filter(f func(int64) bool) *Int64Stream {
	return FromInt64Observable(filterFilter(func(v interface{}) bool { return f(v.(int64)) }).Int64(s))
}

// Last returns just the first element of the stream.
func (s *Int64Stream) First() *Int64Stream {
	return FromInt64Observable(firstFilter().Int64(s))
}

// Last returns just the last element of the stream.
func (s *Int64Stream) Last() *Int64Stream {
	return FromInt64Observable(lastFilter().Int64(s))
}

// SkipLast skips the first N elements of the stream.
func (s *Int64Stream) Skip(n int) *Int64Stream {
	return FromInt64Observable(skipFilter(n).Int64(s))
}

// SkipLast skips the last N elements of the stream.
func (s *Int64Stream) SkipLast(n int) *Int64Stream {
	return FromInt64Observable(skipLastFilter(n).Int64(s))
}

// Take returns just the first N elements of the stream.
func (s *Int64Stream) Take(n int) *Int64Stream {
	return FromInt64Observable(takeFilter(n).Int64(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *Int64Stream) TakeLast(n int) *Int64Stream {
	return FromInt64Observable(takeLastFilter(n).Int64(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *Int64Stream) IgnoreElements() *Int64Stream {
	return FromInt64Observable(ignoreElementsFilter().Int64(s))
}

func (s *Int64Stream) Replay(size int, duration time.Duration) *Int64Stream {
	return FromInt64Observable(replayFilter(size, duration).Int64(s))
}

func (s *Int64Stream) Sample(duration time.Duration) *Int64Stream {
	return FromInt64Observable(sampleFilter(duration).Int64(s))
}

func (s *Int64Stream) Debounce(duration time.Duration) *Int64Stream {
	return FromInt64Observable(debounceFilter(duration).Int64(s))
}

// Wait for completion of the stream and return any error.
func (s *Int64Stream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeInt64Subscriber(observer Int64Observer) Int64Subscriber {
	if subscriber, ok := observer.(Int64Subscriber); ok {
		return subscriber
	}
	return &implInt64Subscriber{NewGenericSubscription(), observer}
}

type concatInt64Subscriber struct {
	observable  int
	observer    Int64Observer
	observables []Int64Observable
	Subscription
}

func (c *concatInt64Subscriber) Next(next int64) {
	c.observer.Next(next)
}

func (c *concatInt64Subscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatInt64Subscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatInt64Observable struct {
	observables []Int64Observable
}

func (m *concatInt64Observable) Subscribe(observer Int64Observer) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatInt64Subscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *Int64Stream) Concat(observables ...Int64Observable) *Int64Stream {
	return &Int64Stream{&concatInt64Observable{append([]Int64Observable{s}, observables...)}}
}

type mergeInt64Observable struct {
	delayError  bool
	observables []Int64Observable
}

func (m *mergeInt64Observable) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next int64, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(Int64ObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *Int64Stream) Merge(other ...Int64Observable) *Int64Stream {
	if len(other) == 0 {
		return s
	}
	return &Int64Stream{&mergeInt64Observable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *Int64Stream) MergeDelayError(other ...Int64Observable) *Int64Stream {
	if len(other) == 0 {
		return s
	}
	return &Int64Stream{&mergeInt64Observable{true, append(other, s)}}
}

type catchInt64Observable struct {
	parent Int64Observable
	catch  Int64Observable
}

func (r *catchInt64Observable) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	run := func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(Int64ObserverFunc(run))
	return subscription
}

func (s *Int64Stream) Catch(catch Int64Observable) *Int64Stream {
	return &Int64Stream{&catchInt64Observable{s, catch}}
}

type retryInt64Observable struct {
	observable Int64Observable
}

type retryInt64Observer struct {
	observable Int64Observable
	observer   Int64Observer
}

func (r *retryInt64Observer) retry(next int64, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(Int64ObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryInt64Observable) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryInt64Observer{r.observable, observer}
	r.observable.Subscribe(Int64ObserverFunc(ro.retry))
	return subscription
}

func (s *Int64Stream) Retry() *Int64Stream {
	return &Int64Stream{&retryInt64Observable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *Int64Stream) Do(f func(next int64)) *Int64Stream {
	return FromInt64Observable(MapInt642Int64ObserveNext(s, func(next int64) int64 {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *Int64Stream) DoOnError(f func(err error)) *Int64Stream {
	return FromInt64Observable(MapInt642Int64ObserveDirect(s, func(next int64, err error, complete bool, observer Int64Observer) {
		if err != nil {
			f(err)
		}
		PassthroughInt64(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *Int64Stream) DoOnComplete(f func()) *Int64Stream {
	return FromInt64Observable(MapInt642Int64ObserveDirect(s, func(next int64, err error, complete bool, observer Int64Observer) {
		if complete {
			f()
		}
		PassthroughInt64(next, err, complete, observer)
	}))
}

func (s *Int64Stream) Reduce(initial int64, reducer func(int64, int64) int64) *Int64Stream {
	value := initial
	return FromInt64Observable(MapInt642Int64ObserveDirect(s, func(next int64, err error, complete bool, observer Int64Observer) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *Int64Stream) Scan(initial int64, f func(int64, int64) int64) *Int64Stream {
	value := initial
	return FromInt64Observable(MapInt642Int64ObserveDirect(s, func(next int64, err error, complete bool, observer Int64Observer) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutInt64 struct {
	parent  Int64Observable
	timeout time.Duration
}

func (t *timeoutInt64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *Int64Stream) Timeout(timeout time.Duration) *Int64Stream {
	return &Int64Stream{&timeoutInt64{s, timeout}}
}

type forkedInt64Stream struct {
	lock      sync.Mutex
	parent    Int64Observable
	observers []Int64Observer
}

func (f *forkedInt64Stream) Subscribe(observer Int64Observer) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *Int64Stream) Fork() *Int64Stream {
	f := &forkedInt64Stream{parent: s}
	go s.Subscribe(Int64ObserverFunc(func(n int64, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &Int64Stream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *Int64Stream) ToOneWithError() (int64, error) {
	valuech := make(chan int64, 1)
	errch := make(chan error, 1)
	FromInt64Observable(oneFilter().Int64(s)).SubscribeFunc(func(next int64, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroInt64, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *Int64Stream) ToOne() int64 {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *Int64Stream) ToArrayWithError() ([]int64, error) {
	array := []int64{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *Int64Stream) ToArray() []int64 {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *Int64Stream) ToChannelWithError() (<-chan int64, <-chan error) {
	ch := make(chan int64, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *Int64Stream) ToChannel() <-chan int64 {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *Int64Stream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapInt642IntObserveDirect(s, func(next int64, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

func (s *Int64Stream) Average() *Int64Stream {
	var sum int64
	var count int64
	return FromInt64Observable(MapInt642Int64ObserveDirect(s, func(next int64, err error, complete bool, observer Int64Observer) {
		switch {
		case err != nil:
			observer.Next(sum / count)
			observer.Error(err)
		case complete:
			observer.Next(sum / count)
			observer.Complete()
		default:
			sum += next
			count++
		}
	}))
}

func (s *Int64Stream) Sum() *Int64Stream {
	var sum int64
	return FromInt64Observable(MapInt642Int64ObserveDirect(s, func(next int64, err error, complete bool, observer Int64Observer) {
		switch {
		case err != nil:
			observer.Next(sum)
			observer.Error(err)
		case complete:
			observer.Next(sum)
			observer.Complete()
		default:
			sum += next
		}
	}))
}

func (s *Int64Stream) Min() *Int64Stream {
	started := false
	var min int64
	return FromInt64Observable(MapInt642Int64ObserveDirect(s, func(next int64, err error, complete bool, observer Int64Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(min)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(min)
			}
			observer.Complete()
		default:
			if started {
				if min > next {
					min = next
				}
			} else {
				min = next
				started = true
			}
		}
	}))
}

func (s *Int64Stream) Max() *Int64Stream {
	started := false
	var max int64
	return FromInt64Observable(MapInt642Int64ObserveDirect(s, func(next int64, err error, complete bool, observer Int64Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(max)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(max)
			}
			observer.Complete()
		default:
			if started {
				if max <= next {
					max = next
				}
			} else {
				max = next
				started = true
			}
		}
	}))
}

type MappingInt642BoolFunc func(next int64, err error, complete bool, observer BoolObserver)
type MappingInt642BoolFuncFactory func(observer BoolObserver) MappingInt642BoolFunc

type MappingInt642BoolObservable struct {
	parent Int64Observable
	mapper MappingInt642BoolFuncFactory
}

func (f *MappingInt642BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642BoolObservable(parent Int64Observable, mapper MappingInt642BoolFuncFactory) BoolObservable {
	return &MappingInt642BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642BoolObserveDirect(parent Int64Observable, mapper MappingInt642BoolFunc) BoolObservable {
	return MapInt642BoolObservable(parent, func(BoolObserver) MappingInt642BoolFunc {
		return mapper
	})
}

func MapInt642BoolObserveNext(parent Int64Observable, mapper func(int64) bool) BoolObservable {
	return MapInt642BoolObservable(parent, func(BoolObserver) MappingInt642BoolFunc {
		return func(next int64, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Bool struct {
	parent Int64Observable
	mapper func(int64) BoolObservable
}

func (f *flatMapInt642Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *Int64Stream) MapBool(f func(int64) bool) *BoolStream {
	return FromBoolObservable(MapInt642BoolObserveNext(s, f))
}

func (s *Int64Stream) FlatMapBool(f func(int64) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapInt642Bool{s, f}}
}

type MappingInt642RuneFunc func(next int64, err error, complete bool, observer RuneObserver)
type MappingInt642RuneFuncFactory func(observer RuneObserver) MappingInt642RuneFunc

type MappingInt642RuneObservable struct {
	parent Int64Observable
	mapper MappingInt642RuneFuncFactory
}

func (f *MappingInt642RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642RuneObservable(parent Int64Observable, mapper MappingInt642RuneFuncFactory) RuneObservable {
	return &MappingInt642RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642RuneObserveDirect(parent Int64Observable, mapper MappingInt642RuneFunc) RuneObservable {
	return MapInt642RuneObservable(parent, func(RuneObserver) MappingInt642RuneFunc {
		return mapper
	})
}

func MapInt642RuneObserveNext(parent Int64Observable, mapper func(int64) rune) RuneObservable {
	return MapInt642RuneObservable(parent, func(RuneObserver) MappingInt642RuneFunc {
		return func(next int64, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Rune struct {
	parent Int64Observable
	mapper func(int64) RuneObservable
}

func (f *flatMapInt642Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *Int64Stream) MapRune(f func(int64) rune) *RuneStream {
	return FromRuneObservable(MapInt642RuneObserveNext(s, f))
}

func (s *Int64Stream) FlatMapRune(f func(int64) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapInt642Rune{s, f}}
}

type MappingInt642ByteFunc func(next int64, err error, complete bool, observer ByteObserver)
type MappingInt642ByteFuncFactory func(observer ByteObserver) MappingInt642ByteFunc

type MappingInt642ByteObservable struct {
	parent Int64Observable
	mapper MappingInt642ByteFuncFactory
}

func (f *MappingInt642ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642ByteObservable(parent Int64Observable, mapper MappingInt642ByteFuncFactory) ByteObservable {
	return &MappingInt642ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642ByteObserveDirect(parent Int64Observable, mapper MappingInt642ByteFunc) ByteObservable {
	return MapInt642ByteObservable(parent, func(ByteObserver) MappingInt642ByteFunc {
		return mapper
	})
}

func MapInt642ByteObserveNext(parent Int64Observable, mapper func(int64) byte) ByteObservable {
	return MapInt642ByteObservable(parent, func(ByteObserver) MappingInt642ByteFunc {
		return func(next int64, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Byte struct {
	parent Int64Observable
	mapper func(int64) ByteObservable
}

func (f *flatMapInt642Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *Int64Stream) MapByte(f func(int64) byte) *ByteStream {
	return FromByteObservable(MapInt642ByteObserveNext(s, f))
}

func (s *Int64Stream) FlatMapByte(f func(int64) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapInt642Byte{s, f}}
}

type MappingInt642StringFunc func(next int64, err error, complete bool, observer StringObserver)
type MappingInt642StringFuncFactory func(observer StringObserver) MappingInt642StringFunc

type MappingInt642StringObservable struct {
	parent Int64Observable
	mapper MappingInt642StringFuncFactory
}

func (f *MappingInt642StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642StringObservable(parent Int64Observable, mapper MappingInt642StringFuncFactory) StringObservable {
	return &MappingInt642StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642StringObserveDirect(parent Int64Observable, mapper MappingInt642StringFunc) StringObservable {
	return MapInt642StringObservable(parent, func(StringObserver) MappingInt642StringFunc {
		return mapper
	})
}

func MapInt642StringObserveNext(parent Int64Observable, mapper func(int64) string) StringObservable {
	return MapInt642StringObservable(parent, func(StringObserver) MappingInt642StringFunc {
		return func(next int64, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642String struct {
	parent Int64Observable
	mapper func(int64) StringObservable
}

func (f *flatMapInt642String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *Int64Stream) MapString(f func(int64) string) *StringStream {
	return FromStringObservable(MapInt642StringObserveNext(s, f))
}

func (s *Int64Stream) FlatMapString(f func(int64) StringObservable) *StringStream {
	return &StringStream{&flatMapInt642String{s, f}}
}

type MappingInt642UintFunc func(next int64, err error, complete bool, observer UintObserver)
type MappingInt642UintFuncFactory func(observer UintObserver) MappingInt642UintFunc

type MappingInt642UintObservable struct {
	parent Int64Observable
	mapper MappingInt642UintFuncFactory
}

func (f *MappingInt642UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642UintObservable(parent Int64Observable, mapper MappingInt642UintFuncFactory) UintObservable {
	return &MappingInt642UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642UintObserveDirect(parent Int64Observable, mapper MappingInt642UintFunc) UintObservable {
	return MapInt642UintObservable(parent, func(UintObserver) MappingInt642UintFunc {
		return mapper
	})
}

func MapInt642UintObserveNext(parent Int64Observable, mapper func(int64) uint) UintObservable {
	return MapInt642UintObservable(parent, func(UintObserver) MappingInt642UintFunc {
		return func(next int64, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Uint struct {
	parent Int64Observable
	mapper func(int64) UintObservable
}

func (f *flatMapInt642Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *Int64Stream) MapUint(f func(int64) uint) *UintStream {
	return FromUintObservable(MapInt642UintObserveNext(s, f))
}

func (s *Int64Stream) FlatMapUint(f func(int64) UintObservable) *UintStream {
	return &UintStream{&flatMapInt642Uint{s, f}}
}

type MappingInt642IntFunc func(next int64, err error, complete bool, observer IntObserver)
type MappingInt642IntFuncFactory func(observer IntObserver) MappingInt642IntFunc

type MappingInt642IntObservable struct {
	parent Int64Observable
	mapper MappingInt642IntFuncFactory
}

func (f *MappingInt642IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642IntObservable(parent Int64Observable, mapper MappingInt642IntFuncFactory) IntObservable {
	return &MappingInt642IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642IntObserveDirect(parent Int64Observable, mapper MappingInt642IntFunc) IntObservable {
	return MapInt642IntObservable(parent, func(IntObserver) MappingInt642IntFunc {
		return mapper
	})
}

func MapInt642IntObserveNext(parent Int64Observable, mapper func(int64) int) IntObservable {
	return MapInt642IntObservable(parent, func(IntObserver) MappingInt642IntFunc {
		return func(next int64, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Int struct {
	parent Int64Observable
	mapper func(int64) IntObservable
}

func (f *flatMapInt642Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *Int64Stream) MapInt(f func(int64) int) *IntStream {
	return FromIntObservable(MapInt642IntObserveNext(s, f))
}

func (s *Int64Stream) FlatMapInt(f func(int64) IntObservable) *IntStream {
	return &IntStream{&flatMapInt642Int{s, f}}
}

type MappingInt642Uint8Func func(next int64, err error, complete bool, observer Uint8Observer)
type MappingInt642Uint8FuncFactory func(observer Uint8Observer) MappingInt642Uint8Func

type MappingInt642Uint8Observable struct {
	parent Int64Observable
	mapper MappingInt642Uint8FuncFactory
}

func (f *MappingInt642Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642Uint8Observable(parent Int64Observable, mapper MappingInt642Uint8FuncFactory) Uint8Observable {
	return &MappingInt642Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642Uint8ObserveDirect(parent Int64Observable, mapper MappingInt642Uint8Func) Uint8Observable {
	return MapInt642Uint8Observable(parent, func(Uint8Observer) MappingInt642Uint8Func {
		return mapper
	})
}

func MapInt642Uint8ObserveNext(parent Int64Observable, mapper func(int64) uint8) Uint8Observable {
	return MapInt642Uint8Observable(parent, func(Uint8Observer) MappingInt642Uint8Func {
		return func(next int64, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Uint8 struct {
	parent Int64Observable
	mapper func(int64) Uint8Observable
}

func (f *flatMapInt642Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *Int64Stream) MapUint8(f func(int64) uint8) *Uint8Stream {
	return FromUint8Observable(MapInt642Uint8ObserveNext(s, f))
}

func (s *Int64Stream) FlatMapUint8(f func(int64) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapInt642Uint8{s, f}}
}

type MappingInt642Int8Func func(next int64, err error, complete bool, observer Int8Observer)
type MappingInt642Int8FuncFactory func(observer Int8Observer) MappingInt642Int8Func

type MappingInt642Int8Observable struct {
	parent Int64Observable
	mapper MappingInt642Int8FuncFactory
}

func (f *MappingInt642Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642Int8Observable(parent Int64Observable, mapper MappingInt642Int8FuncFactory) Int8Observable {
	return &MappingInt642Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642Int8ObserveDirect(parent Int64Observable, mapper MappingInt642Int8Func) Int8Observable {
	return MapInt642Int8Observable(parent, func(Int8Observer) MappingInt642Int8Func {
		return mapper
	})
}

func MapInt642Int8ObserveNext(parent Int64Observable, mapper func(int64) int8) Int8Observable {
	return MapInt642Int8Observable(parent, func(Int8Observer) MappingInt642Int8Func {
		return func(next int64, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Int8 struct {
	parent Int64Observable
	mapper func(int64) Int8Observable
}

func (f *flatMapInt642Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *Int64Stream) MapInt8(f func(int64) int8) *Int8Stream {
	return FromInt8Observable(MapInt642Int8ObserveNext(s, f))
}

func (s *Int64Stream) FlatMapInt8(f func(int64) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapInt642Int8{s, f}}
}

type MappingInt642Uint16Func func(next int64, err error, complete bool, observer Uint16Observer)
type MappingInt642Uint16FuncFactory func(observer Uint16Observer) MappingInt642Uint16Func

type MappingInt642Uint16Observable struct {
	parent Int64Observable
	mapper MappingInt642Uint16FuncFactory
}

func (f *MappingInt642Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642Uint16Observable(parent Int64Observable, mapper MappingInt642Uint16FuncFactory) Uint16Observable {
	return &MappingInt642Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642Uint16ObserveDirect(parent Int64Observable, mapper MappingInt642Uint16Func) Uint16Observable {
	return MapInt642Uint16Observable(parent, func(Uint16Observer) MappingInt642Uint16Func {
		return mapper
	})
}

func MapInt642Uint16ObserveNext(parent Int64Observable, mapper func(int64) uint16) Uint16Observable {
	return MapInt642Uint16Observable(parent, func(Uint16Observer) MappingInt642Uint16Func {
		return func(next int64, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Uint16 struct {
	parent Int64Observable
	mapper func(int64) Uint16Observable
}

func (f *flatMapInt642Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *Int64Stream) MapUint16(f func(int64) uint16) *Uint16Stream {
	return FromUint16Observable(MapInt642Uint16ObserveNext(s, f))
}

func (s *Int64Stream) FlatMapUint16(f func(int64) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapInt642Uint16{s, f}}
}

type MappingInt642Int16Func func(next int64, err error, complete bool, observer Int16Observer)
type MappingInt642Int16FuncFactory func(observer Int16Observer) MappingInt642Int16Func

type MappingInt642Int16Observable struct {
	parent Int64Observable
	mapper MappingInt642Int16FuncFactory
}

func (f *MappingInt642Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642Int16Observable(parent Int64Observable, mapper MappingInt642Int16FuncFactory) Int16Observable {
	return &MappingInt642Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642Int16ObserveDirect(parent Int64Observable, mapper MappingInt642Int16Func) Int16Observable {
	return MapInt642Int16Observable(parent, func(Int16Observer) MappingInt642Int16Func {
		return mapper
	})
}

func MapInt642Int16ObserveNext(parent Int64Observable, mapper func(int64) int16) Int16Observable {
	return MapInt642Int16Observable(parent, func(Int16Observer) MappingInt642Int16Func {
		return func(next int64, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Int16 struct {
	parent Int64Observable
	mapper func(int64) Int16Observable
}

func (f *flatMapInt642Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *Int64Stream) MapInt16(f func(int64) int16) *Int16Stream {
	return FromInt16Observable(MapInt642Int16ObserveNext(s, f))
}

func (s *Int64Stream) FlatMapInt16(f func(int64) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapInt642Int16{s, f}}
}

type MappingInt642Uint32Func func(next int64, err error, complete bool, observer Uint32Observer)
type MappingInt642Uint32FuncFactory func(observer Uint32Observer) MappingInt642Uint32Func

type MappingInt642Uint32Observable struct {
	parent Int64Observable
	mapper MappingInt642Uint32FuncFactory
}

func (f *MappingInt642Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642Uint32Observable(parent Int64Observable, mapper MappingInt642Uint32FuncFactory) Uint32Observable {
	return &MappingInt642Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642Uint32ObserveDirect(parent Int64Observable, mapper MappingInt642Uint32Func) Uint32Observable {
	return MapInt642Uint32Observable(parent, func(Uint32Observer) MappingInt642Uint32Func {
		return mapper
	})
}

func MapInt642Uint32ObserveNext(parent Int64Observable, mapper func(int64) uint32) Uint32Observable {
	return MapInt642Uint32Observable(parent, func(Uint32Observer) MappingInt642Uint32Func {
		return func(next int64, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Uint32 struct {
	parent Int64Observable
	mapper func(int64) Uint32Observable
}

func (f *flatMapInt642Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *Int64Stream) MapUint32(f func(int64) uint32) *Uint32Stream {
	return FromUint32Observable(MapInt642Uint32ObserveNext(s, f))
}

func (s *Int64Stream) FlatMapUint32(f func(int64) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapInt642Uint32{s, f}}
}

type MappingInt642Int32Func func(next int64, err error, complete bool, observer Int32Observer)
type MappingInt642Int32FuncFactory func(observer Int32Observer) MappingInt642Int32Func

type MappingInt642Int32Observable struct {
	parent Int64Observable
	mapper MappingInt642Int32FuncFactory
}

func (f *MappingInt642Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642Int32Observable(parent Int64Observable, mapper MappingInt642Int32FuncFactory) Int32Observable {
	return &MappingInt642Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642Int32ObserveDirect(parent Int64Observable, mapper MappingInt642Int32Func) Int32Observable {
	return MapInt642Int32Observable(parent, func(Int32Observer) MappingInt642Int32Func {
		return mapper
	})
}

func MapInt642Int32ObserveNext(parent Int64Observable, mapper func(int64) int32) Int32Observable {
	return MapInt642Int32Observable(parent, func(Int32Observer) MappingInt642Int32Func {
		return func(next int64, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Int32 struct {
	parent Int64Observable
	mapper func(int64) Int32Observable
}

func (f *flatMapInt642Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *Int64Stream) MapInt32(f func(int64) int32) *Int32Stream {
	return FromInt32Observable(MapInt642Int32ObserveNext(s, f))
}

func (s *Int64Stream) FlatMapInt32(f func(int64) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapInt642Int32{s, f}}
}

type MappingInt642Uint64Func func(next int64, err error, complete bool, observer Uint64Observer)
type MappingInt642Uint64FuncFactory func(observer Uint64Observer) MappingInt642Uint64Func

type MappingInt642Uint64Observable struct {
	parent Int64Observable
	mapper MappingInt642Uint64FuncFactory
}

func (f *MappingInt642Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642Uint64Observable(parent Int64Observable, mapper MappingInt642Uint64FuncFactory) Uint64Observable {
	return &MappingInt642Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642Uint64ObserveDirect(parent Int64Observable, mapper MappingInt642Uint64Func) Uint64Observable {
	return MapInt642Uint64Observable(parent, func(Uint64Observer) MappingInt642Uint64Func {
		return mapper
	})
}

func MapInt642Uint64ObserveNext(parent Int64Observable, mapper func(int64) uint64) Uint64Observable {
	return MapInt642Uint64Observable(parent, func(Uint64Observer) MappingInt642Uint64Func {
		return func(next int64, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Uint64 struct {
	parent Int64Observable
	mapper func(int64) Uint64Observable
}

func (f *flatMapInt642Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *Int64Stream) MapUint64(f func(int64) uint64) *Uint64Stream {
	return FromUint64Observable(MapInt642Uint64ObserveNext(s, f))
}

func (s *Int64Stream) FlatMapUint64(f func(int64) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapInt642Uint64{s, f}}
}

type MappingInt642Int64Func func(next int64, err error, complete bool, observer Int64Observer)
type MappingInt642Int64FuncFactory func(observer Int64Observer) MappingInt642Int64Func

type MappingInt642Int64Observable struct {
	parent Int64Observable
	mapper MappingInt642Int64FuncFactory
}

func (f *MappingInt642Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642Int64Observable(parent Int64Observable, mapper MappingInt642Int64FuncFactory) Int64Observable {
	return &MappingInt642Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642Int64ObserveDirect(parent Int64Observable, mapper MappingInt642Int64Func) Int64Observable {
	return MapInt642Int64Observable(parent, func(Int64Observer) MappingInt642Int64Func {
		return mapper
	})
}

func MapInt642Int64ObserveNext(parent Int64Observable, mapper func(int64) int64) Int64Observable {
	return MapInt642Int64Observable(parent, func(Int64Observer) MappingInt642Int64Func {
		return func(next int64, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Int64 struct {
	parent Int64Observable
	mapper func(int64) Int64Observable
}

func (f *flatMapInt642Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *Int64Stream) Map(f func(int64) int64) *Int64Stream {
	return FromInt64Observable(MapInt642Int64ObserveNext(s, f))
}

func (s *Int64Stream) FlatMap(f func(int64) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapInt642Int64{s, f}}
}

type MappingInt642Float32Func func(next int64, err error, complete bool, observer Float32Observer)
type MappingInt642Float32FuncFactory func(observer Float32Observer) MappingInt642Float32Func

type MappingInt642Float32Observable struct {
	parent Int64Observable
	mapper MappingInt642Float32FuncFactory
}

func (f *MappingInt642Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642Float32Observable(parent Int64Observable, mapper MappingInt642Float32FuncFactory) Float32Observable {
	return &MappingInt642Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642Float32ObserveDirect(parent Int64Observable, mapper MappingInt642Float32Func) Float32Observable {
	return MapInt642Float32Observable(parent, func(Float32Observer) MappingInt642Float32Func {
		return mapper
	})
}

func MapInt642Float32ObserveNext(parent Int64Observable, mapper func(int64) float32) Float32Observable {
	return MapInt642Float32Observable(parent, func(Float32Observer) MappingInt642Float32Func {
		return func(next int64, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Float32 struct {
	parent Int64Observable
	mapper func(int64) Float32Observable
}

func (f *flatMapInt642Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *Int64Stream) MapFloat32(f func(int64) float32) *Float32Stream {
	return FromFloat32Observable(MapInt642Float32ObserveNext(s, f))
}

func (s *Int64Stream) FlatMapFloat32(f func(int64) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapInt642Float32{s, f}}
}

type MappingInt642Float64Func func(next int64, err error, complete bool, observer Float64Observer)
type MappingInt642Float64FuncFactory func(observer Float64Observer) MappingInt642Float64Func

type MappingInt642Float64Observable struct {
	parent Int64Observable
	mapper MappingInt642Float64FuncFactory
}

func (f *MappingInt642Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642Float64Observable(parent Int64Observable, mapper MappingInt642Float64FuncFactory) Float64Observable {
	return &MappingInt642Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642Float64ObserveDirect(parent Int64Observable, mapper MappingInt642Float64Func) Float64Observable {
	return MapInt642Float64Observable(parent, func(Float64Observer) MappingInt642Float64Func {
		return mapper
	})
}

func MapInt642Float64ObserveNext(parent Int64Observable, mapper func(int64) float64) Float64Observable {
	return MapInt642Float64Observable(parent, func(Float64Observer) MappingInt642Float64Func {
		return func(next int64, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Float64 struct {
	parent Int64Observable
	mapper func(int64) Float64Observable
}

func (f *flatMapInt642Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *Int64Stream) MapFloat64(f func(int64) float64) *Float64Stream {
	return FromFloat64Observable(MapInt642Float64ObserveNext(s, f))
}

func (s *Int64Stream) FlatMapFloat64(f func(int64) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapInt642Float64{s, f}}
}

type MappingInt642Complex64Func func(next int64, err error, complete bool, observer Complex64Observer)
type MappingInt642Complex64FuncFactory func(observer Complex64Observer) MappingInt642Complex64Func

type MappingInt642Complex64Observable struct {
	parent Int64Observable
	mapper MappingInt642Complex64FuncFactory
}

func (f *MappingInt642Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642Complex64Observable(parent Int64Observable, mapper MappingInt642Complex64FuncFactory) Complex64Observable {
	return &MappingInt642Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642Complex64ObserveDirect(parent Int64Observable, mapper MappingInt642Complex64Func) Complex64Observable {
	return MapInt642Complex64Observable(parent, func(Complex64Observer) MappingInt642Complex64Func {
		return mapper
	})
}

func MapInt642Complex64ObserveNext(parent Int64Observable, mapper func(int64) complex64) Complex64Observable {
	return MapInt642Complex64Observable(parent, func(Complex64Observer) MappingInt642Complex64Func {
		return func(next int64, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Complex64 struct {
	parent Int64Observable
	mapper func(int64) Complex64Observable
}

func (f *flatMapInt642Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *Int64Stream) MapComplex64(f func(int64) complex64) *Complex64Stream {
	return FromComplex64Observable(MapInt642Complex64ObserveNext(s, f))
}

func (s *Int64Stream) FlatMapComplex64(f func(int64) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapInt642Complex64{s, f}}
}

type MappingInt642Complex128Func func(next int64, err error, complete bool, observer Complex128Observer)
type MappingInt642Complex128FuncFactory func(observer Complex128Observer) MappingInt642Complex128Func

type MappingInt642Complex128Observable struct {
	parent Int64Observable
	mapper MappingInt642Complex128FuncFactory
}

func (f *MappingInt642Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642Complex128Observable(parent Int64Observable, mapper MappingInt642Complex128FuncFactory) Complex128Observable {
	return &MappingInt642Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642Complex128ObserveDirect(parent Int64Observable, mapper MappingInt642Complex128Func) Complex128Observable {
	return MapInt642Complex128Observable(parent, func(Complex128Observer) MappingInt642Complex128Func {
		return mapper
	})
}

func MapInt642Complex128ObserveNext(parent Int64Observable, mapper func(int64) complex128) Complex128Observable {
	return MapInt642Complex128Observable(parent, func(Complex128Observer) MappingInt642Complex128Func {
		return func(next int64, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Complex128 struct {
	parent Int64Observable
	mapper func(int64) Complex128Observable
}

func (f *flatMapInt642Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *Int64Stream) MapComplex128(f func(int64) complex128) *Complex128Stream {
	return FromComplex128Observable(MapInt642Complex128ObserveNext(s, f))
}

func (s *Int64Stream) FlatMapComplex128(f func(int64) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapInt642Complex128{s, f}}
}

type MappingInt642TimeFunc func(next int64, err error, complete bool, observer TimeObserver)
type MappingInt642TimeFuncFactory func(observer TimeObserver) MappingInt642TimeFunc

type MappingInt642TimeObservable struct {
	parent Int64Observable
	mapper MappingInt642TimeFuncFactory
}

func (f *MappingInt642TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642TimeObservable(parent Int64Observable, mapper MappingInt642TimeFuncFactory) TimeObservable {
	return &MappingInt642TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642TimeObserveDirect(parent Int64Observable, mapper MappingInt642TimeFunc) TimeObservable {
	return MapInt642TimeObservable(parent, func(TimeObserver) MappingInt642TimeFunc {
		return mapper
	})
}

func MapInt642TimeObserveNext(parent Int64Observable, mapper func(int64) time.Time) TimeObservable {
	return MapInt642TimeObservable(parent, func(TimeObserver) MappingInt642TimeFunc {
		return func(next int64, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Time struct {
	parent Int64Observable
	mapper func(int64) TimeObservable
}

func (f *flatMapInt642Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *Int64Stream) MapTime(f func(int64) time.Time) *TimeStream {
	return FromTimeObservable(MapInt642TimeObserveNext(s, f))
}

func (s *Int64Stream) FlatMapTime(f func(int64) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapInt642Time{s, f}}
}

type MappingInt642DurationFunc func(next int64, err error, complete bool, observer DurationObserver)
type MappingInt642DurationFuncFactory func(observer DurationObserver) MappingInt642DurationFunc

type MappingInt642DurationObservable struct {
	parent Int64Observable
	mapper MappingInt642DurationFuncFactory
}

func (f *MappingInt642DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapInt642DurationObservable(parent Int64Observable, mapper MappingInt642DurationFuncFactory) DurationObservable {
	return &MappingInt642DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt642DurationObserveDirect(parent Int64Observable, mapper MappingInt642DurationFunc) DurationObservable {
	return MapInt642DurationObservable(parent, func(DurationObserver) MappingInt642DurationFunc {
		return mapper
	})
}

func MapInt642DurationObserveNext(parent Int64Observable, mapper func(int64) time.Duration) DurationObservable {
	return MapInt642DurationObservable(parent, func(DurationObserver) MappingInt642DurationFunc {
		return func(next int64, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapInt642Duration struct {
	parent Int64Observable
	mapper func(int64) DurationObservable
}

func (f *flatMapInt642Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Int64ObserverFunc(func(next int64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *Int64Stream) MapDuration(f func(int64) time.Duration) *DurationStream {
	return FromDurationObservable(MapInt642DurationObserveNext(s, f))
}

func (s *Int64Stream) FlatMapDuration(f func(int64) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapInt642Duration{s, f}}
}

type Float32Observer interface {
	Next(float32)
	TerminationObserver
}

// A Float32Subscriber represents a subscribed Float32Observer.
type Float32Subscriber interface {
	Subscription
	Float32Observer
}

type implFloat32Subscriber struct {
	Subscription
	Float32Observer
}

func Float32ObserverAsGenericObserver(observer Float32Observer) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(float32))
		}
	})
}

func GenericObserverAsFloat32Observer(observer GenericObserver) Float32Observer {
	return Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type Float32ObservableFactory func(observer Float32Observer, subscription Subscription)

func (f Float32ObservableFactory) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateFloat32 calls f(observer, subscription) to produce values for a stream.
func CreateFloat32(f func(observer Float32Observer, subscription Subscription)) *Float32Stream {
	return FromFloat32Observable(Float32ObservableFactory(f))
}

// Repeat value count times.
func RepeatFloat32(value float32, count int) *Float32Stream {
	return CreateFloat32(func(observer Float32Observer, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartFloat32 is designed to be used with functions that return a
// (float32, error) tuple.
//
// If the error is non-nil the returned Float32Stream will be that error,
// otherwise it will be a single-value stream of float32.
func StartFloat32(f func() (float32, error)) *Float32Stream {
	return CreateFloat32(func(observer Float32Observer, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughFloat32(next float32, err error, complete bool, observer Float32Observer) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroFloat32 = *new(float32)

type Float32ObserverFunc func(float32, error, bool)

func (f Float32ObserverFunc) Next(next float32) { f(next, nil, false) }
func (f Float32ObserverFunc) Error(err error)   { f(zeroFloat32, err, false) }
func (f Float32ObserverFunc) Complete()         { f(zeroFloat32, nil, true) }

type Float32Observable interface {
	Subscribe(Float32Observer) Subscription
}

// Convert a GenericObservableFilter to a Float32Observable
func (f GenericObservableFilterFactory) Float32(parent Float32Observable) Float32Observable {
	return MapFloat322Float32Observable(parent, func(observer Float32Observer) MappingFloat322Float32Func {
		gobserver := Float32ObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next float32, err error, complete bool, observer Float32Observer) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverFloat32() *Float32Stream {
	return CreateFloat32(func(observer Float32Observer, subscription Subscription) {})
}

func EmptyFloat32() *Float32Stream {
	return CreateFloat32(func(observer Float32Observer, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowFloat32(err error) *Float32Stream {
	return CreateFloat32(func(observer Float32Observer, subscription Subscription) {
		observer.Error(err)
	})
}

func FromFloat32Array(array []float32) *Float32Stream {
	return CreateFloat32(func(observer Float32Observer, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromFloat32s(array ...float32) *Float32Stream {
	return FromFloat32Array(array)
}

func JustFloat32(element float32) *Float32Stream {
	return FromFloat32Array([]float32{element})
}

func MergeFloat32(observables ...Float32Observable) *Float32Stream {
	if len(observables) == 0 {
		return EmptyFloat32()
	}
	return (&Float32Stream{observables[0]}).Merge(observables[1:]...)
}

func MergeFloat32DelayError(observables ...Float32Observable) *Float32Stream {
	if len(observables) == 0 {
		return EmptyFloat32()
	}
	return (&Float32Stream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromFloat32Channel(ch <-chan float32) *Float32Stream {
	return CreateFloat32(func(observer Float32Observer, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type Float32Stream struct {
	Float32Observable
}

func FromFloat32Observable(observable Float32Observable) *Float32Stream {
	return &Float32Stream{observable}
}

func (s *Float32Stream) SubscribeFunc(f func(float32, error, bool)) Subscription {
	return s.Subscribe(Float32ObserverFunc(f))
}

func (s *Float32Stream) SubscribeNext(f func(v float32)) Subscription {
	return s.SubscribeFunc(func(next float32, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *Float32Stream) Distinct() *Float32Stream {
	return FromFloat32Observable(distinctFilter().Float32(s))
}

// ElementAt yields the Nth element of the stream.
func (s *Float32Stream) ElementAt(n int) *Float32Stream {
	return FromFloat32Observable(elementAtFilter(n).Float32(s))
}

// Filter elements in the stream on a function.
func (s *Float32Stream) Filter(f func(float32) bool) *Float32Stream {
	return FromFloat32Observable(filterFilter(func(v interface{}) bool { return f(v.(float32)) }).Float32(s))
}

// Last returns just the first element of the stream.
func (s *Float32Stream) First() *Float32Stream {
	return FromFloat32Observable(firstFilter().Float32(s))
}

// Last returns just the last element of the stream.
func (s *Float32Stream) Last() *Float32Stream {
	return FromFloat32Observable(lastFilter().Float32(s))
}

// SkipLast skips the first N elements of the stream.
func (s *Float32Stream) Skip(n int) *Float32Stream {
	return FromFloat32Observable(skipFilter(n).Float32(s))
}

// SkipLast skips the last N elements of the stream.
func (s *Float32Stream) SkipLast(n int) *Float32Stream {
	return FromFloat32Observable(skipLastFilter(n).Float32(s))
}

// Take returns just the first N elements of the stream.
func (s *Float32Stream) Take(n int) *Float32Stream {
	return FromFloat32Observable(takeFilter(n).Float32(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *Float32Stream) TakeLast(n int) *Float32Stream {
	return FromFloat32Observable(takeLastFilter(n).Float32(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *Float32Stream) IgnoreElements() *Float32Stream {
	return FromFloat32Observable(ignoreElementsFilter().Float32(s))
}

func (s *Float32Stream) Replay(size int, duration time.Duration) *Float32Stream {
	return FromFloat32Observable(replayFilter(size, duration).Float32(s))
}

func (s *Float32Stream) Sample(duration time.Duration) *Float32Stream {
	return FromFloat32Observable(sampleFilter(duration).Float32(s))
}

func (s *Float32Stream) Debounce(duration time.Duration) *Float32Stream {
	return FromFloat32Observable(debounceFilter(duration).Float32(s))
}

// Wait for completion of the stream and return any error.
func (s *Float32Stream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeFloat32Subscriber(observer Float32Observer) Float32Subscriber {
	if subscriber, ok := observer.(Float32Subscriber); ok {
		return subscriber
	}
	return &implFloat32Subscriber{NewGenericSubscription(), observer}
}

type concatFloat32Subscriber struct {
	observable  int
	observer    Float32Observer
	observables []Float32Observable
	Subscription
}

func (c *concatFloat32Subscriber) Next(next float32) {
	c.observer.Next(next)
}

func (c *concatFloat32Subscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatFloat32Subscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatFloat32Observable struct {
	observables []Float32Observable
}

func (m *concatFloat32Observable) Subscribe(observer Float32Observer) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatFloat32Subscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *Float32Stream) Concat(observables ...Float32Observable) *Float32Stream {
	return &Float32Stream{&concatFloat32Observable{append([]Float32Observable{s}, observables...)}}
}

type mergeFloat32Observable struct {
	delayError  bool
	observables []Float32Observable
}

func (m *mergeFloat32Observable) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next float32, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(Float32ObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *Float32Stream) Merge(other ...Float32Observable) *Float32Stream {
	if len(other) == 0 {
		return s
	}
	return &Float32Stream{&mergeFloat32Observable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *Float32Stream) MergeDelayError(other ...Float32Observable) *Float32Stream {
	if len(other) == 0 {
		return s
	}
	return &Float32Stream{&mergeFloat32Observable{true, append(other, s)}}
}

type catchFloat32Observable struct {
	parent Float32Observable
	catch  Float32Observable
}

func (r *catchFloat32Observable) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	run := func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(Float32ObserverFunc(run))
	return subscription
}

func (s *Float32Stream) Catch(catch Float32Observable) *Float32Stream {
	return &Float32Stream{&catchFloat32Observable{s, catch}}
}

type retryFloat32Observable struct {
	observable Float32Observable
}

type retryFloat32Observer struct {
	observable Float32Observable
	observer   Float32Observer
}

func (r *retryFloat32Observer) retry(next float32, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(Float32ObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryFloat32Observable) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryFloat32Observer{r.observable, observer}
	r.observable.Subscribe(Float32ObserverFunc(ro.retry))
	return subscription
}

func (s *Float32Stream) Retry() *Float32Stream {
	return &Float32Stream{&retryFloat32Observable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *Float32Stream) Do(f func(next float32)) *Float32Stream {
	return FromFloat32Observable(MapFloat322Float32ObserveNext(s, func(next float32) float32 {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *Float32Stream) DoOnError(f func(err error)) *Float32Stream {
	return FromFloat32Observable(MapFloat322Float32ObserveDirect(s, func(next float32, err error, complete bool, observer Float32Observer) {
		if err != nil {
			f(err)
		}
		PassthroughFloat32(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *Float32Stream) DoOnComplete(f func()) *Float32Stream {
	return FromFloat32Observable(MapFloat322Float32ObserveDirect(s, func(next float32, err error, complete bool, observer Float32Observer) {
		if complete {
			f()
		}
		PassthroughFloat32(next, err, complete, observer)
	}))
}

func (s *Float32Stream) Reduce(initial float32, reducer func(float32, float32) float32) *Float32Stream {
	value := initial
	return FromFloat32Observable(MapFloat322Float32ObserveDirect(s, func(next float32, err error, complete bool, observer Float32Observer) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *Float32Stream) Scan(initial float32, f func(float32, float32) float32) *Float32Stream {
	value := initial
	return FromFloat32Observable(MapFloat322Float32ObserveDirect(s, func(next float32, err error, complete bool, observer Float32Observer) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutFloat32 struct {
	parent  Float32Observable
	timeout time.Duration
}

func (t *timeoutFloat32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *Float32Stream) Timeout(timeout time.Duration) *Float32Stream {
	return &Float32Stream{&timeoutFloat32{s, timeout}}
}

type forkedFloat32Stream struct {
	lock      sync.Mutex
	parent    Float32Observable
	observers []Float32Observer
}

func (f *forkedFloat32Stream) Subscribe(observer Float32Observer) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *Float32Stream) Fork() *Float32Stream {
	f := &forkedFloat32Stream{parent: s}
	go s.Subscribe(Float32ObserverFunc(func(n float32, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &Float32Stream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *Float32Stream) ToOneWithError() (float32, error) {
	valuech := make(chan float32, 1)
	errch := make(chan error, 1)
	FromFloat32Observable(oneFilter().Float32(s)).SubscribeFunc(func(next float32, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroFloat32, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *Float32Stream) ToOne() float32 {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *Float32Stream) ToArrayWithError() ([]float32, error) {
	array := []float32{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *Float32Stream) ToArray() []float32 {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *Float32Stream) ToChannelWithError() (<-chan float32, <-chan error) {
	ch := make(chan float32, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *Float32Stream) ToChannel() <-chan float32 {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *Float32Stream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapFloat322IntObserveDirect(s, func(next float32, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

func (s *Float32Stream) Average() *Float32Stream {
	var sum float32
	var count float32
	return FromFloat32Observable(MapFloat322Float32ObserveDirect(s, func(next float32, err error, complete bool, observer Float32Observer) {
		switch {
		case err != nil:
			observer.Next(sum / count)
			observer.Error(err)
		case complete:
			observer.Next(sum / count)
			observer.Complete()
		default:
			sum += next
			count++
		}
	}))
}

func (s *Float32Stream) Sum() *Float32Stream {
	var sum float32
	return FromFloat32Observable(MapFloat322Float32ObserveDirect(s, func(next float32, err error, complete bool, observer Float32Observer) {
		switch {
		case err != nil:
			observer.Next(sum)
			observer.Error(err)
		case complete:
			observer.Next(sum)
			observer.Complete()
		default:
			sum += next
		}
	}))
}

func (s *Float32Stream) Min() *Float32Stream {
	started := false
	var min float32
	return FromFloat32Observable(MapFloat322Float32ObserveDirect(s, func(next float32, err error, complete bool, observer Float32Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(min)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(min)
			}
			observer.Complete()
		default:
			if started {
				if min > next {
					min = next
				}
			} else {
				min = next
				started = true
			}
		}
	}))
}

func (s *Float32Stream) Max() *Float32Stream {
	started := false
	var max float32
	return FromFloat32Observable(MapFloat322Float32ObserveDirect(s, func(next float32, err error, complete bool, observer Float32Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(max)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(max)
			}
			observer.Complete()
		default:
			if started {
				if max <= next {
					max = next
				}
			} else {
				max = next
				started = true
			}
		}
	}))
}

type MappingFloat322BoolFunc func(next float32, err error, complete bool, observer BoolObserver)
type MappingFloat322BoolFuncFactory func(observer BoolObserver) MappingFloat322BoolFunc

type MappingFloat322BoolObservable struct {
	parent Float32Observable
	mapper MappingFloat322BoolFuncFactory
}

func (f *MappingFloat322BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322BoolObservable(parent Float32Observable, mapper MappingFloat322BoolFuncFactory) BoolObservable {
	return &MappingFloat322BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322BoolObserveDirect(parent Float32Observable, mapper MappingFloat322BoolFunc) BoolObservable {
	return MapFloat322BoolObservable(parent, func(BoolObserver) MappingFloat322BoolFunc {
		return mapper
	})
}

func MapFloat322BoolObserveNext(parent Float32Observable, mapper func(float32) bool) BoolObservable {
	return MapFloat322BoolObservable(parent, func(BoolObserver) MappingFloat322BoolFunc {
		return func(next float32, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Bool struct {
	parent Float32Observable
	mapper func(float32) BoolObservable
}

func (f *flatMapFloat322Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *Float32Stream) MapBool(f func(float32) bool) *BoolStream {
	return FromBoolObservable(MapFloat322BoolObserveNext(s, f))
}

func (s *Float32Stream) FlatMapBool(f func(float32) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapFloat322Bool{s, f}}
}

type MappingFloat322RuneFunc func(next float32, err error, complete bool, observer RuneObserver)
type MappingFloat322RuneFuncFactory func(observer RuneObserver) MappingFloat322RuneFunc

type MappingFloat322RuneObservable struct {
	parent Float32Observable
	mapper MappingFloat322RuneFuncFactory
}

func (f *MappingFloat322RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322RuneObservable(parent Float32Observable, mapper MappingFloat322RuneFuncFactory) RuneObservable {
	return &MappingFloat322RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322RuneObserveDirect(parent Float32Observable, mapper MappingFloat322RuneFunc) RuneObservable {
	return MapFloat322RuneObservable(parent, func(RuneObserver) MappingFloat322RuneFunc {
		return mapper
	})
}

func MapFloat322RuneObserveNext(parent Float32Observable, mapper func(float32) rune) RuneObservable {
	return MapFloat322RuneObservable(parent, func(RuneObserver) MappingFloat322RuneFunc {
		return func(next float32, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Rune struct {
	parent Float32Observable
	mapper func(float32) RuneObservable
}

func (f *flatMapFloat322Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *Float32Stream) MapRune(f func(float32) rune) *RuneStream {
	return FromRuneObservable(MapFloat322RuneObserveNext(s, f))
}

func (s *Float32Stream) FlatMapRune(f func(float32) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapFloat322Rune{s, f}}
}

type MappingFloat322ByteFunc func(next float32, err error, complete bool, observer ByteObserver)
type MappingFloat322ByteFuncFactory func(observer ByteObserver) MappingFloat322ByteFunc

type MappingFloat322ByteObservable struct {
	parent Float32Observable
	mapper MappingFloat322ByteFuncFactory
}

func (f *MappingFloat322ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322ByteObservable(parent Float32Observable, mapper MappingFloat322ByteFuncFactory) ByteObservable {
	return &MappingFloat322ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322ByteObserveDirect(parent Float32Observable, mapper MappingFloat322ByteFunc) ByteObservable {
	return MapFloat322ByteObservable(parent, func(ByteObserver) MappingFloat322ByteFunc {
		return mapper
	})
}

func MapFloat322ByteObserveNext(parent Float32Observable, mapper func(float32) byte) ByteObservable {
	return MapFloat322ByteObservable(parent, func(ByteObserver) MappingFloat322ByteFunc {
		return func(next float32, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Byte struct {
	parent Float32Observable
	mapper func(float32) ByteObservable
}

func (f *flatMapFloat322Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *Float32Stream) MapByte(f func(float32) byte) *ByteStream {
	return FromByteObservable(MapFloat322ByteObserveNext(s, f))
}

func (s *Float32Stream) FlatMapByte(f func(float32) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapFloat322Byte{s, f}}
}

type MappingFloat322StringFunc func(next float32, err error, complete bool, observer StringObserver)
type MappingFloat322StringFuncFactory func(observer StringObserver) MappingFloat322StringFunc

type MappingFloat322StringObservable struct {
	parent Float32Observable
	mapper MappingFloat322StringFuncFactory
}

func (f *MappingFloat322StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322StringObservable(parent Float32Observable, mapper MappingFloat322StringFuncFactory) StringObservable {
	return &MappingFloat322StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322StringObserveDirect(parent Float32Observable, mapper MappingFloat322StringFunc) StringObservable {
	return MapFloat322StringObservable(parent, func(StringObserver) MappingFloat322StringFunc {
		return mapper
	})
}

func MapFloat322StringObserveNext(parent Float32Observable, mapper func(float32) string) StringObservable {
	return MapFloat322StringObservable(parent, func(StringObserver) MappingFloat322StringFunc {
		return func(next float32, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322String struct {
	parent Float32Observable
	mapper func(float32) StringObservable
}

func (f *flatMapFloat322String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *Float32Stream) MapString(f func(float32) string) *StringStream {
	return FromStringObservable(MapFloat322StringObserveNext(s, f))
}

func (s *Float32Stream) FlatMapString(f func(float32) StringObservable) *StringStream {
	return &StringStream{&flatMapFloat322String{s, f}}
}

type MappingFloat322UintFunc func(next float32, err error, complete bool, observer UintObserver)
type MappingFloat322UintFuncFactory func(observer UintObserver) MappingFloat322UintFunc

type MappingFloat322UintObservable struct {
	parent Float32Observable
	mapper MappingFloat322UintFuncFactory
}

func (f *MappingFloat322UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322UintObservable(parent Float32Observable, mapper MappingFloat322UintFuncFactory) UintObservable {
	return &MappingFloat322UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322UintObserveDirect(parent Float32Observable, mapper MappingFloat322UintFunc) UintObservable {
	return MapFloat322UintObservable(parent, func(UintObserver) MappingFloat322UintFunc {
		return mapper
	})
}

func MapFloat322UintObserveNext(parent Float32Observable, mapper func(float32) uint) UintObservable {
	return MapFloat322UintObservable(parent, func(UintObserver) MappingFloat322UintFunc {
		return func(next float32, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Uint struct {
	parent Float32Observable
	mapper func(float32) UintObservable
}

func (f *flatMapFloat322Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *Float32Stream) MapUint(f func(float32) uint) *UintStream {
	return FromUintObservable(MapFloat322UintObserveNext(s, f))
}

func (s *Float32Stream) FlatMapUint(f func(float32) UintObservable) *UintStream {
	return &UintStream{&flatMapFloat322Uint{s, f}}
}

type MappingFloat322IntFunc func(next float32, err error, complete bool, observer IntObserver)
type MappingFloat322IntFuncFactory func(observer IntObserver) MappingFloat322IntFunc

type MappingFloat322IntObservable struct {
	parent Float32Observable
	mapper MappingFloat322IntFuncFactory
}

func (f *MappingFloat322IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322IntObservable(parent Float32Observable, mapper MappingFloat322IntFuncFactory) IntObservable {
	return &MappingFloat322IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322IntObserveDirect(parent Float32Observable, mapper MappingFloat322IntFunc) IntObservable {
	return MapFloat322IntObservable(parent, func(IntObserver) MappingFloat322IntFunc {
		return mapper
	})
}

func MapFloat322IntObserveNext(parent Float32Observable, mapper func(float32) int) IntObservable {
	return MapFloat322IntObservable(parent, func(IntObserver) MappingFloat322IntFunc {
		return func(next float32, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Int struct {
	parent Float32Observable
	mapper func(float32) IntObservable
}

func (f *flatMapFloat322Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *Float32Stream) MapInt(f func(float32) int) *IntStream {
	return FromIntObservable(MapFloat322IntObserveNext(s, f))
}

func (s *Float32Stream) FlatMapInt(f func(float32) IntObservable) *IntStream {
	return &IntStream{&flatMapFloat322Int{s, f}}
}

type MappingFloat322Uint8Func func(next float32, err error, complete bool, observer Uint8Observer)
type MappingFloat322Uint8FuncFactory func(observer Uint8Observer) MappingFloat322Uint8Func

type MappingFloat322Uint8Observable struct {
	parent Float32Observable
	mapper MappingFloat322Uint8FuncFactory
}

func (f *MappingFloat322Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322Uint8Observable(parent Float32Observable, mapper MappingFloat322Uint8FuncFactory) Uint8Observable {
	return &MappingFloat322Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322Uint8ObserveDirect(parent Float32Observable, mapper MappingFloat322Uint8Func) Uint8Observable {
	return MapFloat322Uint8Observable(parent, func(Uint8Observer) MappingFloat322Uint8Func {
		return mapper
	})
}

func MapFloat322Uint8ObserveNext(parent Float32Observable, mapper func(float32) uint8) Uint8Observable {
	return MapFloat322Uint8Observable(parent, func(Uint8Observer) MappingFloat322Uint8Func {
		return func(next float32, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Uint8 struct {
	parent Float32Observable
	mapper func(float32) Uint8Observable
}

func (f *flatMapFloat322Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *Float32Stream) MapUint8(f func(float32) uint8) *Uint8Stream {
	return FromUint8Observable(MapFloat322Uint8ObserveNext(s, f))
}

func (s *Float32Stream) FlatMapUint8(f func(float32) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapFloat322Uint8{s, f}}
}

type MappingFloat322Int8Func func(next float32, err error, complete bool, observer Int8Observer)
type MappingFloat322Int8FuncFactory func(observer Int8Observer) MappingFloat322Int8Func

type MappingFloat322Int8Observable struct {
	parent Float32Observable
	mapper MappingFloat322Int8FuncFactory
}

func (f *MappingFloat322Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322Int8Observable(parent Float32Observable, mapper MappingFloat322Int8FuncFactory) Int8Observable {
	return &MappingFloat322Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322Int8ObserveDirect(parent Float32Observable, mapper MappingFloat322Int8Func) Int8Observable {
	return MapFloat322Int8Observable(parent, func(Int8Observer) MappingFloat322Int8Func {
		return mapper
	})
}

func MapFloat322Int8ObserveNext(parent Float32Observable, mapper func(float32) int8) Int8Observable {
	return MapFloat322Int8Observable(parent, func(Int8Observer) MappingFloat322Int8Func {
		return func(next float32, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Int8 struct {
	parent Float32Observable
	mapper func(float32) Int8Observable
}

func (f *flatMapFloat322Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *Float32Stream) MapInt8(f func(float32) int8) *Int8Stream {
	return FromInt8Observable(MapFloat322Int8ObserveNext(s, f))
}

func (s *Float32Stream) FlatMapInt8(f func(float32) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapFloat322Int8{s, f}}
}

type MappingFloat322Uint16Func func(next float32, err error, complete bool, observer Uint16Observer)
type MappingFloat322Uint16FuncFactory func(observer Uint16Observer) MappingFloat322Uint16Func

type MappingFloat322Uint16Observable struct {
	parent Float32Observable
	mapper MappingFloat322Uint16FuncFactory
}

func (f *MappingFloat322Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322Uint16Observable(parent Float32Observable, mapper MappingFloat322Uint16FuncFactory) Uint16Observable {
	return &MappingFloat322Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322Uint16ObserveDirect(parent Float32Observable, mapper MappingFloat322Uint16Func) Uint16Observable {
	return MapFloat322Uint16Observable(parent, func(Uint16Observer) MappingFloat322Uint16Func {
		return mapper
	})
}

func MapFloat322Uint16ObserveNext(parent Float32Observable, mapper func(float32) uint16) Uint16Observable {
	return MapFloat322Uint16Observable(parent, func(Uint16Observer) MappingFloat322Uint16Func {
		return func(next float32, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Uint16 struct {
	parent Float32Observable
	mapper func(float32) Uint16Observable
}

func (f *flatMapFloat322Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *Float32Stream) MapUint16(f func(float32) uint16) *Uint16Stream {
	return FromUint16Observable(MapFloat322Uint16ObserveNext(s, f))
}

func (s *Float32Stream) FlatMapUint16(f func(float32) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapFloat322Uint16{s, f}}
}

type MappingFloat322Int16Func func(next float32, err error, complete bool, observer Int16Observer)
type MappingFloat322Int16FuncFactory func(observer Int16Observer) MappingFloat322Int16Func

type MappingFloat322Int16Observable struct {
	parent Float32Observable
	mapper MappingFloat322Int16FuncFactory
}

func (f *MappingFloat322Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322Int16Observable(parent Float32Observable, mapper MappingFloat322Int16FuncFactory) Int16Observable {
	return &MappingFloat322Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322Int16ObserveDirect(parent Float32Observable, mapper MappingFloat322Int16Func) Int16Observable {
	return MapFloat322Int16Observable(parent, func(Int16Observer) MappingFloat322Int16Func {
		return mapper
	})
}

func MapFloat322Int16ObserveNext(parent Float32Observable, mapper func(float32) int16) Int16Observable {
	return MapFloat322Int16Observable(parent, func(Int16Observer) MappingFloat322Int16Func {
		return func(next float32, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Int16 struct {
	parent Float32Observable
	mapper func(float32) Int16Observable
}

func (f *flatMapFloat322Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *Float32Stream) MapInt16(f func(float32) int16) *Int16Stream {
	return FromInt16Observable(MapFloat322Int16ObserveNext(s, f))
}

func (s *Float32Stream) FlatMapInt16(f func(float32) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapFloat322Int16{s, f}}
}

type MappingFloat322Uint32Func func(next float32, err error, complete bool, observer Uint32Observer)
type MappingFloat322Uint32FuncFactory func(observer Uint32Observer) MappingFloat322Uint32Func

type MappingFloat322Uint32Observable struct {
	parent Float32Observable
	mapper MappingFloat322Uint32FuncFactory
}

func (f *MappingFloat322Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322Uint32Observable(parent Float32Observable, mapper MappingFloat322Uint32FuncFactory) Uint32Observable {
	return &MappingFloat322Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322Uint32ObserveDirect(parent Float32Observable, mapper MappingFloat322Uint32Func) Uint32Observable {
	return MapFloat322Uint32Observable(parent, func(Uint32Observer) MappingFloat322Uint32Func {
		return mapper
	})
}

func MapFloat322Uint32ObserveNext(parent Float32Observable, mapper func(float32) uint32) Uint32Observable {
	return MapFloat322Uint32Observable(parent, func(Uint32Observer) MappingFloat322Uint32Func {
		return func(next float32, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Uint32 struct {
	parent Float32Observable
	mapper func(float32) Uint32Observable
}

func (f *flatMapFloat322Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *Float32Stream) MapUint32(f func(float32) uint32) *Uint32Stream {
	return FromUint32Observable(MapFloat322Uint32ObserveNext(s, f))
}

func (s *Float32Stream) FlatMapUint32(f func(float32) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapFloat322Uint32{s, f}}
}

type MappingFloat322Int32Func func(next float32, err error, complete bool, observer Int32Observer)
type MappingFloat322Int32FuncFactory func(observer Int32Observer) MappingFloat322Int32Func

type MappingFloat322Int32Observable struct {
	parent Float32Observable
	mapper MappingFloat322Int32FuncFactory
}

func (f *MappingFloat322Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322Int32Observable(parent Float32Observable, mapper MappingFloat322Int32FuncFactory) Int32Observable {
	return &MappingFloat322Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322Int32ObserveDirect(parent Float32Observable, mapper MappingFloat322Int32Func) Int32Observable {
	return MapFloat322Int32Observable(parent, func(Int32Observer) MappingFloat322Int32Func {
		return mapper
	})
}

func MapFloat322Int32ObserveNext(parent Float32Observable, mapper func(float32) int32) Int32Observable {
	return MapFloat322Int32Observable(parent, func(Int32Observer) MappingFloat322Int32Func {
		return func(next float32, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Int32 struct {
	parent Float32Observable
	mapper func(float32) Int32Observable
}

func (f *flatMapFloat322Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *Float32Stream) MapInt32(f func(float32) int32) *Int32Stream {
	return FromInt32Observable(MapFloat322Int32ObserveNext(s, f))
}

func (s *Float32Stream) FlatMapInt32(f func(float32) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapFloat322Int32{s, f}}
}

type MappingFloat322Uint64Func func(next float32, err error, complete bool, observer Uint64Observer)
type MappingFloat322Uint64FuncFactory func(observer Uint64Observer) MappingFloat322Uint64Func

type MappingFloat322Uint64Observable struct {
	parent Float32Observable
	mapper MappingFloat322Uint64FuncFactory
}

func (f *MappingFloat322Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322Uint64Observable(parent Float32Observable, mapper MappingFloat322Uint64FuncFactory) Uint64Observable {
	return &MappingFloat322Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322Uint64ObserveDirect(parent Float32Observable, mapper MappingFloat322Uint64Func) Uint64Observable {
	return MapFloat322Uint64Observable(parent, func(Uint64Observer) MappingFloat322Uint64Func {
		return mapper
	})
}

func MapFloat322Uint64ObserveNext(parent Float32Observable, mapper func(float32) uint64) Uint64Observable {
	return MapFloat322Uint64Observable(parent, func(Uint64Observer) MappingFloat322Uint64Func {
		return func(next float32, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Uint64 struct {
	parent Float32Observable
	mapper func(float32) Uint64Observable
}

func (f *flatMapFloat322Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *Float32Stream) MapUint64(f func(float32) uint64) *Uint64Stream {
	return FromUint64Observable(MapFloat322Uint64ObserveNext(s, f))
}

func (s *Float32Stream) FlatMapUint64(f func(float32) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapFloat322Uint64{s, f}}
}

type MappingFloat322Int64Func func(next float32, err error, complete bool, observer Int64Observer)
type MappingFloat322Int64FuncFactory func(observer Int64Observer) MappingFloat322Int64Func

type MappingFloat322Int64Observable struct {
	parent Float32Observable
	mapper MappingFloat322Int64FuncFactory
}

func (f *MappingFloat322Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322Int64Observable(parent Float32Observable, mapper MappingFloat322Int64FuncFactory) Int64Observable {
	return &MappingFloat322Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322Int64ObserveDirect(parent Float32Observable, mapper MappingFloat322Int64Func) Int64Observable {
	return MapFloat322Int64Observable(parent, func(Int64Observer) MappingFloat322Int64Func {
		return mapper
	})
}

func MapFloat322Int64ObserveNext(parent Float32Observable, mapper func(float32) int64) Int64Observable {
	return MapFloat322Int64Observable(parent, func(Int64Observer) MappingFloat322Int64Func {
		return func(next float32, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Int64 struct {
	parent Float32Observable
	mapper func(float32) Int64Observable
}

func (f *flatMapFloat322Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *Float32Stream) MapInt64(f func(float32) int64) *Int64Stream {
	return FromInt64Observable(MapFloat322Int64ObserveNext(s, f))
}

func (s *Float32Stream) FlatMapInt64(f func(float32) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapFloat322Int64{s, f}}
}

type MappingFloat322Float32Func func(next float32, err error, complete bool, observer Float32Observer)
type MappingFloat322Float32FuncFactory func(observer Float32Observer) MappingFloat322Float32Func

type MappingFloat322Float32Observable struct {
	parent Float32Observable
	mapper MappingFloat322Float32FuncFactory
}

func (f *MappingFloat322Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322Float32Observable(parent Float32Observable, mapper MappingFloat322Float32FuncFactory) Float32Observable {
	return &MappingFloat322Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322Float32ObserveDirect(parent Float32Observable, mapper MappingFloat322Float32Func) Float32Observable {
	return MapFloat322Float32Observable(parent, func(Float32Observer) MappingFloat322Float32Func {
		return mapper
	})
}

func MapFloat322Float32ObserveNext(parent Float32Observable, mapper func(float32) float32) Float32Observable {
	return MapFloat322Float32Observable(parent, func(Float32Observer) MappingFloat322Float32Func {
		return func(next float32, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Float32 struct {
	parent Float32Observable
	mapper func(float32) Float32Observable
}

func (f *flatMapFloat322Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *Float32Stream) Map(f func(float32) float32) *Float32Stream {
	return FromFloat32Observable(MapFloat322Float32ObserveNext(s, f))
}

func (s *Float32Stream) FlatMap(f func(float32) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapFloat322Float32{s, f}}
}

type MappingFloat322Float64Func func(next float32, err error, complete bool, observer Float64Observer)
type MappingFloat322Float64FuncFactory func(observer Float64Observer) MappingFloat322Float64Func

type MappingFloat322Float64Observable struct {
	parent Float32Observable
	mapper MappingFloat322Float64FuncFactory
}

func (f *MappingFloat322Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322Float64Observable(parent Float32Observable, mapper MappingFloat322Float64FuncFactory) Float64Observable {
	return &MappingFloat322Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322Float64ObserveDirect(parent Float32Observable, mapper MappingFloat322Float64Func) Float64Observable {
	return MapFloat322Float64Observable(parent, func(Float64Observer) MappingFloat322Float64Func {
		return mapper
	})
}

func MapFloat322Float64ObserveNext(parent Float32Observable, mapper func(float32) float64) Float64Observable {
	return MapFloat322Float64Observable(parent, func(Float64Observer) MappingFloat322Float64Func {
		return func(next float32, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Float64 struct {
	parent Float32Observable
	mapper func(float32) Float64Observable
}

func (f *flatMapFloat322Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *Float32Stream) MapFloat64(f func(float32) float64) *Float64Stream {
	return FromFloat64Observable(MapFloat322Float64ObserveNext(s, f))
}

func (s *Float32Stream) FlatMapFloat64(f func(float32) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapFloat322Float64{s, f}}
}

type MappingFloat322Complex64Func func(next float32, err error, complete bool, observer Complex64Observer)
type MappingFloat322Complex64FuncFactory func(observer Complex64Observer) MappingFloat322Complex64Func

type MappingFloat322Complex64Observable struct {
	parent Float32Observable
	mapper MappingFloat322Complex64FuncFactory
}

func (f *MappingFloat322Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322Complex64Observable(parent Float32Observable, mapper MappingFloat322Complex64FuncFactory) Complex64Observable {
	return &MappingFloat322Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322Complex64ObserveDirect(parent Float32Observable, mapper MappingFloat322Complex64Func) Complex64Observable {
	return MapFloat322Complex64Observable(parent, func(Complex64Observer) MappingFloat322Complex64Func {
		return mapper
	})
}

func MapFloat322Complex64ObserveNext(parent Float32Observable, mapper func(float32) complex64) Complex64Observable {
	return MapFloat322Complex64Observable(parent, func(Complex64Observer) MappingFloat322Complex64Func {
		return func(next float32, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Complex64 struct {
	parent Float32Observable
	mapper func(float32) Complex64Observable
}

func (f *flatMapFloat322Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *Float32Stream) MapComplex64(f func(float32) complex64) *Complex64Stream {
	return FromComplex64Observable(MapFloat322Complex64ObserveNext(s, f))
}

func (s *Float32Stream) FlatMapComplex64(f func(float32) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapFloat322Complex64{s, f}}
}

type MappingFloat322Complex128Func func(next float32, err error, complete bool, observer Complex128Observer)
type MappingFloat322Complex128FuncFactory func(observer Complex128Observer) MappingFloat322Complex128Func

type MappingFloat322Complex128Observable struct {
	parent Float32Observable
	mapper MappingFloat322Complex128FuncFactory
}

func (f *MappingFloat322Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322Complex128Observable(parent Float32Observable, mapper MappingFloat322Complex128FuncFactory) Complex128Observable {
	return &MappingFloat322Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322Complex128ObserveDirect(parent Float32Observable, mapper MappingFloat322Complex128Func) Complex128Observable {
	return MapFloat322Complex128Observable(parent, func(Complex128Observer) MappingFloat322Complex128Func {
		return mapper
	})
}

func MapFloat322Complex128ObserveNext(parent Float32Observable, mapper func(float32) complex128) Complex128Observable {
	return MapFloat322Complex128Observable(parent, func(Complex128Observer) MappingFloat322Complex128Func {
		return func(next float32, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Complex128 struct {
	parent Float32Observable
	mapper func(float32) Complex128Observable
}

func (f *flatMapFloat322Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *Float32Stream) MapComplex128(f func(float32) complex128) *Complex128Stream {
	return FromComplex128Observable(MapFloat322Complex128ObserveNext(s, f))
}

func (s *Float32Stream) FlatMapComplex128(f func(float32) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapFloat322Complex128{s, f}}
}

type MappingFloat322TimeFunc func(next float32, err error, complete bool, observer TimeObserver)
type MappingFloat322TimeFuncFactory func(observer TimeObserver) MappingFloat322TimeFunc

type MappingFloat322TimeObservable struct {
	parent Float32Observable
	mapper MappingFloat322TimeFuncFactory
}

func (f *MappingFloat322TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322TimeObservable(parent Float32Observable, mapper MappingFloat322TimeFuncFactory) TimeObservable {
	return &MappingFloat322TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322TimeObserveDirect(parent Float32Observable, mapper MappingFloat322TimeFunc) TimeObservable {
	return MapFloat322TimeObservable(parent, func(TimeObserver) MappingFloat322TimeFunc {
		return mapper
	})
}

func MapFloat322TimeObserveNext(parent Float32Observable, mapper func(float32) time.Time) TimeObservable {
	return MapFloat322TimeObservable(parent, func(TimeObserver) MappingFloat322TimeFunc {
		return func(next float32, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Time struct {
	parent Float32Observable
	mapper func(float32) TimeObservable
}

func (f *flatMapFloat322Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *Float32Stream) MapTime(f func(float32) time.Time) *TimeStream {
	return FromTimeObservable(MapFloat322TimeObserveNext(s, f))
}

func (s *Float32Stream) FlatMapTime(f func(float32) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapFloat322Time{s, f}}
}

type MappingFloat322DurationFunc func(next float32, err error, complete bool, observer DurationObserver)
type MappingFloat322DurationFuncFactory func(observer DurationObserver) MappingFloat322DurationFunc

type MappingFloat322DurationObservable struct {
	parent Float32Observable
	mapper MappingFloat322DurationFuncFactory
}

func (f *MappingFloat322DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat322DurationObservable(parent Float32Observable, mapper MappingFloat322DurationFuncFactory) DurationObservable {
	return &MappingFloat322DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322DurationObserveDirect(parent Float32Observable, mapper MappingFloat322DurationFunc) DurationObservable {
	return MapFloat322DurationObservable(parent, func(DurationObserver) MappingFloat322DurationFunc {
		return mapper
	})
}

func MapFloat322DurationObserveNext(parent Float32Observable, mapper func(float32) time.Duration) DurationObservable {
	return MapFloat322DurationObservable(parent, func(DurationObserver) MappingFloat322DurationFunc {
		return func(next float32, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat322Duration struct {
	parent Float32Observable
	mapper func(float32) DurationObservable
}

func (f *flatMapFloat322Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *Float32Stream) MapDuration(f func(float32) time.Duration) *DurationStream {
	return FromDurationObservable(MapFloat322DurationObserveNext(s, f))
}

func (s *Float32Stream) FlatMapDuration(f func(float32) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapFloat322Duration{s, f}}
}

type Float64Observer interface {
	Next(float64)
	TerminationObserver
}

// A Float64Subscriber represents a subscribed Float64Observer.
type Float64Subscriber interface {
	Subscription
	Float64Observer
}

type implFloat64Subscriber struct {
	Subscription
	Float64Observer
}

func Float64ObserverAsGenericObserver(observer Float64Observer) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(float64))
		}
	})
}

func GenericObserverAsFloat64Observer(observer GenericObserver) Float64Observer {
	return Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type Float64ObservableFactory func(observer Float64Observer, subscription Subscription)

func (f Float64ObservableFactory) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateFloat64 calls f(observer, subscription) to produce values for a stream.
func CreateFloat64(f func(observer Float64Observer, subscription Subscription)) *Float64Stream {
	return FromFloat64Observable(Float64ObservableFactory(f))
}

// Repeat value count times.
func RepeatFloat64(value float64, count int) *Float64Stream {
	return CreateFloat64(func(observer Float64Observer, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartFloat64 is designed to be used with functions that return a
// (float64, error) tuple.
//
// If the error is non-nil the returned Float64Stream will be that error,
// otherwise it will be a single-value stream of float64.
func StartFloat64(f func() (float64, error)) *Float64Stream {
	return CreateFloat64(func(observer Float64Observer, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughFloat64(next float64, err error, complete bool, observer Float64Observer) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroFloat64 = *new(float64)

type Float64ObserverFunc func(float64, error, bool)

func (f Float64ObserverFunc) Next(next float64) { f(next, nil, false) }
func (f Float64ObserverFunc) Error(err error)   { f(zeroFloat64, err, false) }
func (f Float64ObserverFunc) Complete()         { f(zeroFloat64, nil, true) }

type Float64Observable interface {
	Subscribe(Float64Observer) Subscription
}

// Convert a GenericObservableFilter to a Float64Observable
func (f GenericObservableFilterFactory) Float64(parent Float64Observable) Float64Observable {
	return MapFloat642Float64Observable(parent, func(observer Float64Observer) MappingFloat642Float64Func {
		gobserver := Float64ObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next float64, err error, complete bool, observer Float64Observer) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverFloat64() *Float64Stream {
	return CreateFloat64(func(observer Float64Observer, subscription Subscription) {})
}

func EmptyFloat64() *Float64Stream {
	return CreateFloat64(func(observer Float64Observer, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowFloat64(err error) *Float64Stream {
	return CreateFloat64(func(observer Float64Observer, subscription Subscription) {
		observer.Error(err)
	})
}

func FromFloat64Array(array []float64) *Float64Stream {
	return CreateFloat64(func(observer Float64Observer, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromFloat64s(array ...float64) *Float64Stream {
	return FromFloat64Array(array)
}

func JustFloat64(element float64) *Float64Stream {
	return FromFloat64Array([]float64{element})
}

func MergeFloat64(observables ...Float64Observable) *Float64Stream {
	if len(observables) == 0 {
		return EmptyFloat64()
	}
	return (&Float64Stream{observables[0]}).Merge(observables[1:]...)
}

func MergeFloat64DelayError(observables ...Float64Observable) *Float64Stream {
	if len(observables) == 0 {
		return EmptyFloat64()
	}
	return (&Float64Stream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromFloat64Channel(ch <-chan float64) *Float64Stream {
	return CreateFloat64(func(observer Float64Observer, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type Float64Stream struct {
	Float64Observable
}

func FromFloat64Observable(observable Float64Observable) *Float64Stream {
	return &Float64Stream{observable}
}

func (s *Float64Stream) SubscribeFunc(f func(float64, error, bool)) Subscription {
	return s.Subscribe(Float64ObserverFunc(f))
}

func (s *Float64Stream) SubscribeNext(f func(v float64)) Subscription {
	return s.SubscribeFunc(func(next float64, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *Float64Stream) Distinct() *Float64Stream {
	return FromFloat64Observable(distinctFilter().Float64(s))
}

// ElementAt yields the Nth element of the stream.
func (s *Float64Stream) ElementAt(n int) *Float64Stream {
	return FromFloat64Observable(elementAtFilter(n).Float64(s))
}

// Filter elements in the stream on a function.
func (s *Float64Stream) Filter(f func(float64) bool) *Float64Stream {
	return FromFloat64Observable(filterFilter(func(v interface{}) bool { return f(v.(float64)) }).Float64(s))
}

// Last returns just the first element of the stream.
func (s *Float64Stream) First() *Float64Stream {
	return FromFloat64Observable(firstFilter().Float64(s))
}

// Last returns just the last element of the stream.
func (s *Float64Stream) Last() *Float64Stream {
	return FromFloat64Observable(lastFilter().Float64(s))
}

// SkipLast skips the first N elements of the stream.
func (s *Float64Stream) Skip(n int) *Float64Stream {
	return FromFloat64Observable(skipFilter(n).Float64(s))
}

// SkipLast skips the last N elements of the stream.
func (s *Float64Stream) SkipLast(n int) *Float64Stream {
	return FromFloat64Observable(skipLastFilter(n).Float64(s))
}

// Take returns just the first N elements of the stream.
func (s *Float64Stream) Take(n int) *Float64Stream {
	return FromFloat64Observable(takeFilter(n).Float64(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *Float64Stream) TakeLast(n int) *Float64Stream {
	return FromFloat64Observable(takeLastFilter(n).Float64(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *Float64Stream) IgnoreElements() *Float64Stream {
	return FromFloat64Observable(ignoreElementsFilter().Float64(s))
}

func (s *Float64Stream) Replay(size int, duration time.Duration) *Float64Stream {
	return FromFloat64Observable(replayFilter(size, duration).Float64(s))
}

func (s *Float64Stream) Sample(duration time.Duration) *Float64Stream {
	return FromFloat64Observable(sampleFilter(duration).Float64(s))
}

func (s *Float64Stream) Debounce(duration time.Duration) *Float64Stream {
	return FromFloat64Observable(debounceFilter(duration).Float64(s))
}

// Wait for completion of the stream and return any error.
func (s *Float64Stream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeFloat64Subscriber(observer Float64Observer) Float64Subscriber {
	if subscriber, ok := observer.(Float64Subscriber); ok {
		return subscriber
	}
	return &implFloat64Subscriber{NewGenericSubscription(), observer}
}

type concatFloat64Subscriber struct {
	observable  int
	observer    Float64Observer
	observables []Float64Observable
	Subscription
}

func (c *concatFloat64Subscriber) Next(next float64) {
	c.observer.Next(next)
}

func (c *concatFloat64Subscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatFloat64Subscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatFloat64Observable struct {
	observables []Float64Observable
}

func (m *concatFloat64Observable) Subscribe(observer Float64Observer) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatFloat64Subscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *Float64Stream) Concat(observables ...Float64Observable) *Float64Stream {
	return &Float64Stream{&concatFloat64Observable{append([]Float64Observable{s}, observables...)}}
}

type mergeFloat64Observable struct {
	delayError  bool
	observables []Float64Observable
}

func (m *mergeFloat64Observable) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next float64, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(Float64ObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *Float64Stream) Merge(other ...Float64Observable) *Float64Stream {
	if len(other) == 0 {
		return s
	}
	return &Float64Stream{&mergeFloat64Observable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *Float64Stream) MergeDelayError(other ...Float64Observable) *Float64Stream {
	if len(other) == 0 {
		return s
	}
	return &Float64Stream{&mergeFloat64Observable{true, append(other, s)}}
}

type catchFloat64Observable struct {
	parent Float64Observable
	catch  Float64Observable
}

func (r *catchFloat64Observable) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	run := func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(Float64ObserverFunc(run))
	return subscription
}

func (s *Float64Stream) Catch(catch Float64Observable) *Float64Stream {
	return &Float64Stream{&catchFloat64Observable{s, catch}}
}

type retryFloat64Observable struct {
	observable Float64Observable
}

type retryFloat64Observer struct {
	observable Float64Observable
	observer   Float64Observer
}

func (r *retryFloat64Observer) retry(next float64, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(Float64ObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryFloat64Observable) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryFloat64Observer{r.observable, observer}
	r.observable.Subscribe(Float64ObserverFunc(ro.retry))
	return subscription
}

func (s *Float64Stream) Retry() *Float64Stream {
	return &Float64Stream{&retryFloat64Observable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *Float64Stream) Do(f func(next float64)) *Float64Stream {
	return FromFloat64Observable(MapFloat642Float64ObserveNext(s, func(next float64) float64 {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *Float64Stream) DoOnError(f func(err error)) *Float64Stream {
	return FromFloat64Observable(MapFloat642Float64ObserveDirect(s, func(next float64, err error, complete bool, observer Float64Observer) {
		if err != nil {
			f(err)
		}
		PassthroughFloat64(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *Float64Stream) DoOnComplete(f func()) *Float64Stream {
	return FromFloat64Observable(MapFloat642Float64ObserveDirect(s, func(next float64, err error, complete bool, observer Float64Observer) {
		if complete {
			f()
		}
		PassthroughFloat64(next, err, complete, observer)
	}))
}

func (s *Float64Stream) Reduce(initial float64, reducer func(float64, float64) float64) *Float64Stream {
	value := initial
	return FromFloat64Observable(MapFloat642Float64ObserveDirect(s, func(next float64, err error, complete bool, observer Float64Observer) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *Float64Stream) Scan(initial float64, f func(float64, float64) float64) *Float64Stream {
	value := initial
	return FromFloat64Observable(MapFloat642Float64ObserveDirect(s, func(next float64, err error, complete bool, observer Float64Observer) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutFloat64 struct {
	parent  Float64Observable
	timeout time.Duration
}

func (t *timeoutFloat64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *Float64Stream) Timeout(timeout time.Duration) *Float64Stream {
	return &Float64Stream{&timeoutFloat64{s, timeout}}
}

type forkedFloat64Stream struct {
	lock      sync.Mutex
	parent    Float64Observable
	observers []Float64Observer
}

func (f *forkedFloat64Stream) Subscribe(observer Float64Observer) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *Float64Stream) Fork() *Float64Stream {
	f := &forkedFloat64Stream{parent: s}
	go s.Subscribe(Float64ObserverFunc(func(n float64, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &Float64Stream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *Float64Stream) ToOneWithError() (float64, error) {
	valuech := make(chan float64, 1)
	errch := make(chan error, 1)
	FromFloat64Observable(oneFilter().Float64(s)).SubscribeFunc(func(next float64, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroFloat64, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *Float64Stream) ToOne() float64 {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *Float64Stream) ToArrayWithError() ([]float64, error) {
	array := []float64{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *Float64Stream) ToArray() []float64 {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *Float64Stream) ToChannelWithError() (<-chan float64, <-chan error) {
	ch := make(chan float64, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *Float64Stream) ToChannel() <-chan float64 {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *Float64Stream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapFloat642IntObserveDirect(s, func(next float64, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

func (s *Float64Stream) Average() *Float64Stream {
	var sum float64
	var count float64
	return FromFloat64Observable(MapFloat642Float64ObserveDirect(s, func(next float64, err error, complete bool, observer Float64Observer) {
		switch {
		case err != nil:
			observer.Next(sum / count)
			observer.Error(err)
		case complete:
			observer.Next(sum / count)
			observer.Complete()
		default:
			sum += next
			count++
		}
	}))
}

func (s *Float64Stream) Sum() *Float64Stream {
	var sum float64
	return FromFloat64Observable(MapFloat642Float64ObserveDirect(s, func(next float64, err error, complete bool, observer Float64Observer) {
		switch {
		case err != nil:
			observer.Next(sum)
			observer.Error(err)
		case complete:
			observer.Next(sum)
			observer.Complete()
		default:
			sum += next
		}
	}))
}

func (s *Float64Stream) Min() *Float64Stream {
	started := false
	var min float64
	return FromFloat64Observable(MapFloat642Float64ObserveDirect(s, func(next float64, err error, complete bool, observer Float64Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(min)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(min)
			}
			observer.Complete()
		default:
			if started {
				if min > next {
					min = next
				}
			} else {
				min = next
				started = true
			}
		}
	}))
}

func (s *Float64Stream) Max() *Float64Stream {
	started := false
	var max float64
	return FromFloat64Observable(MapFloat642Float64ObserveDirect(s, func(next float64, err error, complete bool, observer Float64Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(max)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(max)
			}
			observer.Complete()
		default:
			if started {
				if max <= next {
					max = next
				}
			} else {
				max = next
				started = true
			}
		}
	}))
}

type MappingFloat642BoolFunc func(next float64, err error, complete bool, observer BoolObserver)
type MappingFloat642BoolFuncFactory func(observer BoolObserver) MappingFloat642BoolFunc

type MappingFloat642BoolObservable struct {
	parent Float64Observable
	mapper MappingFloat642BoolFuncFactory
}

func (f *MappingFloat642BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642BoolObservable(parent Float64Observable, mapper MappingFloat642BoolFuncFactory) BoolObservable {
	return &MappingFloat642BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642BoolObserveDirect(parent Float64Observable, mapper MappingFloat642BoolFunc) BoolObservable {
	return MapFloat642BoolObservable(parent, func(BoolObserver) MappingFloat642BoolFunc {
		return mapper
	})
}

func MapFloat642BoolObserveNext(parent Float64Observable, mapper func(float64) bool) BoolObservable {
	return MapFloat642BoolObservable(parent, func(BoolObserver) MappingFloat642BoolFunc {
		return func(next float64, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Bool struct {
	parent Float64Observable
	mapper func(float64) BoolObservable
}

func (f *flatMapFloat642Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *Float64Stream) MapBool(f func(float64) bool) *BoolStream {
	return FromBoolObservable(MapFloat642BoolObserveNext(s, f))
}

func (s *Float64Stream) FlatMapBool(f func(float64) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapFloat642Bool{s, f}}
}

type MappingFloat642RuneFunc func(next float64, err error, complete bool, observer RuneObserver)
type MappingFloat642RuneFuncFactory func(observer RuneObserver) MappingFloat642RuneFunc

type MappingFloat642RuneObservable struct {
	parent Float64Observable
	mapper MappingFloat642RuneFuncFactory
}

func (f *MappingFloat642RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642RuneObservable(parent Float64Observable, mapper MappingFloat642RuneFuncFactory) RuneObservable {
	return &MappingFloat642RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642RuneObserveDirect(parent Float64Observable, mapper MappingFloat642RuneFunc) RuneObservable {
	return MapFloat642RuneObservable(parent, func(RuneObserver) MappingFloat642RuneFunc {
		return mapper
	})
}

func MapFloat642RuneObserveNext(parent Float64Observable, mapper func(float64) rune) RuneObservable {
	return MapFloat642RuneObservable(parent, func(RuneObserver) MappingFloat642RuneFunc {
		return func(next float64, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Rune struct {
	parent Float64Observable
	mapper func(float64) RuneObservable
}

func (f *flatMapFloat642Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *Float64Stream) MapRune(f func(float64) rune) *RuneStream {
	return FromRuneObservable(MapFloat642RuneObserveNext(s, f))
}

func (s *Float64Stream) FlatMapRune(f func(float64) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapFloat642Rune{s, f}}
}

type MappingFloat642ByteFunc func(next float64, err error, complete bool, observer ByteObserver)
type MappingFloat642ByteFuncFactory func(observer ByteObserver) MappingFloat642ByteFunc

type MappingFloat642ByteObservable struct {
	parent Float64Observable
	mapper MappingFloat642ByteFuncFactory
}

func (f *MappingFloat642ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642ByteObservable(parent Float64Observable, mapper MappingFloat642ByteFuncFactory) ByteObservable {
	return &MappingFloat642ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642ByteObserveDirect(parent Float64Observable, mapper MappingFloat642ByteFunc) ByteObservable {
	return MapFloat642ByteObservable(parent, func(ByteObserver) MappingFloat642ByteFunc {
		return mapper
	})
}

func MapFloat642ByteObserveNext(parent Float64Observable, mapper func(float64) byte) ByteObservable {
	return MapFloat642ByteObservable(parent, func(ByteObserver) MappingFloat642ByteFunc {
		return func(next float64, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Byte struct {
	parent Float64Observable
	mapper func(float64) ByteObservable
}

func (f *flatMapFloat642Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *Float64Stream) MapByte(f func(float64) byte) *ByteStream {
	return FromByteObservable(MapFloat642ByteObserveNext(s, f))
}

func (s *Float64Stream) FlatMapByte(f func(float64) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapFloat642Byte{s, f}}
}

type MappingFloat642StringFunc func(next float64, err error, complete bool, observer StringObserver)
type MappingFloat642StringFuncFactory func(observer StringObserver) MappingFloat642StringFunc

type MappingFloat642StringObservable struct {
	parent Float64Observable
	mapper MappingFloat642StringFuncFactory
}

func (f *MappingFloat642StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642StringObservable(parent Float64Observable, mapper MappingFloat642StringFuncFactory) StringObservable {
	return &MappingFloat642StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642StringObserveDirect(parent Float64Observable, mapper MappingFloat642StringFunc) StringObservable {
	return MapFloat642StringObservable(parent, func(StringObserver) MappingFloat642StringFunc {
		return mapper
	})
}

func MapFloat642StringObserveNext(parent Float64Observable, mapper func(float64) string) StringObservable {
	return MapFloat642StringObservable(parent, func(StringObserver) MappingFloat642StringFunc {
		return func(next float64, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642String struct {
	parent Float64Observable
	mapper func(float64) StringObservable
}

func (f *flatMapFloat642String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *Float64Stream) MapString(f func(float64) string) *StringStream {
	return FromStringObservable(MapFloat642StringObserveNext(s, f))
}

func (s *Float64Stream) FlatMapString(f func(float64) StringObservable) *StringStream {
	return &StringStream{&flatMapFloat642String{s, f}}
}

type MappingFloat642UintFunc func(next float64, err error, complete bool, observer UintObserver)
type MappingFloat642UintFuncFactory func(observer UintObserver) MappingFloat642UintFunc

type MappingFloat642UintObservable struct {
	parent Float64Observable
	mapper MappingFloat642UintFuncFactory
}

func (f *MappingFloat642UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642UintObservable(parent Float64Observable, mapper MappingFloat642UintFuncFactory) UintObservable {
	return &MappingFloat642UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642UintObserveDirect(parent Float64Observable, mapper MappingFloat642UintFunc) UintObservable {
	return MapFloat642UintObservable(parent, func(UintObserver) MappingFloat642UintFunc {
		return mapper
	})
}

func MapFloat642UintObserveNext(parent Float64Observable, mapper func(float64) uint) UintObservable {
	return MapFloat642UintObservable(parent, func(UintObserver) MappingFloat642UintFunc {
		return func(next float64, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Uint struct {
	parent Float64Observable
	mapper func(float64) UintObservable
}

func (f *flatMapFloat642Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *Float64Stream) MapUint(f func(float64) uint) *UintStream {
	return FromUintObservable(MapFloat642UintObserveNext(s, f))
}

func (s *Float64Stream) FlatMapUint(f func(float64) UintObservable) *UintStream {
	return &UintStream{&flatMapFloat642Uint{s, f}}
}

type MappingFloat642IntFunc func(next float64, err error, complete bool, observer IntObserver)
type MappingFloat642IntFuncFactory func(observer IntObserver) MappingFloat642IntFunc

type MappingFloat642IntObservable struct {
	parent Float64Observable
	mapper MappingFloat642IntFuncFactory
}

func (f *MappingFloat642IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642IntObservable(parent Float64Observable, mapper MappingFloat642IntFuncFactory) IntObservable {
	return &MappingFloat642IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642IntObserveDirect(parent Float64Observable, mapper MappingFloat642IntFunc) IntObservable {
	return MapFloat642IntObservable(parent, func(IntObserver) MappingFloat642IntFunc {
		return mapper
	})
}

func MapFloat642IntObserveNext(parent Float64Observable, mapper func(float64) int) IntObservable {
	return MapFloat642IntObservable(parent, func(IntObserver) MappingFloat642IntFunc {
		return func(next float64, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Int struct {
	parent Float64Observable
	mapper func(float64) IntObservable
}

func (f *flatMapFloat642Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *Float64Stream) MapInt(f func(float64) int) *IntStream {
	return FromIntObservable(MapFloat642IntObserveNext(s, f))
}

func (s *Float64Stream) FlatMapInt(f func(float64) IntObservable) *IntStream {
	return &IntStream{&flatMapFloat642Int{s, f}}
}

type MappingFloat642Uint8Func func(next float64, err error, complete bool, observer Uint8Observer)
type MappingFloat642Uint8FuncFactory func(observer Uint8Observer) MappingFloat642Uint8Func

type MappingFloat642Uint8Observable struct {
	parent Float64Observable
	mapper MappingFloat642Uint8FuncFactory
}

func (f *MappingFloat642Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642Uint8Observable(parent Float64Observable, mapper MappingFloat642Uint8FuncFactory) Uint8Observable {
	return &MappingFloat642Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642Uint8ObserveDirect(parent Float64Observable, mapper MappingFloat642Uint8Func) Uint8Observable {
	return MapFloat642Uint8Observable(parent, func(Uint8Observer) MappingFloat642Uint8Func {
		return mapper
	})
}

func MapFloat642Uint8ObserveNext(parent Float64Observable, mapper func(float64) uint8) Uint8Observable {
	return MapFloat642Uint8Observable(parent, func(Uint8Observer) MappingFloat642Uint8Func {
		return func(next float64, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Uint8 struct {
	parent Float64Observable
	mapper func(float64) Uint8Observable
}

func (f *flatMapFloat642Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *Float64Stream) MapUint8(f func(float64) uint8) *Uint8Stream {
	return FromUint8Observable(MapFloat642Uint8ObserveNext(s, f))
}

func (s *Float64Stream) FlatMapUint8(f func(float64) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapFloat642Uint8{s, f}}
}

type MappingFloat642Int8Func func(next float64, err error, complete bool, observer Int8Observer)
type MappingFloat642Int8FuncFactory func(observer Int8Observer) MappingFloat642Int8Func

type MappingFloat642Int8Observable struct {
	parent Float64Observable
	mapper MappingFloat642Int8FuncFactory
}

func (f *MappingFloat642Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642Int8Observable(parent Float64Observable, mapper MappingFloat642Int8FuncFactory) Int8Observable {
	return &MappingFloat642Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642Int8ObserveDirect(parent Float64Observable, mapper MappingFloat642Int8Func) Int8Observable {
	return MapFloat642Int8Observable(parent, func(Int8Observer) MappingFloat642Int8Func {
		return mapper
	})
}

func MapFloat642Int8ObserveNext(parent Float64Observable, mapper func(float64) int8) Int8Observable {
	return MapFloat642Int8Observable(parent, func(Int8Observer) MappingFloat642Int8Func {
		return func(next float64, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Int8 struct {
	parent Float64Observable
	mapper func(float64) Int8Observable
}

func (f *flatMapFloat642Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *Float64Stream) MapInt8(f func(float64) int8) *Int8Stream {
	return FromInt8Observable(MapFloat642Int8ObserveNext(s, f))
}

func (s *Float64Stream) FlatMapInt8(f func(float64) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapFloat642Int8{s, f}}
}

type MappingFloat642Uint16Func func(next float64, err error, complete bool, observer Uint16Observer)
type MappingFloat642Uint16FuncFactory func(observer Uint16Observer) MappingFloat642Uint16Func

type MappingFloat642Uint16Observable struct {
	parent Float64Observable
	mapper MappingFloat642Uint16FuncFactory
}

func (f *MappingFloat642Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642Uint16Observable(parent Float64Observable, mapper MappingFloat642Uint16FuncFactory) Uint16Observable {
	return &MappingFloat642Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642Uint16ObserveDirect(parent Float64Observable, mapper MappingFloat642Uint16Func) Uint16Observable {
	return MapFloat642Uint16Observable(parent, func(Uint16Observer) MappingFloat642Uint16Func {
		return mapper
	})
}

func MapFloat642Uint16ObserveNext(parent Float64Observable, mapper func(float64) uint16) Uint16Observable {
	return MapFloat642Uint16Observable(parent, func(Uint16Observer) MappingFloat642Uint16Func {
		return func(next float64, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Uint16 struct {
	parent Float64Observable
	mapper func(float64) Uint16Observable
}

func (f *flatMapFloat642Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *Float64Stream) MapUint16(f func(float64) uint16) *Uint16Stream {
	return FromUint16Observable(MapFloat642Uint16ObserveNext(s, f))
}

func (s *Float64Stream) FlatMapUint16(f func(float64) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapFloat642Uint16{s, f}}
}

type MappingFloat642Int16Func func(next float64, err error, complete bool, observer Int16Observer)
type MappingFloat642Int16FuncFactory func(observer Int16Observer) MappingFloat642Int16Func

type MappingFloat642Int16Observable struct {
	parent Float64Observable
	mapper MappingFloat642Int16FuncFactory
}

func (f *MappingFloat642Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642Int16Observable(parent Float64Observable, mapper MappingFloat642Int16FuncFactory) Int16Observable {
	return &MappingFloat642Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642Int16ObserveDirect(parent Float64Observable, mapper MappingFloat642Int16Func) Int16Observable {
	return MapFloat642Int16Observable(parent, func(Int16Observer) MappingFloat642Int16Func {
		return mapper
	})
}

func MapFloat642Int16ObserveNext(parent Float64Observable, mapper func(float64) int16) Int16Observable {
	return MapFloat642Int16Observable(parent, func(Int16Observer) MappingFloat642Int16Func {
		return func(next float64, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Int16 struct {
	parent Float64Observable
	mapper func(float64) Int16Observable
}

func (f *flatMapFloat642Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *Float64Stream) MapInt16(f func(float64) int16) *Int16Stream {
	return FromInt16Observable(MapFloat642Int16ObserveNext(s, f))
}

func (s *Float64Stream) FlatMapInt16(f func(float64) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapFloat642Int16{s, f}}
}

type MappingFloat642Uint32Func func(next float64, err error, complete bool, observer Uint32Observer)
type MappingFloat642Uint32FuncFactory func(observer Uint32Observer) MappingFloat642Uint32Func

type MappingFloat642Uint32Observable struct {
	parent Float64Observable
	mapper MappingFloat642Uint32FuncFactory
}

func (f *MappingFloat642Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642Uint32Observable(parent Float64Observable, mapper MappingFloat642Uint32FuncFactory) Uint32Observable {
	return &MappingFloat642Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642Uint32ObserveDirect(parent Float64Observable, mapper MappingFloat642Uint32Func) Uint32Observable {
	return MapFloat642Uint32Observable(parent, func(Uint32Observer) MappingFloat642Uint32Func {
		return mapper
	})
}

func MapFloat642Uint32ObserveNext(parent Float64Observable, mapper func(float64) uint32) Uint32Observable {
	return MapFloat642Uint32Observable(parent, func(Uint32Observer) MappingFloat642Uint32Func {
		return func(next float64, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Uint32 struct {
	parent Float64Observable
	mapper func(float64) Uint32Observable
}

func (f *flatMapFloat642Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *Float64Stream) MapUint32(f func(float64) uint32) *Uint32Stream {
	return FromUint32Observable(MapFloat642Uint32ObserveNext(s, f))
}

func (s *Float64Stream) FlatMapUint32(f func(float64) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapFloat642Uint32{s, f}}
}

type MappingFloat642Int32Func func(next float64, err error, complete bool, observer Int32Observer)
type MappingFloat642Int32FuncFactory func(observer Int32Observer) MappingFloat642Int32Func

type MappingFloat642Int32Observable struct {
	parent Float64Observable
	mapper MappingFloat642Int32FuncFactory
}

func (f *MappingFloat642Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642Int32Observable(parent Float64Observable, mapper MappingFloat642Int32FuncFactory) Int32Observable {
	return &MappingFloat642Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642Int32ObserveDirect(parent Float64Observable, mapper MappingFloat642Int32Func) Int32Observable {
	return MapFloat642Int32Observable(parent, func(Int32Observer) MappingFloat642Int32Func {
		return mapper
	})
}

func MapFloat642Int32ObserveNext(parent Float64Observable, mapper func(float64) int32) Int32Observable {
	return MapFloat642Int32Observable(parent, func(Int32Observer) MappingFloat642Int32Func {
		return func(next float64, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Int32 struct {
	parent Float64Observable
	mapper func(float64) Int32Observable
}

func (f *flatMapFloat642Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *Float64Stream) MapInt32(f func(float64) int32) *Int32Stream {
	return FromInt32Observable(MapFloat642Int32ObserveNext(s, f))
}

func (s *Float64Stream) FlatMapInt32(f func(float64) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapFloat642Int32{s, f}}
}

type MappingFloat642Uint64Func func(next float64, err error, complete bool, observer Uint64Observer)
type MappingFloat642Uint64FuncFactory func(observer Uint64Observer) MappingFloat642Uint64Func

type MappingFloat642Uint64Observable struct {
	parent Float64Observable
	mapper MappingFloat642Uint64FuncFactory
}

func (f *MappingFloat642Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642Uint64Observable(parent Float64Observable, mapper MappingFloat642Uint64FuncFactory) Uint64Observable {
	return &MappingFloat642Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642Uint64ObserveDirect(parent Float64Observable, mapper MappingFloat642Uint64Func) Uint64Observable {
	return MapFloat642Uint64Observable(parent, func(Uint64Observer) MappingFloat642Uint64Func {
		return mapper
	})
}

func MapFloat642Uint64ObserveNext(parent Float64Observable, mapper func(float64) uint64) Uint64Observable {
	return MapFloat642Uint64Observable(parent, func(Uint64Observer) MappingFloat642Uint64Func {
		return func(next float64, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Uint64 struct {
	parent Float64Observable
	mapper func(float64) Uint64Observable
}

func (f *flatMapFloat642Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *Float64Stream) MapUint64(f func(float64) uint64) *Uint64Stream {
	return FromUint64Observable(MapFloat642Uint64ObserveNext(s, f))
}

func (s *Float64Stream) FlatMapUint64(f func(float64) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapFloat642Uint64{s, f}}
}

type MappingFloat642Int64Func func(next float64, err error, complete bool, observer Int64Observer)
type MappingFloat642Int64FuncFactory func(observer Int64Observer) MappingFloat642Int64Func

type MappingFloat642Int64Observable struct {
	parent Float64Observable
	mapper MappingFloat642Int64FuncFactory
}

func (f *MappingFloat642Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642Int64Observable(parent Float64Observable, mapper MappingFloat642Int64FuncFactory) Int64Observable {
	return &MappingFloat642Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642Int64ObserveDirect(parent Float64Observable, mapper MappingFloat642Int64Func) Int64Observable {
	return MapFloat642Int64Observable(parent, func(Int64Observer) MappingFloat642Int64Func {
		return mapper
	})
}

func MapFloat642Int64ObserveNext(parent Float64Observable, mapper func(float64) int64) Int64Observable {
	return MapFloat642Int64Observable(parent, func(Int64Observer) MappingFloat642Int64Func {
		return func(next float64, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Int64 struct {
	parent Float64Observable
	mapper func(float64) Int64Observable
}

func (f *flatMapFloat642Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *Float64Stream) MapInt64(f func(float64) int64) *Int64Stream {
	return FromInt64Observable(MapFloat642Int64ObserveNext(s, f))
}

func (s *Float64Stream) FlatMapInt64(f func(float64) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapFloat642Int64{s, f}}
}

type MappingFloat642Float32Func func(next float64, err error, complete bool, observer Float32Observer)
type MappingFloat642Float32FuncFactory func(observer Float32Observer) MappingFloat642Float32Func

type MappingFloat642Float32Observable struct {
	parent Float64Observable
	mapper MappingFloat642Float32FuncFactory
}

func (f *MappingFloat642Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642Float32Observable(parent Float64Observable, mapper MappingFloat642Float32FuncFactory) Float32Observable {
	return &MappingFloat642Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642Float32ObserveDirect(parent Float64Observable, mapper MappingFloat642Float32Func) Float32Observable {
	return MapFloat642Float32Observable(parent, func(Float32Observer) MappingFloat642Float32Func {
		return mapper
	})
}

func MapFloat642Float32ObserveNext(parent Float64Observable, mapper func(float64) float32) Float32Observable {
	return MapFloat642Float32Observable(parent, func(Float32Observer) MappingFloat642Float32Func {
		return func(next float64, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Float32 struct {
	parent Float64Observable
	mapper func(float64) Float32Observable
}

func (f *flatMapFloat642Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *Float64Stream) MapFloat32(f func(float64) float32) *Float32Stream {
	return FromFloat32Observable(MapFloat642Float32ObserveNext(s, f))
}

func (s *Float64Stream) FlatMapFloat32(f func(float64) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapFloat642Float32{s, f}}
}

type MappingFloat642Float64Func func(next float64, err error, complete bool, observer Float64Observer)
type MappingFloat642Float64FuncFactory func(observer Float64Observer) MappingFloat642Float64Func

type MappingFloat642Float64Observable struct {
	parent Float64Observable
	mapper MappingFloat642Float64FuncFactory
}

func (f *MappingFloat642Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642Float64Observable(parent Float64Observable, mapper MappingFloat642Float64FuncFactory) Float64Observable {
	return &MappingFloat642Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642Float64ObserveDirect(parent Float64Observable, mapper MappingFloat642Float64Func) Float64Observable {
	return MapFloat642Float64Observable(parent, func(Float64Observer) MappingFloat642Float64Func {
		return mapper
	})
}

func MapFloat642Float64ObserveNext(parent Float64Observable, mapper func(float64) float64) Float64Observable {
	return MapFloat642Float64Observable(parent, func(Float64Observer) MappingFloat642Float64Func {
		return func(next float64, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Float64 struct {
	parent Float64Observable
	mapper func(float64) Float64Observable
}

func (f *flatMapFloat642Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *Float64Stream) Map(f func(float64) float64) *Float64Stream {
	return FromFloat64Observable(MapFloat642Float64ObserveNext(s, f))
}

func (s *Float64Stream) FlatMap(f func(float64) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapFloat642Float64{s, f}}
}

type MappingFloat642Complex64Func func(next float64, err error, complete bool, observer Complex64Observer)
type MappingFloat642Complex64FuncFactory func(observer Complex64Observer) MappingFloat642Complex64Func

type MappingFloat642Complex64Observable struct {
	parent Float64Observable
	mapper MappingFloat642Complex64FuncFactory
}

func (f *MappingFloat642Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642Complex64Observable(parent Float64Observable, mapper MappingFloat642Complex64FuncFactory) Complex64Observable {
	return &MappingFloat642Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642Complex64ObserveDirect(parent Float64Observable, mapper MappingFloat642Complex64Func) Complex64Observable {
	return MapFloat642Complex64Observable(parent, func(Complex64Observer) MappingFloat642Complex64Func {
		return mapper
	})
}

func MapFloat642Complex64ObserveNext(parent Float64Observable, mapper func(float64) complex64) Complex64Observable {
	return MapFloat642Complex64Observable(parent, func(Complex64Observer) MappingFloat642Complex64Func {
		return func(next float64, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Complex64 struct {
	parent Float64Observable
	mapper func(float64) Complex64Observable
}

func (f *flatMapFloat642Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *Float64Stream) MapComplex64(f func(float64) complex64) *Complex64Stream {
	return FromComplex64Observable(MapFloat642Complex64ObserveNext(s, f))
}

func (s *Float64Stream) FlatMapComplex64(f func(float64) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapFloat642Complex64{s, f}}
}

type MappingFloat642Complex128Func func(next float64, err error, complete bool, observer Complex128Observer)
type MappingFloat642Complex128FuncFactory func(observer Complex128Observer) MappingFloat642Complex128Func

type MappingFloat642Complex128Observable struct {
	parent Float64Observable
	mapper MappingFloat642Complex128FuncFactory
}

func (f *MappingFloat642Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642Complex128Observable(parent Float64Observable, mapper MappingFloat642Complex128FuncFactory) Complex128Observable {
	return &MappingFloat642Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642Complex128ObserveDirect(parent Float64Observable, mapper MappingFloat642Complex128Func) Complex128Observable {
	return MapFloat642Complex128Observable(parent, func(Complex128Observer) MappingFloat642Complex128Func {
		return mapper
	})
}

func MapFloat642Complex128ObserveNext(parent Float64Observable, mapper func(float64) complex128) Complex128Observable {
	return MapFloat642Complex128Observable(parent, func(Complex128Observer) MappingFloat642Complex128Func {
		return func(next float64, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Complex128 struct {
	parent Float64Observable
	mapper func(float64) Complex128Observable
}

func (f *flatMapFloat642Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *Float64Stream) MapComplex128(f func(float64) complex128) *Complex128Stream {
	return FromComplex128Observable(MapFloat642Complex128ObserveNext(s, f))
}

func (s *Float64Stream) FlatMapComplex128(f func(float64) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapFloat642Complex128{s, f}}
}

type MappingFloat642TimeFunc func(next float64, err error, complete bool, observer TimeObserver)
type MappingFloat642TimeFuncFactory func(observer TimeObserver) MappingFloat642TimeFunc

type MappingFloat642TimeObservable struct {
	parent Float64Observable
	mapper MappingFloat642TimeFuncFactory
}

func (f *MappingFloat642TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642TimeObservable(parent Float64Observable, mapper MappingFloat642TimeFuncFactory) TimeObservable {
	return &MappingFloat642TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642TimeObserveDirect(parent Float64Observable, mapper MappingFloat642TimeFunc) TimeObservable {
	return MapFloat642TimeObservable(parent, func(TimeObserver) MappingFloat642TimeFunc {
		return mapper
	})
}

func MapFloat642TimeObserveNext(parent Float64Observable, mapper func(float64) time.Time) TimeObservable {
	return MapFloat642TimeObservable(parent, func(TimeObserver) MappingFloat642TimeFunc {
		return func(next float64, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Time struct {
	parent Float64Observable
	mapper func(float64) TimeObservable
}

func (f *flatMapFloat642Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *Float64Stream) MapTime(f func(float64) time.Time) *TimeStream {
	return FromTimeObservable(MapFloat642TimeObserveNext(s, f))
}

func (s *Float64Stream) FlatMapTime(f func(float64) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapFloat642Time{s, f}}
}

type MappingFloat642DurationFunc func(next float64, err error, complete bool, observer DurationObserver)
type MappingFloat642DurationFuncFactory func(observer DurationObserver) MappingFloat642DurationFunc

type MappingFloat642DurationObservable struct {
	parent Float64Observable
	mapper MappingFloat642DurationFuncFactory
}

func (f *MappingFloat642DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapFloat642DurationObservable(parent Float64Observable, mapper MappingFloat642DurationFuncFactory) DurationObservable {
	return &MappingFloat642DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat642DurationObserveDirect(parent Float64Observable, mapper MappingFloat642DurationFunc) DurationObservable {
	return MapFloat642DurationObservable(parent, func(DurationObserver) MappingFloat642DurationFunc {
		return mapper
	})
}

func MapFloat642DurationObserveNext(parent Float64Observable, mapper func(float64) time.Duration) DurationObservable {
	return MapFloat642DurationObservable(parent, func(DurationObserver) MappingFloat642DurationFunc {
		return func(next float64, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapFloat642Duration struct {
	parent Float64Observable
	mapper func(float64) DurationObservable
}

func (f *flatMapFloat642Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Float64ObserverFunc(func(next float64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *Float64Stream) MapDuration(f func(float64) time.Duration) *DurationStream {
	return FromDurationObservable(MapFloat642DurationObserveNext(s, f))
}

func (s *Float64Stream) FlatMapDuration(f func(float64) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapFloat642Duration{s, f}}
}

type Complex64Observer interface {
	Next(complex64)
	TerminationObserver
}

// A Complex64Subscriber represents a subscribed Complex64Observer.
type Complex64Subscriber interface {
	Subscription
	Complex64Observer
}

type implComplex64Subscriber struct {
	Subscription
	Complex64Observer
}

func Complex64ObserverAsGenericObserver(observer Complex64Observer) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(complex64))
		}
	})
}

func GenericObserverAsComplex64Observer(observer GenericObserver) Complex64Observer {
	return Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type Complex64ObservableFactory func(observer Complex64Observer, subscription Subscription)

func (f Complex64ObservableFactory) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateComplex64 calls f(observer, subscription) to produce values for a stream.
func CreateComplex64(f func(observer Complex64Observer, subscription Subscription)) *Complex64Stream {
	return FromComplex64Observable(Complex64ObservableFactory(f))
}

// Repeat value count times.
func RepeatComplex64(value complex64, count int) *Complex64Stream {
	return CreateComplex64(func(observer Complex64Observer, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartComplex64 is designed to be used with functions that return a
// (complex64, error) tuple.
//
// If the error is non-nil the returned Complex64Stream will be that error,
// otherwise it will be a single-value stream of complex64.
func StartComplex64(f func() (complex64, error)) *Complex64Stream {
	return CreateComplex64(func(observer Complex64Observer, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughComplex64(next complex64, err error, complete bool, observer Complex64Observer) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroComplex64 = *new(complex64)

type Complex64ObserverFunc func(complex64, error, bool)

func (f Complex64ObserverFunc) Next(next complex64) { f(next, nil, false) }
func (f Complex64ObserverFunc) Error(err error)     { f(zeroComplex64, err, false) }
func (f Complex64ObserverFunc) Complete()           { f(zeroComplex64, nil, true) }

type Complex64Observable interface {
	Subscribe(Complex64Observer) Subscription
}

// Convert a GenericObservableFilter to a Complex64Observable
func (f GenericObservableFilterFactory) Complex64(parent Complex64Observable) Complex64Observable {
	return MapComplex642Complex64Observable(parent, func(observer Complex64Observer) MappingComplex642Complex64Func {
		gobserver := Complex64ObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next complex64, err error, complete bool, observer Complex64Observer) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverComplex64() *Complex64Stream {
	return CreateComplex64(func(observer Complex64Observer, subscription Subscription) {})
}

func EmptyComplex64() *Complex64Stream {
	return CreateComplex64(func(observer Complex64Observer, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowComplex64(err error) *Complex64Stream {
	return CreateComplex64(func(observer Complex64Observer, subscription Subscription) {
		observer.Error(err)
	})
}

func FromComplex64Array(array []complex64) *Complex64Stream {
	return CreateComplex64(func(observer Complex64Observer, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromComplex64s(array ...complex64) *Complex64Stream {
	return FromComplex64Array(array)
}

func JustComplex64(element complex64) *Complex64Stream {
	return FromComplex64Array([]complex64{element})
}

func MergeComplex64(observables ...Complex64Observable) *Complex64Stream {
	if len(observables) == 0 {
		return EmptyComplex64()
	}
	return (&Complex64Stream{observables[0]}).Merge(observables[1:]...)
}

func MergeComplex64DelayError(observables ...Complex64Observable) *Complex64Stream {
	if len(observables) == 0 {
		return EmptyComplex64()
	}
	return (&Complex64Stream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromComplex64Channel(ch <-chan complex64) *Complex64Stream {
	return CreateComplex64(func(observer Complex64Observer, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type Complex64Stream struct {
	Complex64Observable
}

func FromComplex64Observable(observable Complex64Observable) *Complex64Stream {
	return &Complex64Stream{observable}
}

func (s *Complex64Stream) SubscribeFunc(f func(complex64, error, bool)) Subscription {
	return s.Subscribe(Complex64ObserverFunc(f))
}

func (s *Complex64Stream) SubscribeNext(f func(v complex64)) Subscription {
	return s.SubscribeFunc(func(next complex64, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *Complex64Stream) Distinct() *Complex64Stream {
	return FromComplex64Observable(distinctFilter().Complex64(s))
}

// ElementAt yields the Nth element of the stream.
func (s *Complex64Stream) ElementAt(n int) *Complex64Stream {
	return FromComplex64Observable(elementAtFilter(n).Complex64(s))
}

// Filter elements in the stream on a function.
func (s *Complex64Stream) Filter(f func(complex64) bool) *Complex64Stream {
	return FromComplex64Observable(filterFilter(func(v interface{}) bool { return f(v.(complex64)) }).Complex64(s))
}

// Last returns just the first element of the stream.
func (s *Complex64Stream) First() *Complex64Stream {
	return FromComplex64Observable(firstFilter().Complex64(s))
}

// Last returns just the last element of the stream.
func (s *Complex64Stream) Last() *Complex64Stream {
	return FromComplex64Observable(lastFilter().Complex64(s))
}

// SkipLast skips the first N elements of the stream.
func (s *Complex64Stream) Skip(n int) *Complex64Stream {
	return FromComplex64Observable(skipFilter(n).Complex64(s))
}

// SkipLast skips the last N elements of the stream.
func (s *Complex64Stream) SkipLast(n int) *Complex64Stream {
	return FromComplex64Observable(skipLastFilter(n).Complex64(s))
}

// Take returns just the first N elements of the stream.
func (s *Complex64Stream) Take(n int) *Complex64Stream {
	return FromComplex64Observable(takeFilter(n).Complex64(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *Complex64Stream) TakeLast(n int) *Complex64Stream {
	return FromComplex64Observable(takeLastFilter(n).Complex64(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *Complex64Stream) IgnoreElements() *Complex64Stream {
	return FromComplex64Observable(ignoreElementsFilter().Complex64(s))
}

func (s *Complex64Stream) Replay(size int, duration time.Duration) *Complex64Stream {
	return FromComplex64Observable(replayFilter(size, duration).Complex64(s))
}

func (s *Complex64Stream) Sample(duration time.Duration) *Complex64Stream {
	return FromComplex64Observable(sampleFilter(duration).Complex64(s))
}

func (s *Complex64Stream) Debounce(duration time.Duration) *Complex64Stream {
	return FromComplex64Observable(debounceFilter(duration).Complex64(s))
}

// Wait for completion of the stream and return any error.
func (s *Complex64Stream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeComplex64Subscriber(observer Complex64Observer) Complex64Subscriber {
	if subscriber, ok := observer.(Complex64Subscriber); ok {
		return subscriber
	}
	return &implComplex64Subscriber{NewGenericSubscription(), observer}
}

type concatComplex64Subscriber struct {
	observable  int
	observer    Complex64Observer
	observables []Complex64Observable
	Subscription
}

func (c *concatComplex64Subscriber) Next(next complex64) {
	c.observer.Next(next)
}

func (c *concatComplex64Subscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatComplex64Subscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatComplex64Observable struct {
	observables []Complex64Observable
}

func (m *concatComplex64Observable) Subscribe(observer Complex64Observer) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatComplex64Subscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *Complex64Stream) Concat(observables ...Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&concatComplex64Observable{append([]Complex64Observable{s}, observables...)}}
}

type mergeComplex64Observable struct {
	delayError  bool
	observables []Complex64Observable
}

func (m *mergeComplex64Observable) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next complex64, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(Complex64ObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *Complex64Stream) Merge(other ...Complex64Observable) *Complex64Stream {
	if len(other) == 0 {
		return s
	}
	return &Complex64Stream{&mergeComplex64Observable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *Complex64Stream) MergeDelayError(other ...Complex64Observable) *Complex64Stream {
	if len(other) == 0 {
		return s
	}
	return &Complex64Stream{&mergeComplex64Observable{true, append(other, s)}}
}

type catchComplex64Observable struct {
	parent Complex64Observable
	catch  Complex64Observable
}

func (r *catchComplex64Observable) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	run := func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(Complex64ObserverFunc(run))
	return subscription
}

func (s *Complex64Stream) Catch(catch Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&catchComplex64Observable{s, catch}}
}

type retryComplex64Observable struct {
	observable Complex64Observable
}

type retryComplex64Observer struct {
	observable Complex64Observable
	observer   Complex64Observer
}

func (r *retryComplex64Observer) retry(next complex64, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(Complex64ObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryComplex64Observable) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryComplex64Observer{r.observable, observer}
	r.observable.Subscribe(Complex64ObserverFunc(ro.retry))
	return subscription
}

func (s *Complex64Stream) Retry() *Complex64Stream {
	return &Complex64Stream{&retryComplex64Observable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *Complex64Stream) Do(f func(next complex64)) *Complex64Stream {
	return FromComplex64Observable(MapComplex642Complex64ObserveNext(s, func(next complex64) complex64 {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *Complex64Stream) DoOnError(f func(err error)) *Complex64Stream {
	return FromComplex64Observable(MapComplex642Complex64ObserveDirect(s, func(next complex64, err error, complete bool, observer Complex64Observer) {
		if err != nil {
			f(err)
		}
		PassthroughComplex64(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *Complex64Stream) DoOnComplete(f func()) *Complex64Stream {
	return FromComplex64Observable(MapComplex642Complex64ObserveDirect(s, func(next complex64, err error, complete bool, observer Complex64Observer) {
		if complete {
			f()
		}
		PassthroughComplex64(next, err, complete, observer)
	}))
}

func (s *Complex64Stream) Reduce(initial complex64, reducer func(complex64, complex64) complex64) *Complex64Stream {
	value := initial
	return FromComplex64Observable(MapComplex642Complex64ObserveDirect(s, func(next complex64, err error, complete bool, observer Complex64Observer) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *Complex64Stream) Scan(initial complex64, f func(complex64, complex64) complex64) *Complex64Stream {
	value := initial
	return FromComplex64Observable(MapComplex642Complex64ObserveDirect(s, func(next complex64, err error, complete bool, observer Complex64Observer) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutComplex64 struct {
	parent  Complex64Observable
	timeout time.Duration
}

func (t *timeoutComplex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *Complex64Stream) Timeout(timeout time.Duration) *Complex64Stream {
	return &Complex64Stream{&timeoutComplex64{s, timeout}}
}

type forkedComplex64Stream struct {
	lock      sync.Mutex
	parent    Complex64Observable
	observers []Complex64Observer
}

func (f *forkedComplex64Stream) Subscribe(observer Complex64Observer) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *Complex64Stream) Fork() *Complex64Stream {
	f := &forkedComplex64Stream{parent: s}
	go s.Subscribe(Complex64ObserverFunc(func(n complex64, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &Complex64Stream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *Complex64Stream) ToOneWithError() (complex64, error) {
	valuech := make(chan complex64, 1)
	errch := make(chan error, 1)
	FromComplex64Observable(oneFilter().Complex64(s)).SubscribeFunc(func(next complex64, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroComplex64, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *Complex64Stream) ToOne() complex64 {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *Complex64Stream) ToArrayWithError() ([]complex64, error) {
	array := []complex64{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *Complex64Stream) ToArray() []complex64 {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *Complex64Stream) ToChannelWithError() (<-chan complex64, <-chan error) {
	ch := make(chan complex64, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *Complex64Stream) ToChannel() <-chan complex64 {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *Complex64Stream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapComplex642IntObserveDirect(s, func(next complex64, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

type MappingComplex642BoolFunc func(next complex64, err error, complete bool, observer BoolObserver)
type MappingComplex642BoolFuncFactory func(observer BoolObserver) MappingComplex642BoolFunc

type MappingComplex642BoolObservable struct {
	parent Complex64Observable
	mapper MappingComplex642BoolFuncFactory
}

func (f *MappingComplex642BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642BoolObservable(parent Complex64Observable, mapper MappingComplex642BoolFuncFactory) BoolObservable {
	return &MappingComplex642BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642BoolObserveDirect(parent Complex64Observable, mapper MappingComplex642BoolFunc) BoolObservable {
	return MapComplex642BoolObservable(parent, func(BoolObserver) MappingComplex642BoolFunc {
		return mapper
	})
}

func MapComplex642BoolObserveNext(parent Complex64Observable, mapper func(complex64) bool) BoolObservable {
	return MapComplex642BoolObservable(parent, func(BoolObserver) MappingComplex642BoolFunc {
		return func(next complex64, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Bool struct {
	parent Complex64Observable
	mapper func(complex64) BoolObservable
}

func (f *flatMapComplex642Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *Complex64Stream) MapBool(f func(complex64) bool) *BoolStream {
	return FromBoolObservable(MapComplex642BoolObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapBool(f func(complex64) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapComplex642Bool{s, f}}
}

type MappingComplex642RuneFunc func(next complex64, err error, complete bool, observer RuneObserver)
type MappingComplex642RuneFuncFactory func(observer RuneObserver) MappingComplex642RuneFunc

type MappingComplex642RuneObservable struct {
	parent Complex64Observable
	mapper MappingComplex642RuneFuncFactory
}

func (f *MappingComplex642RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642RuneObservable(parent Complex64Observable, mapper MappingComplex642RuneFuncFactory) RuneObservable {
	return &MappingComplex642RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642RuneObserveDirect(parent Complex64Observable, mapper MappingComplex642RuneFunc) RuneObservable {
	return MapComplex642RuneObservable(parent, func(RuneObserver) MappingComplex642RuneFunc {
		return mapper
	})
}

func MapComplex642RuneObserveNext(parent Complex64Observable, mapper func(complex64) rune) RuneObservable {
	return MapComplex642RuneObservable(parent, func(RuneObserver) MappingComplex642RuneFunc {
		return func(next complex64, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Rune struct {
	parent Complex64Observable
	mapper func(complex64) RuneObservable
}

func (f *flatMapComplex642Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *Complex64Stream) MapRune(f func(complex64) rune) *RuneStream {
	return FromRuneObservable(MapComplex642RuneObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapRune(f func(complex64) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapComplex642Rune{s, f}}
}

type MappingComplex642ByteFunc func(next complex64, err error, complete bool, observer ByteObserver)
type MappingComplex642ByteFuncFactory func(observer ByteObserver) MappingComplex642ByteFunc

type MappingComplex642ByteObservable struct {
	parent Complex64Observable
	mapper MappingComplex642ByteFuncFactory
}

func (f *MappingComplex642ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642ByteObservable(parent Complex64Observable, mapper MappingComplex642ByteFuncFactory) ByteObservable {
	return &MappingComplex642ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642ByteObserveDirect(parent Complex64Observable, mapper MappingComplex642ByteFunc) ByteObservable {
	return MapComplex642ByteObservable(parent, func(ByteObserver) MappingComplex642ByteFunc {
		return mapper
	})
}

func MapComplex642ByteObserveNext(parent Complex64Observable, mapper func(complex64) byte) ByteObservable {
	return MapComplex642ByteObservable(parent, func(ByteObserver) MappingComplex642ByteFunc {
		return func(next complex64, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Byte struct {
	parent Complex64Observable
	mapper func(complex64) ByteObservable
}

func (f *flatMapComplex642Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *Complex64Stream) MapByte(f func(complex64) byte) *ByteStream {
	return FromByteObservable(MapComplex642ByteObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapByte(f func(complex64) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapComplex642Byte{s, f}}
}

type MappingComplex642StringFunc func(next complex64, err error, complete bool, observer StringObserver)
type MappingComplex642StringFuncFactory func(observer StringObserver) MappingComplex642StringFunc

type MappingComplex642StringObservable struct {
	parent Complex64Observable
	mapper MappingComplex642StringFuncFactory
}

func (f *MappingComplex642StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642StringObservable(parent Complex64Observable, mapper MappingComplex642StringFuncFactory) StringObservable {
	return &MappingComplex642StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642StringObserveDirect(parent Complex64Observable, mapper MappingComplex642StringFunc) StringObservable {
	return MapComplex642StringObservable(parent, func(StringObserver) MappingComplex642StringFunc {
		return mapper
	})
}

func MapComplex642StringObserveNext(parent Complex64Observable, mapper func(complex64) string) StringObservable {
	return MapComplex642StringObservable(parent, func(StringObserver) MappingComplex642StringFunc {
		return func(next complex64, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642String struct {
	parent Complex64Observable
	mapper func(complex64) StringObservable
}

func (f *flatMapComplex642String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *Complex64Stream) MapString(f func(complex64) string) *StringStream {
	return FromStringObservable(MapComplex642StringObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapString(f func(complex64) StringObservable) *StringStream {
	return &StringStream{&flatMapComplex642String{s, f}}
}

type MappingComplex642UintFunc func(next complex64, err error, complete bool, observer UintObserver)
type MappingComplex642UintFuncFactory func(observer UintObserver) MappingComplex642UintFunc

type MappingComplex642UintObservable struct {
	parent Complex64Observable
	mapper MappingComplex642UintFuncFactory
}

func (f *MappingComplex642UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642UintObservable(parent Complex64Observable, mapper MappingComplex642UintFuncFactory) UintObservable {
	return &MappingComplex642UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642UintObserveDirect(parent Complex64Observable, mapper MappingComplex642UintFunc) UintObservable {
	return MapComplex642UintObservable(parent, func(UintObserver) MappingComplex642UintFunc {
		return mapper
	})
}

func MapComplex642UintObserveNext(parent Complex64Observable, mapper func(complex64) uint) UintObservable {
	return MapComplex642UintObservable(parent, func(UintObserver) MappingComplex642UintFunc {
		return func(next complex64, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Uint struct {
	parent Complex64Observable
	mapper func(complex64) UintObservable
}

func (f *flatMapComplex642Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *Complex64Stream) MapUint(f func(complex64) uint) *UintStream {
	return FromUintObservable(MapComplex642UintObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapUint(f func(complex64) UintObservable) *UintStream {
	return &UintStream{&flatMapComplex642Uint{s, f}}
}

type MappingComplex642IntFunc func(next complex64, err error, complete bool, observer IntObserver)
type MappingComplex642IntFuncFactory func(observer IntObserver) MappingComplex642IntFunc

type MappingComplex642IntObservable struct {
	parent Complex64Observable
	mapper MappingComplex642IntFuncFactory
}

func (f *MappingComplex642IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642IntObservable(parent Complex64Observable, mapper MappingComplex642IntFuncFactory) IntObservable {
	return &MappingComplex642IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642IntObserveDirect(parent Complex64Observable, mapper MappingComplex642IntFunc) IntObservable {
	return MapComplex642IntObservable(parent, func(IntObserver) MappingComplex642IntFunc {
		return mapper
	})
}

func MapComplex642IntObserveNext(parent Complex64Observable, mapper func(complex64) int) IntObservable {
	return MapComplex642IntObservable(parent, func(IntObserver) MappingComplex642IntFunc {
		return func(next complex64, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Int struct {
	parent Complex64Observable
	mapper func(complex64) IntObservable
}

func (f *flatMapComplex642Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *Complex64Stream) MapInt(f func(complex64) int) *IntStream {
	return FromIntObservable(MapComplex642IntObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapInt(f func(complex64) IntObservable) *IntStream {
	return &IntStream{&flatMapComplex642Int{s, f}}
}

type MappingComplex642Uint8Func func(next complex64, err error, complete bool, observer Uint8Observer)
type MappingComplex642Uint8FuncFactory func(observer Uint8Observer) MappingComplex642Uint8Func

type MappingComplex642Uint8Observable struct {
	parent Complex64Observable
	mapper MappingComplex642Uint8FuncFactory
}

func (f *MappingComplex642Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642Uint8Observable(parent Complex64Observable, mapper MappingComplex642Uint8FuncFactory) Uint8Observable {
	return &MappingComplex642Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642Uint8ObserveDirect(parent Complex64Observable, mapper MappingComplex642Uint8Func) Uint8Observable {
	return MapComplex642Uint8Observable(parent, func(Uint8Observer) MappingComplex642Uint8Func {
		return mapper
	})
}

func MapComplex642Uint8ObserveNext(parent Complex64Observable, mapper func(complex64) uint8) Uint8Observable {
	return MapComplex642Uint8Observable(parent, func(Uint8Observer) MappingComplex642Uint8Func {
		return func(next complex64, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Uint8 struct {
	parent Complex64Observable
	mapper func(complex64) Uint8Observable
}

func (f *flatMapComplex642Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *Complex64Stream) MapUint8(f func(complex64) uint8) *Uint8Stream {
	return FromUint8Observable(MapComplex642Uint8ObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapUint8(f func(complex64) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapComplex642Uint8{s, f}}
}

type MappingComplex642Int8Func func(next complex64, err error, complete bool, observer Int8Observer)
type MappingComplex642Int8FuncFactory func(observer Int8Observer) MappingComplex642Int8Func

type MappingComplex642Int8Observable struct {
	parent Complex64Observable
	mapper MappingComplex642Int8FuncFactory
}

func (f *MappingComplex642Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642Int8Observable(parent Complex64Observable, mapper MappingComplex642Int8FuncFactory) Int8Observable {
	return &MappingComplex642Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642Int8ObserveDirect(parent Complex64Observable, mapper MappingComplex642Int8Func) Int8Observable {
	return MapComplex642Int8Observable(parent, func(Int8Observer) MappingComplex642Int8Func {
		return mapper
	})
}

func MapComplex642Int8ObserveNext(parent Complex64Observable, mapper func(complex64) int8) Int8Observable {
	return MapComplex642Int8Observable(parent, func(Int8Observer) MappingComplex642Int8Func {
		return func(next complex64, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Int8 struct {
	parent Complex64Observable
	mapper func(complex64) Int8Observable
}

func (f *flatMapComplex642Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *Complex64Stream) MapInt8(f func(complex64) int8) *Int8Stream {
	return FromInt8Observable(MapComplex642Int8ObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapInt8(f func(complex64) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapComplex642Int8{s, f}}
}

type MappingComplex642Uint16Func func(next complex64, err error, complete bool, observer Uint16Observer)
type MappingComplex642Uint16FuncFactory func(observer Uint16Observer) MappingComplex642Uint16Func

type MappingComplex642Uint16Observable struct {
	parent Complex64Observable
	mapper MappingComplex642Uint16FuncFactory
}

func (f *MappingComplex642Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642Uint16Observable(parent Complex64Observable, mapper MappingComplex642Uint16FuncFactory) Uint16Observable {
	return &MappingComplex642Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642Uint16ObserveDirect(parent Complex64Observable, mapper MappingComplex642Uint16Func) Uint16Observable {
	return MapComplex642Uint16Observable(parent, func(Uint16Observer) MappingComplex642Uint16Func {
		return mapper
	})
}

func MapComplex642Uint16ObserveNext(parent Complex64Observable, mapper func(complex64) uint16) Uint16Observable {
	return MapComplex642Uint16Observable(parent, func(Uint16Observer) MappingComplex642Uint16Func {
		return func(next complex64, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Uint16 struct {
	parent Complex64Observable
	mapper func(complex64) Uint16Observable
}

func (f *flatMapComplex642Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *Complex64Stream) MapUint16(f func(complex64) uint16) *Uint16Stream {
	return FromUint16Observable(MapComplex642Uint16ObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapUint16(f func(complex64) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapComplex642Uint16{s, f}}
}

type MappingComplex642Int16Func func(next complex64, err error, complete bool, observer Int16Observer)
type MappingComplex642Int16FuncFactory func(observer Int16Observer) MappingComplex642Int16Func

type MappingComplex642Int16Observable struct {
	parent Complex64Observable
	mapper MappingComplex642Int16FuncFactory
}

func (f *MappingComplex642Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642Int16Observable(parent Complex64Observable, mapper MappingComplex642Int16FuncFactory) Int16Observable {
	return &MappingComplex642Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642Int16ObserveDirect(parent Complex64Observable, mapper MappingComplex642Int16Func) Int16Observable {
	return MapComplex642Int16Observable(parent, func(Int16Observer) MappingComplex642Int16Func {
		return mapper
	})
}

func MapComplex642Int16ObserveNext(parent Complex64Observable, mapper func(complex64) int16) Int16Observable {
	return MapComplex642Int16Observable(parent, func(Int16Observer) MappingComplex642Int16Func {
		return func(next complex64, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Int16 struct {
	parent Complex64Observable
	mapper func(complex64) Int16Observable
}

func (f *flatMapComplex642Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *Complex64Stream) MapInt16(f func(complex64) int16) *Int16Stream {
	return FromInt16Observable(MapComplex642Int16ObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapInt16(f func(complex64) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapComplex642Int16{s, f}}
}

type MappingComplex642Uint32Func func(next complex64, err error, complete bool, observer Uint32Observer)
type MappingComplex642Uint32FuncFactory func(observer Uint32Observer) MappingComplex642Uint32Func

type MappingComplex642Uint32Observable struct {
	parent Complex64Observable
	mapper MappingComplex642Uint32FuncFactory
}

func (f *MappingComplex642Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642Uint32Observable(parent Complex64Observable, mapper MappingComplex642Uint32FuncFactory) Uint32Observable {
	return &MappingComplex642Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642Uint32ObserveDirect(parent Complex64Observable, mapper MappingComplex642Uint32Func) Uint32Observable {
	return MapComplex642Uint32Observable(parent, func(Uint32Observer) MappingComplex642Uint32Func {
		return mapper
	})
}

func MapComplex642Uint32ObserveNext(parent Complex64Observable, mapper func(complex64) uint32) Uint32Observable {
	return MapComplex642Uint32Observable(parent, func(Uint32Observer) MappingComplex642Uint32Func {
		return func(next complex64, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Uint32 struct {
	parent Complex64Observable
	mapper func(complex64) Uint32Observable
}

func (f *flatMapComplex642Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *Complex64Stream) MapUint32(f func(complex64) uint32) *Uint32Stream {
	return FromUint32Observable(MapComplex642Uint32ObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapUint32(f func(complex64) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapComplex642Uint32{s, f}}
}

type MappingComplex642Int32Func func(next complex64, err error, complete bool, observer Int32Observer)
type MappingComplex642Int32FuncFactory func(observer Int32Observer) MappingComplex642Int32Func

type MappingComplex642Int32Observable struct {
	parent Complex64Observable
	mapper MappingComplex642Int32FuncFactory
}

func (f *MappingComplex642Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642Int32Observable(parent Complex64Observable, mapper MappingComplex642Int32FuncFactory) Int32Observable {
	return &MappingComplex642Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642Int32ObserveDirect(parent Complex64Observable, mapper MappingComplex642Int32Func) Int32Observable {
	return MapComplex642Int32Observable(parent, func(Int32Observer) MappingComplex642Int32Func {
		return mapper
	})
}

func MapComplex642Int32ObserveNext(parent Complex64Observable, mapper func(complex64) int32) Int32Observable {
	return MapComplex642Int32Observable(parent, func(Int32Observer) MappingComplex642Int32Func {
		return func(next complex64, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Int32 struct {
	parent Complex64Observable
	mapper func(complex64) Int32Observable
}

func (f *flatMapComplex642Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *Complex64Stream) MapInt32(f func(complex64) int32) *Int32Stream {
	return FromInt32Observable(MapComplex642Int32ObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapInt32(f func(complex64) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapComplex642Int32{s, f}}
}

type MappingComplex642Uint64Func func(next complex64, err error, complete bool, observer Uint64Observer)
type MappingComplex642Uint64FuncFactory func(observer Uint64Observer) MappingComplex642Uint64Func

type MappingComplex642Uint64Observable struct {
	parent Complex64Observable
	mapper MappingComplex642Uint64FuncFactory
}

func (f *MappingComplex642Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642Uint64Observable(parent Complex64Observable, mapper MappingComplex642Uint64FuncFactory) Uint64Observable {
	return &MappingComplex642Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642Uint64ObserveDirect(parent Complex64Observable, mapper MappingComplex642Uint64Func) Uint64Observable {
	return MapComplex642Uint64Observable(parent, func(Uint64Observer) MappingComplex642Uint64Func {
		return mapper
	})
}

func MapComplex642Uint64ObserveNext(parent Complex64Observable, mapper func(complex64) uint64) Uint64Observable {
	return MapComplex642Uint64Observable(parent, func(Uint64Observer) MappingComplex642Uint64Func {
		return func(next complex64, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Uint64 struct {
	parent Complex64Observable
	mapper func(complex64) Uint64Observable
}

func (f *flatMapComplex642Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *Complex64Stream) MapUint64(f func(complex64) uint64) *Uint64Stream {
	return FromUint64Observable(MapComplex642Uint64ObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapUint64(f func(complex64) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapComplex642Uint64{s, f}}
}

type MappingComplex642Int64Func func(next complex64, err error, complete bool, observer Int64Observer)
type MappingComplex642Int64FuncFactory func(observer Int64Observer) MappingComplex642Int64Func

type MappingComplex642Int64Observable struct {
	parent Complex64Observable
	mapper MappingComplex642Int64FuncFactory
}

func (f *MappingComplex642Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642Int64Observable(parent Complex64Observable, mapper MappingComplex642Int64FuncFactory) Int64Observable {
	return &MappingComplex642Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642Int64ObserveDirect(parent Complex64Observable, mapper MappingComplex642Int64Func) Int64Observable {
	return MapComplex642Int64Observable(parent, func(Int64Observer) MappingComplex642Int64Func {
		return mapper
	})
}

func MapComplex642Int64ObserveNext(parent Complex64Observable, mapper func(complex64) int64) Int64Observable {
	return MapComplex642Int64Observable(parent, func(Int64Observer) MappingComplex642Int64Func {
		return func(next complex64, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Int64 struct {
	parent Complex64Observable
	mapper func(complex64) Int64Observable
}

func (f *flatMapComplex642Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *Complex64Stream) MapInt64(f func(complex64) int64) *Int64Stream {
	return FromInt64Observable(MapComplex642Int64ObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapInt64(f func(complex64) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapComplex642Int64{s, f}}
}

type MappingComplex642Float32Func func(next complex64, err error, complete bool, observer Float32Observer)
type MappingComplex642Float32FuncFactory func(observer Float32Observer) MappingComplex642Float32Func

type MappingComplex642Float32Observable struct {
	parent Complex64Observable
	mapper MappingComplex642Float32FuncFactory
}

func (f *MappingComplex642Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642Float32Observable(parent Complex64Observable, mapper MappingComplex642Float32FuncFactory) Float32Observable {
	return &MappingComplex642Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642Float32ObserveDirect(parent Complex64Observable, mapper MappingComplex642Float32Func) Float32Observable {
	return MapComplex642Float32Observable(parent, func(Float32Observer) MappingComplex642Float32Func {
		return mapper
	})
}

func MapComplex642Float32ObserveNext(parent Complex64Observable, mapper func(complex64) float32) Float32Observable {
	return MapComplex642Float32Observable(parent, func(Float32Observer) MappingComplex642Float32Func {
		return func(next complex64, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Float32 struct {
	parent Complex64Observable
	mapper func(complex64) Float32Observable
}

func (f *flatMapComplex642Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *Complex64Stream) MapFloat32(f func(complex64) float32) *Float32Stream {
	return FromFloat32Observable(MapComplex642Float32ObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapFloat32(f func(complex64) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapComplex642Float32{s, f}}
}

type MappingComplex642Float64Func func(next complex64, err error, complete bool, observer Float64Observer)
type MappingComplex642Float64FuncFactory func(observer Float64Observer) MappingComplex642Float64Func

type MappingComplex642Float64Observable struct {
	parent Complex64Observable
	mapper MappingComplex642Float64FuncFactory
}

func (f *MappingComplex642Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642Float64Observable(parent Complex64Observable, mapper MappingComplex642Float64FuncFactory) Float64Observable {
	return &MappingComplex642Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642Float64ObserveDirect(parent Complex64Observable, mapper MappingComplex642Float64Func) Float64Observable {
	return MapComplex642Float64Observable(parent, func(Float64Observer) MappingComplex642Float64Func {
		return mapper
	})
}

func MapComplex642Float64ObserveNext(parent Complex64Observable, mapper func(complex64) float64) Float64Observable {
	return MapComplex642Float64Observable(parent, func(Float64Observer) MappingComplex642Float64Func {
		return func(next complex64, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Float64 struct {
	parent Complex64Observable
	mapper func(complex64) Float64Observable
}

func (f *flatMapComplex642Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *Complex64Stream) MapFloat64(f func(complex64) float64) *Float64Stream {
	return FromFloat64Observable(MapComplex642Float64ObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapFloat64(f func(complex64) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapComplex642Float64{s, f}}
}

type MappingComplex642Complex64Func func(next complex64, err error, complete bool, observer Complex64Observer)
type MappingComplex642Complex64FuncFactory func(observer Complex64Observer) MappingComplex642Complex64Func

type MappingComplex642Complex64Observable struct {
	parent Complex64Observable
	mapper MappingComplex642Complex64FuncFactory
}

func (f *MappingComplex642Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642Complex64Observable(parent Complex64Observable, mapper MappingComplex642Complex64FuncFactory) Complex64Observable {
	return &MappingComplex642Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642Complex64ObserveDirect(parent Complex64Observable, mapper MappingComplex642Complex64Func) Complex64Observable {
	return MapComplex642Complex64Observable(parent, func(Complex64Observer) MappingComplex642Complex64Func {
		return mapper
	})
}

func MapComplex642Complex64ObserveNext(parent Complex64Observable, mapper func(complex64) complex64) Complex64Observable {
	return MapComplex642Complex64Observable(parent, func(Complex64Observer) MappingComplex642Complex64Func {
		return func(next complex64, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Complex64 struct {
	parent Complex64Observable
	mapper func(complex64) Complex64Observable
}

func (f *flatMapComplex642Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *Complex64Stream) Map(f func(complex64) complex64) *Complex64Stream {
	return FromComplex64Observable(MapComplex642Complex64ObserveNext(s, f))
}

func (s *Complex64Stream) FlatMap(f func(complex64) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapComplex642Complex64{s, f}}
}

type MappingComplex642Complex128Func func(next complex64, err error, complete bool, observer Complex128Observer)
type MappingComplex642Complex128FuncFactory func(observer Complex128Observer) MappingComplex642Complex128Func

type MappingComplex642Complex128Observable struct {
	parent Complex64Observable
	mapper MappingComplex642Complex128FuncFactory
}

func (f *MappingComplex642Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642Complex128Observable(parent Complex64Observable, mapper MappingComplex642Complex128FuncFactory) Complex128Observable {
	return &MappingComplex642Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642Complex128ObserveDirect(parent Complex64Observable, mapper MappingComplex642Complex128Func) Complex128Observable {
	return MapComplex642Complex128Observable(parent, func(Complex128Observer) MappingComplex642Complex128Func {
		return mapper
	})
}

func MapComplex642Complex128ObserveNext(parent Complex64Observable, mapper func(complex64) complex128) Complex128Observable {
	return MapComplex642Complex128Observable(parent, func(Complex128Observer) MappingComplex642Complex128Func {
		return func(next complex64, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Complex128 struct {
	parent Complex64Observable
	mapper func(complex64) Complex128Observable
}

func (f *flatMapComplex642Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *Complex64Stream) MapComplex128(f func(complex64) complex128) *Complex128Stream {
	return FromComplex128Observable(MapComplex642Complex128ObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapComplex128(f func(complex64) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapComplex642Complex128{s, f}}
}

type MappingComplex642TimeFunc func(next complex64, err error, complete bool, observer TimeObserver)
type MappingComplex642TimeFuncFactory func(observer TimeObserver) MappingComplex642TimeFunc

type MappingComplex642TimeObservable struct {
	parent Complex64Observable
	mapper MappingComplex642TimeFuncFactory
}

func (f *MappingComplex642TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642TimeObservable(parent Complex64Observable, mapper MappingComplex642TimeFuncFactory) TimeObservable {
	return &MappingComplex642TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642TimeObserveDirect(parent Complex64Observable, mapper MappingComplex642TimeFunc) TimeObservable {
	return MapComplex642TimeObservable(parent, func(TimeObserver) MappingComplex642TimeFunc {
		return mapper
	})
}

func MapComplex642TimeObserveNext(parent Complex64Observable, mapper func(complex64) time.Time) TimeObservable {
	return MapComplex642TimeObservable(parent, func(TimeObserver) MappingComplex642TimeFunc {
		return func(next complex64, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Time struct {
	parent Complex64Observable
	mapper func(complex64) TimeObservable
}

func (f *flatMapComplex642Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *Complex64Stream) MapTime(f func(complex64) time.Time) *TimeStream {
	return FromTimeObservable(MapComplex642TimeObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapTime(f func(complex64) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapComplex642Time{s, f}}
}

type MappingComplex642DurationFunc func(next complex64, err error, complete bool, observer DurationObserver)
type MappingComplex642DurationFuncFactory func(observer DurationObserver) MappingComplex642DurationFunc

type MappingComplex642DurationObservable struct {
	parent Complex64Observable
	mapper MappingComplex642DurationFuncFactory
}

func (f *MappingComplex642DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex642DurationObservable(parent Complex64Observable, mapper MappingComplex642DurationFuncFactory) DurationObservable {
	return &MappingComplex642DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex642DurationObserveDirect(parent Complex64Observable, mapper MappingComplex642DurationFunc) DurationObservable {
	return MapComplex642DurationObservable(parent, func(DurationObserver) MappingComplex642DurationFunc {
		return mapper
	})
}

func MapComplex642DurationObserveNext(parent Complex64Observable, mapper func(complex64) time.Duration) DurationObservable {
	return MapComplex642DurationObservable(parent, func(DurationObserver) MappingComplex642DurationFunc {
		return func(next complex64, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex642Duration struct {
	parent Complex64Observable
	mapper func(complex64) DurationObservable
}

func (f *flatMapComplex642Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex64ObserverFunc(func(next complex64, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *Complex64Stream) MapDuration(f func(complex64) time.Duration) *DurationStream {
	return FromDurationObservable(MapComplex642DurationObserveNext(s, f))
}

func (s *Complex64Stream) FlatMapDuration(f func(complex64) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapComplex642Duration{s, f}}
}

type Complex128Observer interface {
	Next(complex128)
	TerminationObserver
}

// A Complex128Subscriber represents a subscribed Complex128Observer.
type Complex128Subscriber interface {
	Subscription
	Complex128Observer
}

type implComplex128Subscriber struct {
	Subscription
	Complex128Observer
}

func Complex128ObserverAsGenericObserver(observer Complex128Observer) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(complex128))
		}
	})
}

func GenericObserverAsComplex128Observer(observer GenericObserver) Complex128Observer {
	return Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type Complex128ObservableFactory func(observer Complex128Observer, subscription Subscription)

func (f Complex128ObservableFactory) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateComplex128 calls f(observer, subscription) to produce values for a stream.
func CreateComplex128(f func(observer Complex128Observer, subscription Subscription)) *Complex128Stream {
	return FromComplex128Observable(Complex128ObservableFactory(f))
}

// Repeat value count times.
func RepeatComplex128(value complex128, count int) *Complex128Stream {
	return CreateComplex128(func(observer Complex128Observer, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartComplex128 is designed to be used with functions that return a
// (complex128, error) tuple.
//
// If the error is non-nil the returned Complex128Stream will be that error,
// otherwise it will be a single-value stream of complex128.
func StartComplex128(f func() (complex128, error)) *Complex128Stream {
	return CreateComplex128(func(observer Complex128Observer, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughComplex128(next complex128, err error, complete bool, observer Complex128Observer) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroComplex128 = *new(complex128)

type Complex128ObserverFunc func(complex128, error, bool)

func (f Complex128ObserverFunc) Next(next complex128) { f(next, nil, false) }
func (f Complex128ObserverFunc) Error(err error)      { f(zeroComplex128, err, false) }
func (f Complex128ObserverFunc) Complete()            { f(zeroComplex128, nil, true) }

type Complex128Observable interface {
	Subscribe(Complex128Observer) Subscription
}

// Convert a GenericObservableFilter to a Complex128Observable
func (f GenericObservableFilterFactory) Complex128(parent Complex128Observable) Complex128Observable {
	return MapComplex1282Complex128Observable(parent, func(observer Complex128Observer) MappingComplex1282Complex128Func {
		gobserver := Complex128ObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next complex128, err error, complete bool, observer Complex128Observer) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverComplex128() *Complex128Stream {
	return CreateComplex128(func(observer Complex128Observer, subscription Subscription) {})
}

func EmptyComplex128() *Complex128Stream {
	return CreateComplex128(func(observer Complex128Observer, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowComplex128(err error) *Complex128Stream {
	return CreateComplex128(func(observer Complex128Observer, subscription Subscription) {
		observer.Error(err)
	})
}

func FromComplex128Array(array []complex128) *Complex128Stream {
	return CreateComplex128(func(observer Complex128Observer, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromComplex128s(array ...complex128) *Complex128Stream {
	return FromComplex128Array(array)
}

func JustComplex128(element complex128) *Complex128Stream {
	return FromComplex128Array([]complex128{element})
}

func MergeComplex128(observables ...Complex128Observable) *Complex128Stream {
	if len(observables) == 0 {
		return EmptyComplex128()
	}
	return (&Complex128Stream{observables[0]}).Merge(observables[1:]...)
}

func MergeComplex128DelayError(observables ...Complex128Observable) *Complex128Stream {
	if len(observables) == 0 {
		return EmptyComplex128()
	}
	return (&Complex128Stream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromComplex128Channel(ch <-chan complex128) *Complex128Stream {
	return CreateComplex128(func(observer Complex128Observer, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type Complex128Stream struct {
	Complex128Observable
}

func FromComplex128Observable(observable Complex128Observable) *Complex128Stream {
	return &Complex128Stream{observable}
}

func (s *Complex128Stream) SubscribeFunc(f func(complex128, error, bool)) Subscription {
	return s.Subscribe(Complex128ObserverFunc(f))
}

func (s *Complex128Stream) SubscribeNext(f func(v complex128)) Subscription {
	return s.SubscribeFunc(func(next complex128, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *Complex128Stream) Distinct() *Complex128Stream {
	return FromComplex128Observable(distinctFilter().Complex128(s))
}

// ElementAt yields the Nth element of the stream.
func (s *Complex128Stream) ElementAt(n int) *Complex128Stream {
	return FromComplex128Observable(elementAtFilter(n).Complex128(s))
}

// Filter elements in the stream on a function.
func (s *Complex128Stream) Filter(f func(complex128) bool) *Complex128Stream {
	return FromComplex128Observable(filterFilter(func(v interface{}) bool { return f(v.(complex128)) }).Complex128(s))
}

// Last returns just the first element of the stream.
func (s *Complex128Stream) First() *Complex128Stream {
	return FromComplex128Observable(firstFilter().Complex128(s))
}

// Last returns just the last element of the stream.
func (s *Complex128Stream) Last() *Complex128Stream {
	return FromComplex128Observable(lastFilter().Complex128(s))
}

// SkipLast skips the first N elements of the stream.
func (s *Complex128Stream) Skip(n int) *Complex128Stream {
	return FromComplex128Observable(skipFilter(n).Complex128(s))
}

// SkipLast skips the last N elements of the stream.
func (s *Complex128Stream) SkipLast(n int) *Complex128Stream {
	return FromComplex128Observable(skipLastFilter(n).Complex128(s))
}

// Take returns just the first N elements of the stream.
func (s *Complex128Stream) Take(n int) *Complex128Stream {
	return FromComplex128Observable(takeFilter(n).Complex128(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *Complex128Stream) TakeLast(n int) *Complex128Stream {
	return FromComplex128Observable(takeLastFilter(n).Complex128(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *Complex128Stream) IgnoreElements() *Complex128Stream {
	return FromComplex128Observable(ignoreElementsFilter().Complex128(s))
}

func (s *Complex128Stream) Replay(size int, duration time.Duration) *Complex128Stream {
	return FromComplex128Observable(replayFilter(size, duration).Complex128(s))
}

func (s *Complex128Stream) Sample(duration time.Duration) *Complex128Stream {
	return FromComplex128Observable(sampleFilter(duration).Complex128(s))
}

func (s *Complex128Stream) Debounce(duration time.Duration) *Complex128Stream {
	return FromComplex128Observable(debounceFilter(duration).Complex128(s))
}

// Wait for completion of the stream and return any error.
func (s *Complex128Stream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeComplex128Subscriber(observer Complex128Observer) Complex128Subscriber {
	if subscriber, ok := observer.(Complex128Subscriber); ok {
		return subscriber
	}
	return &implComplex128Subscriber{NewGenericSubscription(), observer}
}

type concatComplex128Subscriber struct {
	observable  int
	observer    Complex128Observer
	observables []Complex128Observable
	Subscription
}

func (c *concatComplex128Subscriber) Next(next complex128) {
	c.observer.Next(next)
}

func (c *concatComplex128Subscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatComplex128Subscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatComplex128Observable struct {
	observables []Complex128Observable
}

func (m *concatComplex128Observable) Subscribe(observer Complex128Observer) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatComplex128Subscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *Complex128Stream) Concat(observables ...Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&concatComplex128Observable{append([]Complex128Observable{s}, observables...)}}
}

type mergeComplex128Observable struct {
	delayError  bool
	observables []Complex128Observable
}

func (m *mergeComplex128Observable) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next complex128, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(Complex128ObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *Complex128Stream) Merge(other ...Complex128Observable) *Complex128Stream {
	if len(other) == 0 {
		return s
	}
	return &Complex128Stream{&mergeComplex128Observable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *Complex128Stream) MergeDelayError(other ...Complex128Observable) *Complex128Stream {
	if len(other) == 0 {
		return s
	}
	return &Complex128Stream{&mergeComplex128Observable{true, append(other, s)}}
}

type catchComplex128Observable struct {
	parent Complex128Observable
	catch  Complex128Observable
}

func (r *catchComplex128Observable) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	run := func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(Complex128ObserverFunc(run))
	return subscription
}

func (s *Complex128Stream) Catch(catch Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&catchComplex128Observable{s, catch}}
}

type retryComplex128Observable struct {
	observable Complex128Observable
}

type retryComplex128Observer struct {
	observable Complex128Observable
	observer   Complex128Observer
}

func (r *retryComplex128Observer) retry(next complex128, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(Complex128ObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryComplex128Observable) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryComplex128Observer{r.observable, observer}
	r.observable.Subscribe(Complex128ObserverFunc(ro.retry))
	return subscription
}

func (s *Complex128Stream) Retry() *Complex128Stream {
	return &Complex128Stream{&retryComplex128Observable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *Complex128Stream) Do(f func(next complex128)) *Complex128Stream {
	return FromComplex128Observable(MapComplex1282Complex128ObserveNext(s, func(next complex128) complex128 {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *Complex128Stream) DoOnError(f func(err error)) *Complex128Stream {
	return FromComplex128Observable(MapComplex1282Complex128ObserveDirect(s, func(next complex128, err error, complete bool, observer Complex128Observer) {
		if err != nil {
			f(err)
		}
		PassthroughComplex128(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *Complex128Stream) DoOnComplete(f func()) *Complex128Stream {
	return FromComplex128Observable(MapComplex1282Complex128ObserveDirect(s, func(next complex128, err error, complete bool, observer Complex128Observer) {
		if complete {
			f()
		}
		PassthroughComplex128(next, err, complete, observer)
	}))
}

func (s *Complex128Stream) Reduce(initial complex128, reducer func(complex128, complex128) complex128) *Complex128Stream {
	value := initial
	return FromComplex128Observable(MapComplex1282Complex128ObserveDirect(s, func(next complex128, err error, complete bool, observer Complex128Observer) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *Complex128Stream) Scan(initial complex128, f func(complex128, complex128) complex128) *Complex128Stream {
	value := initial
	return FromComplex128Observable(MapComplex1282Complex128ObserveDirect(s, func(next complex128, err error, complete bool, observer Complex128Observer) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutComplex128 struct {
	parent  Complex128Observable
	timeout time.Duration
}

func (t *timeoutComplex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *Complex128Stream) Timeout(timeout time.Duration) *Complex128Stream {
	return &Complex128Stream{&timeoutComplex128{s, timeout}}
}

type forkedComplex128Stream struct {
	lock      sync.Mutex
	parent    Complex128Observable
	observers []Complex128Observer
}

func (f *forkedComplex128Stream) Subscribe(observer Complex128Observer) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *Complex128Stream) Fork() *Complex128Stream {
	f := &forkedComplex128Stream{parent: s}
	go s.Subscribe(Complex128ObserverFunc(func(n complex128, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &Complex128Stream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *Complex128Stream) ToOneWithError() (complex128, error) {
	valuech := make(chan complex128, 1)
	errch := make(chan error, 1)
	FromComplex128Observable(oneFilter().Complex128(s)).SubscribeFunc(func(next complex128, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroComplex128, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *Complex128Stream) ToOne() complex128 {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *Complex128Stream) ToArrayWithError() ([]complex128, error) {
	array := []complex128{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *Complex128Stream) ToArray() []complex128 {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *Complex128Stream) ToChannelWithError() (<-chan complex128, <-chan error) {
	ch := make(chan complex128, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *Complex128Stream) ToChannel() <-chan complex128 {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *Complex128Stream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapComplex1282IntObserveDirect(s, func(next complex128, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

type MappingComplex1282BoolFunc func(next complex128, err error, complete bool, observer BoolObserver)
type MappingComplex1282BoolFuncFactory func(observer BoolObserver) MappingComplex1282BoolFunc

type MappingComplex1282BoolObservable struct {
	parent Complex128Observable
	mapper MappingComplex1282BoolFuncFactory
}

func (f *MappingComplex1282BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282BoolObservable(parent Complex128Observable, mapper MappingComplex1282BoolFuncFactory) BoolObservable {
	return &MappingComplex1282BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282BoolObserveDirect(parent Complex128Observable, mapper MappingComplex1282BoolFunc) BoolObservable {
	return MapComplex1282BoolObservable(parent, func(BoolObserver) MappingComplex1282BoolFunc {
		return mapper
	})
}

func MapComplex1282BoolObserveNext(parent Complex128Observable, mapper func(complex128) bool) BoolObservable {
	return MapComplex1282BoolObservable(parent, func(BoolObserver) MappingComplex1282BoolFunc {
		return func(next complex128, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Bool struct {
	parent Complex128Observable
	mapper func(complex128) BoolObservable
}

func (f *flatMapComplex1282Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *Complex128Stream) MapBool(f func(complex128) bool) *BoolStream {
	return FromBoolObservable(MapComplex1282BoolObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapBool(f func(complex128) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapComplex1282Bool{s, f}}
}

type MappingComplex1282RuneFunc func(next complex128, err error, complete bool, observer RuneObserver)
type MappingComplex1282RuneFuncFactory func(observer RuneObserver) MappingComplex1282RuneFunc

type MappingComplex1282RuneObservable struct {
	parent Complex128Observable
	mapper MappingComplex1282RuneFuncFactory
}

func (f *MappingComplex1282RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282RuneObservable(parent Complex128Observable, mapper MappingComplex1282RuneFuncFactory) RuneObservable {
	return &MappingComplex1282RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282RuneObserveDirect(parent Complex128Observable, mapper MappingComplex1282RuneFunc) RuneObservable {
	return MapComplex1282RuneObservable(parent, func(RuneObserver) MappingComplex1282RuneFunc {
		return mapper
	})
}

func MapComplex1282RuneObserveNext(parent Complex128Observable, mapper func(complex128) rune) RuneObservable {
	return MapComplex1282RuneObservable(parent, func(RuneObserver) MappingComplex1282RuneFunc {
		return func(next complex128, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Rune struct {
	parent Complex128Observable
	mapper func(complex128) RuneObservable
}

func (f *flatMapComplex1282Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *Complex128Stream) MapRune(f func(complex128) rune) *RuneStream {
	return FromRuneObservable(MapComplex1282RuneObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapRune(f func(complex128) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapComplex1282Rune{s, f}}
}

type MappingComplex1282ByteFunc func(next complex128, err error, complete bool, observer ByteObserver)
type MappingComplex1282ByteFuncFactory func(observer ByteObserver) MappingComplex1282ByteFunc

type MappingComplex1282ByteObservable struct {
	parent Complex128Observable
	mapper MappingComplex1282ByteFuncFactory
}

func (f *MappingComplex1282ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282ByteObservable(parent Complex128Observable, mapper MappingComplex1282ByteFuncFactory) ByteObservable {
	return &MappingComplex1282ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282ByteObserveDirect(parent Complex128Observable, mapper MappingComplex1282ByteFunc) ByteObservable {
	return MapComplex1282ByteObservable(parent, func(ByteObserver) MappingComplex1282ByteFunc {
		return mapper
	})
}

func MapComplex1282ByteObserveNext(parent Complex128Observable, mapper func(complex128) byte) ByteObservable {
	return MapComplex1282ByteObservable(parent, func(ByteObserver) MappingComplex1282ByteFunc {
		return func(next complex128, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Byte struct {
	parent Complex128Observable
	mapper func(complex128) ByteObservable
}

func (f *flatMapComplex1282Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *Complex128Stream) MapByte(f func(complex128) byte) *ByteStream {
	return FromByteObservable(MapComplex1282ByteObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapByte(f func(complex128) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapComplex1282Byte{s, f}}
}

type MappingComplex1282StringFunc func(next complex128, err error, complete bool, observer StringObserver)
type MappingComplex1282StringFuncFactory func(observer StringObserver) MappingComplex1282StringFunc

type MappingComplex1282StringObservable struct {
	parent Complex128Observable
	mapper MappingComplex1282StringFuncFactory
}

func (f *MappingComplex1282StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282StringObservable(parent Complex128Observable, mapper MappingComplex1282StringFuncFactory) StringObservable {
	return &MappingComplex1282StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282StringObserveDirect(parent Complex128Observable, mapper MappingComplex1282StringFunc) StringObservable {
	return MapComplex1282StringObservable(parent, func(StringObserver) MappingComplex1282StringFunc {
		return mapper
	})
}

func MapComplex1282StringObserveNext(parent Complex128Observable, mapper func(complex128) string) StringObservable {
	return MapComplex1282StringObservable(parent, func(StringObserver) MappingComplex1282StringFunc {
		return func(next complex128, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282String struct {
	parent Complex128Observable
	mapper func(complex128) StringObservable
}

func (f *flatMapComplex1282String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *Complex128Stream) MapString(f func(complex128) string) *StringStream {
	return FromStringObservable(MapComplex1282StringObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapString(f func(complex128) StringObservable) *StringStream {
	return &StringStream{&flatMapComplex1282String{s, f}}
}

type MappingComplex1282UintFunc func(next complex128, err error, complete bool, observer UintObserver)
type MappingComplex1282UintFuncFactory func(observer UintObserver) MappingComplex1282UintFunc

type MappingComplex1282UintObservable struct {
	parent Complex128Observable
	mapper MappingComplex1282UintFuncFactory
}

func (f *MappingComplex1282UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282UintObservable(parent Complex128Observable, mapper MappingComplex1282UintFuncFactory) UintObservable {
	return &MappingComplex1282UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282UintObserveDirect(parent Complex128Observable, mapper MappingComplex1282UintFunc) UintObservable {
	return MapComplex1282UintObservable(parent, func(UintObserver) MappingComplex1282UintFunc {
		return mapper
	})
}

func MapComplex1282UintObserveNext(parent Complex128Observable, mapper func(complex128) uint) UintObservable {
	return MapComplex1282UintObservable(parent, func(UintObserver) MappingComplex1282UintFunc {
		return func(next complex128, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Uint struct {
	parent Complex128Observable
	mapper func(complex128) UintObservable
}

func (f *flatMapComplex1282Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *Complex128Stream) MapUint(f func(complex128) uint) *UintStream {
	return FromUintObservable(MapComplex1282UintObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapUint(f func(complex128) UintObservable) *UintStream {
	return &UintStream{&flatMapComplex1282Uint{s, f}}
}

type MappingComplex1282IntFunc func(next complex128, err error, complete bool, observer IntObserver)
type MappingComplex1282IntFuncFactory func(observer IntObserver) MappingComplex1282IntFunc

type MappingComplex1282IntObservable struct {
	parent Complex128Observable
	mapper MappingComplex1282IntFuncFactory
}

func (f *MappingComplex1282IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282IntObservable(parent Complex128Observable, mapper MappingComplex1282IntFuncFactory) IntObservable {
	return &MappingComplex1282IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282IntObserveDirect(parent Complex128Observable, mapper MappingComplex1282IntFunc) IntObservable {
	return MapComplex1282IntObservable(parent, func(IntObserver) MappingComplex1282IntFunc {
		return mapper
	})
}

func MapComplex1282IntObserveNext(parent Complex128Observable, mapper func(complex128) int) IntObservable {
	return MapComplex1282IntObservable(parent, func(IntObserver) MappingComplex1282IntFunc {
		return func(next complex128, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Int struct {
	parent Complex128Observable
	mapper func(complex128) IntObservable
}

func (f *flatMapComplex1282Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *Complex128Stream) MapInt(f func(complex128) int) *IntStream {
	return FromIntObservable(MapComplex1282IntObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapInt(f func(complex128) IntObservable) *IntStream {
	return &IntStream{&flatMapComplex1282Int{s, f}}
}

type MappingComplex1282Uint8Func func(next complex128, err error, complete bool, observer Uint8Observer)
type MappingComplex1282Uint8FuncFactory func(observer Uint8Observer) MappingComplex1282Uint8Func

type MappingComplex1282Uint8Observable struct {
	parent Complex128Observable
	mapper MappingComplex1282Uint8FuncFactory
}

func (f *MappingComplex1282Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282Uint8Observable(parent Complex128Observable, mapper MappingComplex1282Uint8FuncFactory) Uint8Observable {
	return &MappingComplex1282Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282Uint8ObserveDirect(parent Complex128Observable, mapper MappingComplex1282Uint8Func) Uint8Observable {
	return MapComplex1282Uint8Observable(parent, func(Uint8Observer) MappingComplex1282Uint8Func {
		return mapper
	})
}

func MapComplex1282Uint8ObserveNext(parent Complex128Observable, mapper func(complex128) uint8) Uint8Observable {
	return MapComplex1282Uint8Observable(parent, func(Uint8Observer) MappingComplex1282Uint8Func {
		return func(next complex128, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Uint8 struct {
	parent Complex128Observable
	mapper func(complex128) Uint8Observable
}

func (f *flatMapComplex1282Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *Complex128Stream) MapUint8(f func(complex128) uint8) *Uint8Stream {
	return FromUint8Observable(MapComplex1282Uint8ObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapUint8(f func(complex128) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapComplex1282Uint8{s, f}}
}

type MappingComplex1282Int8Func func(next complex128, err error, complete bool, observer Int8Observer)
type MappingComplex1282Int8FuncFactory func(observer Int8Observer) MappingComplex1282Int8Func

type MappingComplex1282Int8Observable struct {
	parent Complex128Observable
	mapper MappingComplex1282Int8FuncFactory
}

func (f *MappingComplex1282Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282Int8Observable(parent Complex128Observable, mapper MappingComplex1282Int8FuncFactory) Int8Observable {
	return &MappingComplex1282Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282Int8ObserveDirect(parent Complex128Observable, mapper MappingComplex1282Int8Func) Int8Observable {
	return MapComplex1282Int8Observable(parent, func(Int8Observer) MappingComplex1282Int8Func {
		return mapper
	})
}

func MapComplex1282Int8ObserveNext(parent Complex128Observable, mapper func(complex128) int8) Int8Observable {
	return MapComplex1282Int8Observable(parent, func(Int8Observer) MappingComplex1282Int8Func {
		return func(next complex128, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Int8 struct {
	parent Complex128Observable
	mapper func(complex128) Int8Observable
}

func (f *flatMapComplex1282Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *Complex128Stream) MapInt8(f func(complex128) int8) *Int8Stream {
	return FromInt8Observable(MapComplex1282Int8ObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapInt8(f func(complex128) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapComplex1282Int8{s, f}}
}

type MappingComplex1282Uint16Func func(next complex128, err error, complete bool, observer Uint16Observer)
type MappingComplex1282Uint16FuncFactory func(observer Uint16Observer) MappingComplex1282Uint16Func

type MappingComplex1282Uint16Observable struct {
	parent Complex128Observable
	mapper MappingComplex1282Uint16FuncFactory
}

func (f *MappingComplex1282Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282Uint16Observable(parent Complex128Observable, mapper MappingComplex1282Uint16FuncFactory) Uint16Observable {
	return &MappingComplex1282Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282Uint16ObserveDirect(parent Complex128Observable, mapper MappingComplex1282Uint16Func) Uint16Observable {
	return MapComplex1282Uint16Observable(parent, func(Uint16Observer) MappingComplex1282Uint16Func {
		return mapper
	})
}

func MapComplex1282Uint16ObserveNext(parent Complex128Observable, mapper func(complex128) uint16) Uint16Observable {
	return MapComplex1282Uint16Observable(parent, func(Uint16Observer) MappingComplex1282Uint16Func {
		return func(next complex128, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Uint16 struct {
	parent Complex128Observable
	mapper func(complex128) Uint16Observable
}

func (f *flatMapComplex1282Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *Complex128Stream) MapUint16(f func(complex128) uint16) *Uint16Stream {
	return FromUint16Observable(MapComplex1282Uint16ObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapUint16(f func(complex128) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapComplex1282Uint16{s, f}}
}

type MappingComplex1282Int16Func func(next complex128, err error, complete bool, observer Int16Observer)
type MappingComplex1282Int16FuncFactory func(observer Int16Observer) MappingComplex1282Int16Func

type MappingComplex1282Int16Observable struct {
	parent Complex128Observable
	mapper MappingComplex1282Int16FuncFactory
}

func (f *MappingComplex1282Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282Int16Observable(parent Complex128Observable, mapper MappingComplex1282Int16FuncFactory) Int16Observable {
	return &MappingComplex1282Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282Int16ObserveDirect(parent Complex128Observable, mapper MappingComplex1282Int16Func) Int16Observable {
	return MapComplex1282Int16Observable(parent, func(Int16Observer) MappingComplex1282Int16Func {
		return mapper
	})
}

func MapComplex1282Int16ObserveNext(parent Complex128Observable, mapper func(complex128) int16) Int16Observable {
	return MapComplex1282Int16Observable(parent, func(Int16Observer) MappingComplex1282Int16Func {
		return func(next complex128, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Int16 struct {
	parent Complex128Observable
	mapper func(complex128) Int16Observable
}

func (f *flatMapComplex1282Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *Complex128Stream) MapInt16(f func(complex128) int16) *Int16Stream {
	return FromInt16Observable(MapComplex1282Int16ObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapInt16(f func(complex128) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapComplex1282Int16{s, f}}
}

type MappingComplex1282Uint32Func func(next complex128, err error, complete bool, observer Uint32Observer)
type MappingComplex1282Uint32FuncFactory func(observer Uint32Observer) MappingComplex1282Uint32Func

type MappingComplex1282Uint32Observable struct {
	parent Complex128Observable
	mapper MappingComplex1282Uint32FuncFactory
}

func (f *MappingComplex1282Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282Uint32Observable(parent Complex128Observable, mapper MappingComplex1282Uint32FuncFactory) Uint32Observable {
	return &MappingComplex1282Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282Uint32ObserveDirect(parent Complex128Observable, mapper MappingComplex1282Uint32Func) Uint32Observable {
	return MapComplex1282Uint32Observable(parent, func(Uint32Observer) MappingComplex1282Uint32Func {
		return mapper
	})
}

func MapComplex1282Uint32ObserveNext(parent Complex128Observable, mapper func(complex128) uint32) Uint32Observable {
	return MapComplex1282Uint32Observable(parent, func(Uint32Observer) MappingComplex1282Uint32Func {
		return func(next complex128, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Uint32 struct {
	parent Complex128Observable
	mapper func(complex128) Uint32Observable
}

func (f *flatMapComplex1282Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *Complex128Stream) MapUint32(f func(complex128) uint32) *Uint32Stream {
	return FromUint32Observable(MapComplex1282Uint32ObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapUint32(f func(complex128) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapComplex1282Uint32{s, f}}
}

type MappingComplex1282Int32Func func(next complex128, err error, complete bool, observer Int32Observer)
type MappingComplex1282Int32FuncFactory func(observer Int32Observer) MappingComplex1282Int32Func

type MappingComplex1282Int32Observable struct {
	parent Complex128Observable
	mapper MappingComplex1282Int32FuncFactory
}

func (f *MappingComplex1282Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282Int32Observable(parent Complex128Observable, mapper MappingComplex1282Int32FuncFactory) Int32Observable {
	return &MappingComplex1282Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282Int32ObserveDirect(parent Complex128Observable, mapper MappingComplex1282Int32Func) Int32Observable {
	return MapComplex1282Int32Observable(parent, func(Int32Observer) MappingComplex1282Int32Func {
		return mapper
	})
}

func MapComplex1282Int32ObserveNext(parent Complex128Observable, mapper func(complex128) int32) Int32Observable {
	return MapComplex1282Int32Observable(parent, func(Int32Observer) MappingComplex1282Int32Func {
		return func(next complex128, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Int32 struct {
	parent Complex128Observable
	mapper func(complex128) Int32Observable
}

func (f *flatMapComplex1282Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *Complex128Stream) MapInt32(f func(complex128) int32) *Int32Stream {
	return FromInt32Observable(MapComplex1282Int32ObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapInt32(f func(complex128) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapComplex1282Int32{s, f}}
}

type MappingComplex1282Uint64Func func(next complex128, err error, complete bool, observer Uint64Observer)
type MappingComplex1282Uint64FuncFactory func(observer Uint64Observer) MappingComplex1282Uint64Func

type MappingComplex1282Uint64Observable struct {
	parent Complex128Observable
	mapper MappingComplex1282Uint64FuncFactory
}

func (f *MappingComplex1282Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282Uint64Observable(parent Complex128Observable, mapper MappingComplex1282Uint64FuncFactory) Uint64Observable {
	return &MappingComplex1282Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282Uint64ObserveDirect(parent Complex128Observable, mapper MappingComplex1282Uint64Func) Uint64Observable {
	return MapComplex1282Uint64Observable(parent, func(Uint64Observer) MappingComplex1282Uint64Func {
		return mapper
	})
}

func MapComplex1282Uint64ObserveNext(parent Complex128Observable, mapper func(complex128) uint64) Uint64Observable {
	return MapComplex1282Uint64Observable(parent, func(Uint64Observer) MappingComplex1282Uint64Func {
		return func(next complex128, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Uint64 struct {
	parent Complex128Observable
	mapper func(complex128) Uint64Observable
}

func (f *flatMapComplex1282Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *Complex128Stream) MapUint64(f func(complex128) uint64) *Uint64Stream {
	return FromUint64Observable(MapComplex1282Uint64ObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapUint64(f func(complex128) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapComplex1282Uint64{s, f}}
}

type MappingComplex1282Int64Func func(next complex128, err error, complete bool, observer Int64Observer)
type MappingComplex1282Int64FuncFactory func(observer Int64Observer) MappingComplex1282Int64Func

type MappingComplex1282Int64Observable struct {
	parent Complex128Observable
	mapper MappingComplex1282Int64FuncFactory
}

func (f *MappingComplex1282Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282Int64Observable(parent Complex128Observable, mapper MappingComplex1282Int64FuncFactory) Int64Observable {
	return &MappingComplex1282Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282Int64ObserveDirect(parent Complex128Observable, mapper MappingComplex1282Int64Func) Int64Observable {
	return MapComplex1282Int64Observable(parent, func(Int64Observer) MappingComplex1282Int64Func {
		return mapper
	})
}

func MapComplex1282Int64ObserveNext(parent Complex128Observable, mapper func(complex128) int64) Int64Observable {
	return MapComplex1282Int64Observable(parent, func(Int64Observer) MappingComplex1282Int64Func {
		return func(next complex128, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Int64 struct {
	parent Complex128Observable
	mapper func(complex128) Int64Observable
}

func (f *flatMapComplex1282Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *Complex128Stream) MapInt64(f func(complex128) int64) *Int64Stream {
	return FromInt64Observable(MapComplex1282Int64ObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapInt64(f func(complex128) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapComplex1282Int64{s, f}}
}

type MappingComplex1282Float32Func func(next complex128, err error, complete bool, observer Float32Observer)
type MappingComplex1282Float32FuncFactory func(observer Float32Observer) MappingComplex1282Float32Func

type MappingComplex1282Float32Observable struct {
	parent Complex128Observable
	mapper MappingComplex1282Float32FuncFactory
}

func (f *MappingComplex1282Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282Float32Observable(parent Complex128Observable, mapper MappingComplex1282Float32FuncFactory) Float32Observable {
	return &MappingComplex1282Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282Float32ObserveDirect(parent Complex128Observable, mapper MappingComplex1282Float32Func) Float32Observable {
	return MapComplex1282Float32Observable(parent, func(Float32Observer) MappingComplex1282Float32Func {
		return mapper
	})
}

func MapComplex1282Float32ObserveNext(parent Complex128Observable, mapper func(complex128) float32) Float32Observable {
	return MapComplex1282Float32Observable(parent, func(Float32Observer) MappingComplex1282Float32Func {
		return func(next complex128, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Float32 struct {
	parent Complex128Observable
	mapper func(complex128) Float32Observable
}

func (f *flatMapComplex1282Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *Complex128Stream) MapFloat32(f func(complex128) float32) *Float32Stream {
	return FromFloat32Observable(MapComplex1282Float32ObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapFloat32(f func(complex128) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapComplex1282Float32{s, f}}
}

type MappingComplex1282Float64Func func(next complex128, err error, complete bool, observer Float64Observer)
type MappingComplex1282Float64FuncFactory func(observer Float64Observer) MappingComplex1282Float64Func

type MappingComplex1282Float64Observable struct {
	parent Complex128Observable
	mapper MappingComplex1282Float64FuncFactory
}

func (f *MappingComplex1282Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282Float64Observable(parent Complex128Observable, mapper MappingComplex1282Float64FuncFactory) Float64Observable {
	return &MappingComplex1282Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282Float64ObserveDirect(parent Complex128Observable, mapper MappingComplex1282Float64Func) Float64Observable {
	return MapComplex1282Float64Observable(parent, func(Float64Observer) MappingComplex1282Float64Func {
		return mapper
	})
}

func MapComplex1282Float64ObserveNext(parent Complex128Observable, mapper func(complex128) float64) Float64Observable {
	return MapComplex1282Float64Observable(parent, func(Float64Observer) MappingComplex1282Float64Func {
		return func(next complex128, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Float64 struct {
	parent Complex128Observable
	mapper func(complex128) Float64Observable
}

func (f *flatMapComplex1282Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *Complex128Stream) MapFloat64(f func(complex128) float64) *Float64Stream {
	return FromFloat64Observable(MapComplex1282Float64ObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapFloat64(f func(complex128) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapComplex1282Float64{s, f}}
}

type MappingComplex1282Complex64Func func(next complex128, err error, complete bool, observer Complex64Observer)
type MappingComplex1282Complex64FuncFactory func(observer Complex64Observer) MappingComplex1282Complex64Func

type MappingComplex1282Complex64Observable struct {
	parent Complex128Observable
	mapper MappingComplex1282Complex64FuncFactory
}

func (f *MappingComplex1282Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282Complex64Observable(parent Complex128Observable, mapper MappingComplex1282Complex64FuncFactory) Complex64Observable {
	return &MappingComplex1282Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282Complex64ObserveDirect(parent Complex128Observable, mapper MappingComplex1282Complex64Func) Complex64Observable {
	return MapComplex1282Complex64Observable(parent, func(Complex64Observer) MappingComplex1282Complex64Func {
		return mapper
	})
}

func MapComplex1282Complex64ObserveNext(parent Complex128Observable, mapper func(complex128) complex64) Complex64Observable {
	return MapComplex1282Complex64Observable(parent, func(Complex64Observer) MappingComplex1282Complex64Func {
		return func(next complex128, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Complex64 struct {
	parent Complex128Observable
	mapper func(complex128) Complex64Observable
}

func (f *flatMapComplex1282Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *Complex128Stream) MapComplex64(f func(complex128) complex64) *Complex64Stream {
	return FromComplex64Observable(MapComplex1282Complex64ObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapComplex64(f func(complex128) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapComplex1282Complex64{s, f}}
}

type MappingComplex1282Complex128Func func(next complex128, err error, complete bool, observer Complex128Observer)
type MappingComplex1282Complex128FuncFactory func(observer Complex128Observer) MappingComplex1282Complex128Func

type MappingComplex1282Complex128Observable struct {
	parent Complex128Observable
	mapper MappingComplex1282Complex128FuncFactory
}

func (f *MappingComplex1282Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282Complex128Observable(parent Complex128Observable, mapper MappingComplex1282Complex128FuncFactory) Complex128Observable {
	return &MappingComplex1282Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282Complex128ObserveDirect(parent Complex128Observable, mapper MappingComplex1282Complex128Func) Complex128Observable {
	return MapComplex1282Complex128Observable(parent, func(Complex128Observer) MappingComplex1282Complex128Func {
		return mapper
	})
}

func MapComplex1282Complex128ObserveNext(parent Complex128Observable, mapper func(complex128) complex128) Complex128Observable {
	return MapComplex1282Complex128Observable(parent, func(Complex128Observer) MappingComplex1282Complex128Func {
		return func(next complex128, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Complex128 struct {
	parent Complex128Observable
	mapper func(complex128) Complex128Observable
}

func (f *flatMapComplex1282Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *Complex128Stream) Map(f func(complex128) complex128) *Complex128Stream {
	return FromComplex128Observable(MapComplex1282Complex128ObserveNext(s, f))
}

func (s *Complex128Stream) FlatMap(f func(complex128) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapComplex1282Complex128{s, f}}
}

type MappingComplex1282TimeFunc func(next complex128, err error, complete bool, observer TimeObserver)
type MappingComplex1282TimeFuncFactory func(observer TimeObserver) MappingComplex1282TimeFunc

type MappingComplex1282TimeObservable struct {
	parent Complex128Observable
	mapper MappingComplex1282TimeFuncFactory
}

func (f *MappingComplex1282TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282TimeObservable(parent Complex128Observable, mapper MappingComplex1282TimeFuncFactory) TimeObservable {
	return &MappingComplex1282TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282TimeObserveDirect(parent Complex128Observable, mapper MappingComplex1282TimeFunc) TimeObservable {
	return MapComplex1282TimeObservable(parent, func(TimeObserver) MappingComplex1282TimeFunc {
		return mapper
	})
}

func MapComplex1282TimeObserveNext(parent Complex128Observable, mapper func(complex128) time.Time) TimeObservable {
	return MapComplex1282TimeObservable(parent, func(TimeObserver) MappingComplex1282TimeFunc {
		return func(next complex128, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Time struct {
	parent Complex128Observable
	mapper func(complex128) TimeObservable
}

func (f *flatMapComplex1282Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *Complex128Stream) MapTime(f func(complex128) time.Time) *TimeStream {
	return FromTimeObservable(MapComplex1282TimeObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapTime(f func(complex128) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapComplex1282Time{s, f}}
}

type MappingComplex1282DurationFunc func(next complex128, err error, complete bool, observer DurationObserver)
type MappingComplex1282DurationFuncFactory func(observer DurationObserver) MappingComplex1282DurationFunc

type MappingComplex1282DurationObservable struct {
	parent Complex128Observable
	mapper MappingComplex1282DurationFuncFactory
}

func (f *MappingComplex1282DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapComplex1282DurationObservable(parent Complex128Observable, mapper MappingComplex1282DurationFuncFactory) DurationObservable {
	return &MappingComplex1282DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapComplex1282DurationObserveDirect(parent Complex128Observable, mapper MappingComplex1282DurationFunc) DurationObservable {
	return MapComplex1282DurationObservable(parent, func(DurationObserver) MappingComplex1282DurationFunc {
		return mapper
	})
}

func MapComplex1282DurationObserveNext(parent Complex128Observable, mapper func(complex128) time.Duration) DurationObservable {
	return MapComplex1282DurationObservable(parent, func(DurationObserver) MappingComplex1282DurationFunc {
		return func(next complex128, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapComplex1282Duration struct {
	parent Complex128Observable
	mapper func(complex128) DurationObservable
}

func (f *flatMapComplex1282Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(Complex128ObserverFunc(func(next complex128, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *Complex128Stream) MapDuration(f func(complex128) time.Duration) *DurationStream {
	return FromDurationObservable(MapComplex1282DurationObserveNext(s, f))
}

func (s *Complex128Stream) FlatMapDuration(f func(complex128) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapComplex1282Duration{s, f}}
}

type TimeObserver interface {
	Next(time.Time)
	TerminationObserver
}

// A TimeSubscriber represents a subscribed TimeObserver.
type TimeSubscriber interface {
	Subscription
	TimeObserver
}

type implTimeSubscriber struct {
	Subscription
	TimeObserver
}

func TimeObserverAsGenericObserver(observer TimeObserver) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(time.Time))
		}
	})
}

func GenericObserverAsTimeObserver(observer GenericObserver) TimeObserver {
	return TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type TimeObservableFactory func(observer TimeObserver, subscription Subscription)

func (f TimeObservableFactory) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateTime calls f(observer, subscription) to produce values for a stream.
func CreateTime(f func(observer TimeObserver, subscription Subscription)) *TimeStream {
	return FromTimeObservable(TimeObservableFactory(f))
}

// Repeat value count times.
func RepeatTime(value time.Time, count int) *TimeStream {
	return CreateTime(func(observer TimeObserver, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartTime is designed to be used with functions that return a
// (time.Time, error) tuple.
//
// If the error is non-nil the returned TimeStream will be that error,
// otherwise it will be a single-value stream of time.Time.
func StartTime(f func() (time.Time, error)) *TimeStream {
	return CreateTime(func(observer TimeObserver, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughTime(next time.Time, err error, complete bool, observer TimeObserver) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroTime = *new(time.Time)

type TimeObserverFunc func(time.Time, error, bool)

func (f TimeObserverFunc) Next(next time.Time) { f(next, nil, false) }
func (f TimeObserverFunc) Error(err error)     { f(zeroTime, err, false) }
func (f TimeObserverFunc) Complete()           { f(zeroTime, nil, true) }

type TimeObservable interface {
	Subscribe(TimeObserver) Subscription
}

// Convert a GenericObservableFilter to a TimeObservable
func (f GenericObservableFilterFactory) Time(parent TimeObservable) TimeObservable {
	return MapTime2TimeObservable(parent, func(observer TimeObserver) MappingTime2TimeFunc {
		gobserver := TimeObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next time.Time, err error, complete bool, observer TimeObserver) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverTime() *TimeStream {
	return CreateTime(func(observer TimeObserver, subscription Subscription) {})
}

func EmptyTime() *TimeStream {
	return CreateTime(func(observer TimeObserver, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowTime(err error) *TimeStream {
	return CreateTime(func(observer TimeObserver, subscription Subscription) {
		observer.Error(err)
	})
}

func FromTimeArray(array []time.Time) *TimeStream {
	return CreateTime(func(observer TimeObserver, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromTimes(array ...time.Time) *TimeStream {
	return FromTimeArray(array)
}

func JustTime(element time.Time) *TimeStream {
	return FromTimeArray([]time.Time{element})
}

func MergeTime(observables ...TimeObservable) *TimeStream {
	if len(observables) == 0 {
		return EmptyTime()
	}
	return (&TimeStream{observables[0]}).Merge(observables[1:]...)
}

func MergeTimeDelayError(observables ...TimeObservable) *TimeStream {
	if len(observables) == 0 {
		return EmptyTime()
	}
	return (&TimeStream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromTimeChannel(ch <-chan time.Time) *TimeStream {
	return CreateTime(func(observer TimeObserver, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type TimeStream struct {
	TimeObservable
}

func FromTimeObservable(observable TimeObservable) *TimeStream {
	return &TimeStream{observable}
}

func (s *TimeStream) SubscribeFunc(f func(time.Time, error, bool)) Subscription {
	return s.Subscribe(TimeObserverFunc(f))
}

func (s *TimeStream) SubscribeNext(f func(v time.Time)) Subscription {
	return s.SubscribeFunc(func(next time.Time, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *TimeStream) Distinct() *TimeStream {
	return FromTimeObservable(distinctFilter().Time(s))
}

// ElementAt yields the Nth element of the stream.
func (s *TimeStream) ElementAt(n int) *TimeStream {
	return FromTimeObservable(elementAtFilter(n).Time(s))
}

// Filter elements in the stream on a function.
func (s *TimeStream) Filter(f func(time.Time) bool) *TimeStream {
	return FromTimeObservable(filterFilter(func(v interface{}) bool { return f(v.(time.Time)) }).Time(s))
}

// Last returns just the first element of the stream.
func (s *TimeStream) First() *TimeStream {
	return FromTimeObservable(firstFilter().Time(s))
}

// Last returns just the last element of the stream.
func (s *TimeStream) Last() *TimeStream {
	return FromTimeObservable(lastFilter().Time(s))
}

// SkipLast skips the first N elements of the stream.
func (s *TimeStream) Skip(n int) *TimeStream {
	return FromTimeObservable(skipFilter(n).Time(s))
}

// SkipLast skips the last N elements of the stream.
func (s *TimeStream) SkipLast(n int) *TimeStream {
	return FromTimeObservable(skipLastFilter(n).Time(s))
}

// Take returns just the first N elements of the stream.
func (s *TimeStream) Take(n int) *TimeStream {
	return FromTimeObservable(takeFilter(n).Time(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *TimeStream) TakeLast(n int) *TimeStream {
	return FromTimeObservable(takeLastFilter(n).Time(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *TimeStream) IgnoreElements() *TimeStream {
	return FromTimeObservable(ignoreElementsFilter().Time(s))
}

func (s *TimeStream) Replay(size int, duration time.Duration) *TimeStream {
	return FromTimeObservable(replayFilter(size, duration).Time(s))
}

func (s *TimeStream) Sample(duration time.Duration) *TimeStream {
	return FromTimeObservable(sampleFilter(duration).Time(s))
}

func (s *TimeStream) Debounce(duration time.Duration) *TimeStream {
	return FromTimeObservable(debounceFilter(duration).Time(s))
}

// Wait for completion of the stream and return any error.
func (s *TimeStream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeTimeSubscriber(observer TimeObserver) TimeSubscriber {
	if subscriber, ok := observer.(TimeSubscriber); ok {
		return subscriber
	}
	return &implTimeSubscriber{NewGenericSubscription(), observer}
}

type concatTimeSubscriber struct {
	observable  int
	observer    TimeObserver
	observables []TimeObservable
	Subscription
}

func (c *concatTimeSubscriber) Next(next time.Time) {
	c.observer.Next(next)
}

func (c *concatTimeSubscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatTimeSubscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatTimeObservable struct {
	observables []TimeObservable
}

func (m *concatTimeObservable) Subscribe(observer TimeObserver) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatTimeSubscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *TimeStream) Concat(observables ...TimeObservable) *TimeStream {
	return &TimeStream{&concatTimeObservable{append([]TimeObservable{s}, observables...)}}
}

type mergeTimeObservable struct {
	delayError  bool
	observables []TimeObservable
}

func (m *mergeTimeObservable) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next time.Time, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(TimeObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *TimeStream) Merge(other ...TimeObservable) *TimeStream {
	if len(other) == 0 {
		return s
	}
	return &TimeStream{&mergeTimeObservable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *TimeStream) MergeDelayError(other ...TimeObservable) *TimeStream {
	if len(other) == 0 {
		return s
	}
	return &TimeStream{&mergeTimeObservable{true, append(other, s)}}
}

type catchTimeObservable struct {
	parent TimeObservable
	catch  TimeObservable
}

func (r *catchTimeObservable) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	run := func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(TimeObserverFunc(run))
	return subscription
}

func (s *TimeStream) Catch(catch TimeObservable) *TimeStream {
	return &TimeStream{&catchTimeObservable{s, catch}}
}

type retryTimeObservable struct {
	observable TimeObservable
}

type retryTimeObserver struct {
	observable TimeObservable
	observer   TimeObserver
}

func (r *retryTimeObserver) retry(next time.Time, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(TimeObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryTimeObservable) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryTimeObserver{r.observable, observer}
	r.observable.Subscribe(TimeObserverFunc(ro.retry))
	return subscription
}

func (s *TimeStream) Retry() *TimeStream {
	return &TimeStream{&retryTimeObservable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *TimeStream) Do(f func(next time.Time)) *TimeStream {
	return FromTimeObservable(MapTime2TimeObserveNext(s, func(next time.Time) time.Time {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *TimeStream) DoOnError(f func(err error)) *TimeStream {
	return FromTimeObservable(MapTime2TimeObserveDirect(s, func(next time.Time, err error, complete bool, observer TimeObserver) {
		if err != nil {
			f(err)
		}
		PassthroughTime(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *TimeStream) DoOnComplete(f func()) *TimeStream {
	return FromTimeObservable(MapTime2TimeObserveDirect(s, func(next time.Time, err error, complete bool, observer TimeObserver) {
		if complete {
			f()
		}
		PassthroughTime(next, err, complete, observer)
	}))
}

func (s *TimeStream) Reduce(initial time.Time, reducer func(time.Time, time.Time) time.Time) *TimeStream {
	value := initial
	return FromTimeObservable(MapTime2TimeObserveDirect(s, func(next time.Time, err error, complete bool, observer TimeObserver) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *TimeStream) Scan(initial time.Time, f func(time.Time, time.Time) time.Time) *TimeStream {
	value := initial
	return FromTimeObservable(MapTime2TimeObserveDirect(s, func(next time.Time, err error, complete bool, observer TimeObserver) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutTime struct {
	parent  TimeObservable
	timeout time.Duration
}

func (t *timeoutTime) Subscribe(observer TimeObserver) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *TimeStream) Timeout(timeout time.Duration) *TimeStream {
	return &TimeStream{&timeoutTime{s, timeout}}
}

type forkedTimeStream struct {
	lock      sync.Mutex
	parent    TimeObservable
	observers []TimeObserver
}

func (f *forkedTimeStream) Subscribe(observer TimeObserver) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *TimeStream) Fork() *TimeStream {
	f := &forkedTimeStream{parent: s}
	go s.Subscribe(TimeObserverFunc(func(n time.Time, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &TimeStream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *TimeStream) ToOneWithError() (time.Time, error) {
	valuech := make(chan time.Time, 1)
	errch := make(chan error, 1)
	FromTimeObservable(oneFilter().Time(s)).SubscribeFunc(func(next time.Time, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroTime, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *TimeStream) ToOne() time.Time {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *TimeStream) ToArrayWithError() ([]time.Time, error) {
	array := []time.Time{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *TimeStream) ToArray() []time.Time {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *TimeStream) ToChannelWithError() (<-chan time.Time, <-chan error) {
	ch := make(chan time.Time, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *TimeStream) ToChannel() <-chan time.Time {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *TimeStream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapTime2IntObserveDirect(s, func(next time.Time, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

type MappingTime2BoolFunc func(next time.Time, err error, complete bool, observer BoolObserver)
type MappingTime2BoolFuncFactory func(observer BoolObserver) MappingTime2BoolFunc

type MappingTime2BoolObservable struct {
	parent TimeObservable
	mapper MappingTime2BoolFuncFactory
}

func (f *MappingTime2BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2BoolObservable(parent TimeObservable, mapper MappingTime2BoolFuncFactory) BoolObservable {
	return &MappingTime2BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2BoolObserveDirect(parent TimeObservable, mapper MappingTime2BoolFunc) BoolObservable {
	return MapTime2BoolObservable(parent, func(BoolObserver) MappingTime2BoolFunc {
		return mapper
	})
}

func MapTime2BoolObserveNext(parent TimeObservable, mapper func(time.Time) bool) BoolObservable {
	return MapTime2BoolObservable(parent, func(BoolObserver) MappingTime2BoolFunc {
		return func(next time.Time, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Bool struct {
	parent TimeObservable
	mapper func(time.Time) BoolObservable
}

func (f *flatMapTime2Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *TimeStream) MapBool(f func(time.Time) bool) *BoolStream {
	return FromBoolObservable(MapTime2BoolObserveNext(s, f))
}

func (s *TimeStream) FlatMapBool(f func(time.Time) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapTime2Bool{s, f}}
}

type MappingTime2RuneFunc func(next time.Time, err error, complete bool, observer RuneObserver)
type MappingTime2RuneFuncFactory func(observer RuneObserver) MappingTime2RuneFunc

type MappingTime2RuneObservable struct {
	parent TimeObservable
	mapper MappingTime2RuneFuncFactory
}

func (f *MappingTime2RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2RuneObservable(parent TimeObservable, mapper MappingTime2RuneFuncFactory) RuneObservable {
	return &MappingTime2RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2RuneObserveDirect(parent TimeObservable, mapper MappingTime2RuneFunc) RuneObservable {
	return MapTime2RuneObservable(parent, func(RuneObserver) MappingTime2RuneFunc {
		return mapper
	})
}

func MapTime2RuneObserveNext(parent TimeObservable, mapper func(time.Time) rune) RuneObservable {
	return MapTime2RuneObservable(parent, func(RuneObserver) MappingTime2RuneFunc {
		return func(next time.Time, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Rune struct {
	parent TimeObservable
	mapper func(time.Time) RuneObservable
}

func (f *flatMapTime2Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *TimeStream) MapRune(f func(time.Time) rune) *RuneStream {
	return FromRuneObservable(MapTime2RuneObserveNext(s, f))
}

func (s *TimeStream) FlatMapRune(f func(time.Time) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapTime2Rune{s, f}}
}

type MappingTime2ByteFunc func(next time.Time, err error, complete bool, observer ByteObserver)
type MappingTime2ByteFuncFactory func(observer ByteObserver) MappingTime2ByteFunc

type MappingTime2ByteObservable struct {
	parent TimeObservable
	mapper MappingTime2ByteFuncFactory
}

func (f *MappingTime2ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2ByteObservable(parent TimeObservable, mapper MappingTime2ByteFuncFactory) ByteObservable {
	return &MappingTime2ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2ByteObserveDirect(parent TimeObservable, mapper MappingTime2ByteFunc) ByteObservable {
	return MapTime2ByteObservable(parent, func(ByteObserver) MappingTime2ByteFunc {
		return mapper
	})
}

func MapTime2ByteObserveNext(parent TimeObservable, mapper func(time.Time) byte) ByteObservable {
	return MapTime2ByteObservable(parent, func(ByteObserver) MappingTime2ByteFunc {
		return func(next time.Time, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Byte struct {
	parent TimeObservable
	mapper func(time.Time) ByteObservable
}

func (f *flatMapTime2Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *TimeStream) MapByte(f func(time.Time) byte) *ByteStream {
	return FromByteObservable(MapTime2ByteObserveNext(s, f))
}

func (s *TimeStream) FlatMapByte(f func(time.Time) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapTime2Byte{s, f}}
}

type MappingTime2StringFunc func(next time.Time, err error, complete bool, observer StringObserver)
type MappingTime2StringFuncFactory func(observer StringObserver) MappingTime2StringFunc

type MappingTime2StringObservable struct {
	parent TimeObservable
	mapper MappingTime2StringFuncFactory
}

func (f *MappingTime2StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2StringObservable(parent TimeObservable, mapper MappingTime2StringFuncFactory) StringObservable {
	return &MappingTime2StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2StringObserveDirect(parent TimeObservable, mapper MappingTime2StringFunc) StringObservable {
	return MapTime2StringObservable(parent, func(StringObserver) MappingTime2StringFunc {
		return mapper
	})
}

func MapTime2StringObserveNext(parent TimeObservable, mapper func(time.Time) string) StringObservable {
	return MapTime2StringObservable(parent, func(StringObserver) MappingTime2StringFunc {
		return func(next time.Time, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2String struct {
	parent TimeObservable
	mapper func(time.Time) StringObservable
}

func (f *flatMapTime2String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *TimeStream) MapString(f func(time.Time) string) *StringStream {
	return FromStringObservable(MapTime2StringObserveNext(s, f))
}

func (s *TimeStream) FlatMapString(f func(time.Time) StringObservable) *StringStream {
	return &StringStream{&flatMapTime2String{s, f}}
}

type MappingTime2UintFunc func(next time.Time, err error, complete bool, observer UintObserver)
type MappingTime2UintFuncFactory func(observer UintObserver) MappingTime2UintFunc

type MappingTime2UintObservable struct {
	parent TimeObservable
	mapper MappingTime2UintFuncFactory
}

func (f *MappingTime2UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2UintObservable(parent TimeObservable, mapper MappingTime2UintFuncFactory) UintObservable {
	return &MappingTime2UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2UintObserveDirect(parent TimeObservable, mapper MappingTime2UintFunc) UintObservable {
	return MapTime2UintObservable(parent, func(UintObserver) MappingTime2UintFunc {
		return mapper
	})
}

func MapTime2UintObserveNext(parent TimeObservable, mapper func(time.Time) uint) UintObservable {
	return MapTime2UintObservable(parent, func(UintObserver) MappingTime2UintFunc {
		return func(next time.Time, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Uint struct {
	parent TimeObservable
	mapper func(time.Time) UintObservable
}

func (f *flatMapTime2Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *TimeStream) MapUint(f func(time.Time) uint) *UintStream {
	return FromUintObservable(MapTime2UintObserveNext(s, f))
}

func (s *TimeStream) FlatMapUint(f func(time.Time) UintObservable) *UintStream {
	return &UintStream{&flatMapTime2Uint{s, f}}
}

type MappingTime2IntFunc func(next time.Time, err error, complete bool, observer IntObserver)
type MappingTime2IntFuncFactory func(observer IntObserver) MappingTime2IntFunc

type MappingTime2IntObservable struct {
	parent TimeObservable
	mapper MappingTime2IntFuncFactory
}

func (f *MappingTime2IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2IntObservable(parent TimeObservable, mapper MappingTime2IntFuncFactory) IntObservable {
	return &MappingTime2IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2IntObserveDirect(parent TimeObservable, mapper MappingTime2IntFunc) IntObservable {
	return MapTime2IntObservable(parent, func(IntObserver) MappingTime2IntFunc {
		return mapper
	})
}

func MapTime2IntObserveNext(parent TimeObservable, mapper func(time.Time) int) IntObservable {
	return MapTime2IntObservable(parent, func(IntObserver) MappingTime2IntFunc {
		return func(next time.Time, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Int struct {
	parent TimeObservable
	mapper func(time.Time) IntObservable
}

func (f *flatMapTime2Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *TimeStream) MapInt(f func(time.Time) int) *IntStream {
	return FromIntObservable(MapTime2IntObserveNext(s, f))
}

func (s *TimeStream) FlatMapInt(f func(time.Time) IntObservable) *IntStream {
	return &IntStream{&flatMapTime2Int{s, f}}
}

type MappingTime2Uint8Func func(next time.Time, err error, complete bool, observer Uint8Observer)
type MappingTime2Uint8FuncFactory func(observer Uint8Observer) MappingTime2Uint8Func

type MappingTime2Uint8Observable struct {
	parent TimeObservable
	mapper MappingTime2Uint8FuncFactory
}

func (f *MappingTime2Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2Uint8Observable(parent TimeObservable, mapper MappingTime2Uint8FuncFactory) Uint8Observable {
	return &MappingTime2Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2Uint8ObserveDirect(parent TimeObservable, mapper MappingTime2Uint8Func) Uint8Observable {
	return MapTime2Uint8Observable(parent, func(Uint8Observer) MappingTime2Uint8Func {
		return mapper
	})
}

func MapTime2Uint8ObserveNext(parent TimeObservable, mapper func(time.Time) uint8) Uint8Observable {
	return MapTime2Uint8Observable(parent, func(Uint8Observer) MappingTime2Uint8Func {
		return func(next time.Time, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Uint8 struct {
	parent TimeObservable
	mapper func(time.Time) Uint8Observable
}

func (f *flatMapTime2Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *TimeStream) MapUint8(f func(time.Time) uint8) *Uint8Stream {
	return FromUint8Observable(MapTime2Uint8ObserveNext(s, f))
}

func (s *TimeStream) FlatMapUint8(f func(time.Time) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapTime2Uint8{s, f}}
}

type MappingTime2Int8Func func(next time.Time, err error, complete bool, observer Int8Observer)
type MappingTime2Int8FuncFactory func(observer Int8Observer) MappingTime2Int8Func

type MappingTime2Int8Observable struct {
	parent TimeObservable
	mapper MappingTime2Int8FuncFactory
}

func (f *MappingTime2Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2Int8Observable(parent TimeObservable, mapper MappingTime2Int8FuncFactory) Int8Observable {
	return &MappingTime2Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2Int8ObserveDirect(parent TimeObservable, mapper MappingTime2Int8Func) Int8Observable {
	return MapTime2Int8Observable(parent, func(Int8Observer) MappingTime2Int8Func {
		return mapper
	})
}

func MapTime2Int8ObserveNext(parent TimeObservable, mapper func(time.Time) int8) Int8Observable {
	return MapTime2Int8Observable(parent, func(Int8Observer) MappingTime2Int8Func {
		return func(next time.Time, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Int8 struct {
	parent TimeObservable
	mapper func(time.Time) Int8Observable
}

func (f *flatMapTime2Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *TimeStream) MapInt8(f func(time.Time) int8) *Int8Stream {
	return FromInt8Observable(MapTime2Int8ObserveNext(s, f))
}

func (s *TimeStream) FlatMapInt8(f func(time.Time) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapTime2Int8{s, f}}
}

type MappingTime2Uint16Func func(next time.Time, err error, complete bool, observer Uint16Observer)
type MappingTime2Uint16FuncFactory func(observer Uint16Observer) MappingTime2Uint16Func

type MappingTime2Uint16Observable struct {
	parent TimeObservable
	mapper MappingTime2Uint16FuncFactory
}

func (f *MappingTime2Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2Uint16Observable(parent TimeObservable, mapper MappingTime2Uint16FuncFactory) Uint16Observable {
	return &MappingTime2Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2Uint16ObserveDirect(parent TimeObservable, mapper MappingTime2Uint16Func) Uint16Observable {
	return MapTime2Uint16Observable(parent, func(Uint16Observer) MappingTime2Uint16Func {
		return mapper
	})
}

func MapTime2Uint16ObserveNext(parent TimeObservable, mapper func(time.Time) uint16) Uint16Observable {
	return MapTime2Uint16Observable(parent, func(Uint16Observer) MappingTime2Uint16Func {
		return func(next time.Time, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Uint16 struct {
	parent TimeObservable
	mapper func(time.Time) Uint16Observable
}

func (f *flatMapTime2Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *TimeStream) MapUint16(f func(time.Time) uint16) *Uint16Stream {
	return FromUint16Observable(MapTime2Uint16ObserveNext(s, f))
}

func (s *TimeStream) FlatMapUint16(f func(time.Time) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapTime2Uint16{s, f}}
}

type MappingTime2Int16Func func(next time.Time, err error, complete bool, observer Int16Observer)
type MappingTime2Int16FuncFactory func(observer Int16Observer) MappingTime2Int16Func

type MappingTime2Int16Observable struct {
	parent TimeObservable
	mapper MappingTime2Int16FuncFactory
}

func (f *MappingTime2Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2Int16Observable(parent TimeObservable, mapper MappingTime2Int16FuncFactory) Int16Observable {
	return &MappingTime2Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2Int16ObserveDirect(parent TimeObservable, mapper MappingTime2Int16Func) Int16Observable {
	return MapTime2Int16Observable(parent, func(Int16Observer) MappingTime2Int16Func {
		return mapper
	})
}

func MapTime2Int16ObserveNext(parent TimeObservable, mapper func(time.Time) int16) Int16Observable {
	return MapTime2Int16Observable(parent, func(Int16Observer) MappingTime2Int16Func {
		return func(next time.Time, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Int16 struct {
	parent TimeObservable
	mapper func(time.Time) Int16Observable
}

func (f *flatMapTime2Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *TimeStream) MapInt16(f func(time.Time) int16) *Int16Stream {
	return FromInt16Observable(MapTime2Int16ObserveNext(s, f))
}

func (s *TimeStream) FlatMapInt16(f func(time.Time) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapTime2Int16{s, f}}
}

type MappingTime2Uint32Func func(next time.Time, err error, complete bool, observer Uint32Observer)
type MappingTime2Uint32FuncFactory func(observer Uint32Observer) MappingTime2Uint32Func

type MappingTime2Uint32Observable struct {
	parent TimeObservable
	mapper MappingTime2Uint32FuncFactory
}

func (f *MappingTime2Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2Uint32Observable(parent TimeObservable, mapper MappingTime2Uint32FuncFactory) Uint32Observable {
	return &MappingTime2Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2Uint32ObserveDirect(parent TimeObservable, mapper MappingTime2Uint32Func) Uint32Observable {
	return MapTime2Uint32Observable(parent, func(Uint32Observer) MappingTime2Uint32Func {
		return mapper
	})
}

func MapTime2Uint32ObserveNext(parent TimeObservable, mapper func(time.Time) uint32) Uint32Observable {
	return MapTime2Uint32Observable(parent, func(Uint32Observer) MappingTime2Uint32Func {
		return func(next time.Time, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Uint32 struct {
	parent TimeObservable
	mapper func(time.Time) Uint32Observable
}

func (f *flatMapTime2Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *TimeStream) MapUint32(f func(time.Time) uint32) *Uint32Stream {
	return FromUint32Observable(MapTime2Uint32ObserveNext(s, f))
}

func (s *TimeStream) FlatMapUint32(f func(time.Time) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapTime2Uint32{s, f}}
}

type MappingTime2Int32Func func(next time.Time, err error, complete bool, observer Int32Observer)
type MappingTime2Int32FuncFactory func(observer Int32Observer) MappingTime2Int32Func

type MappingTime2Int32Observable struct {
	parent TimeObservable
	mapper MappingTime2Int32FuncFactory
}

func (f *MappingTime2Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2Int32Observable(parent TimeObservable, mapper MappingTime2Int32FuncFactory) Int32Observable {
	return &MappingTime2Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2Int32ObserveDirect(parent TimeObservable, mapper MappingTime2Int32Func) Int32Observable {
	return MapTime2Int32Observable(parent, func(Int32Observer) MappingTime2Int32Func {
		return mapper
	})
}

func MapTime2Int32ObserveNext(parent TimeObservable, mapper func(time.Time) int32) Int32Observable {
	return MapTime2Int32Observable(parent, func(Int32Observer) MappingTime2Int32Func {
		return func(next time.Time, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Int32 struct {
	parent TimeObservable
	mapper func(time.Time) Int32Observable
}

func (f *flatMapTime2Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *TimeStream) MapInt32(f func(time.Time) int32) *Int32Stream {
	return FromInt32Observable(MapTime2Int32ObserveNext(s, f))
}

func (s *TimeStream) FlatMapInt32(f func(time.Time) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapTime2Int32{s, f}}
}

type MappingTime2Uint64Func func(next time.Time, err error, complete bool, observer Uint64Observer)
type MappingTime2Uint64FuncFactory func(observer Uint64Observer) MappingTime2Uint64Func

type MappingTime2Uint64Observable struct {
	parent TimeObservable
	mapper MappingTime2Uint64FuncFactory
}

func (f *MappingTime2Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2Uint64Observable(parent TimeObservable, mapper MappingTime2Uint64FuncFactory) Uint64Observable {
	return &MappingTime2Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2Uint64ObserveDirect(parent TimeObservable, mapper MappingTime2Uint64Func) Uint64Observable {
	return MapTime2Uint64Observable(parent, func(Uint64Observer) MappingTime2Uint64Func {
		return mapper
	})
}

func MapTime2Uint64ObserveNext(parent TimeObservable, mapper func(time.Time) uint64) Uint64Observable {
	return MapTime2Uint64Observable(parent, func(Uint64Observer) MappingTime2Uint64Func {
		return func(next time.Time, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Uint64 struct {
	parent TimeObservable
	mapper func(time.Time) Uint64Observable
}

func (f *flatMapTime2Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *TimeStream) MapUint64(f func(time.Time) uint64) *Uint64Stream {
	return FromUint64Observable(MapTime2Uint64ObserveNext(s, f))
}

func (s *TimeStream) FlatMapUint64(f func(time.Time) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapTime2Uint64{s, f}}
}

type MappingTime2Int64Func func(next time.Time, err error, complete bool, observer Int64Observer)
type MappingTime2Int64FuncFactory func(observer Int64Observer) MappingTime2Int64Func

type MappingTime2Int64Observable struct {
	parent TimeObservable
	mapper MappingTime2Int64FuncFactory
}

func (f *MappingTime2Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2Int64Observable(parent TimeObservable, mapper MappingTime2Int64FuncFactory) Int64Observable {
	return &MappingTime2Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2Int64ObserveDirect(parent TimeObservable, mapper MappingTime2Int64Func) Int64Observable {
	return MapTime2Int64Observable(parent, func(Int64Observer) MappingTime2Int64Func {
		return mapper
	})
}

func MapTime2Int64ObserveNext(parent TimeObservable, mapper func(time.Time) int64) Int64Observable {
	return MapTime2Int64Observable(parent, func(Int64Observer) MappingTime2Int64Func {
		return func(next time.Time, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Int64 struct {
	parent TimeObservable
	mapper func(time.Time) Int64Observable
}

func (f *flatMapTime2Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *TimeStream) MapInt64(f func(time.Time) int64) *Int64Stream {
	return FromInt64Observable(MapTime2Int64ObserveNext(s, f))
}

func (s *TimeStream) FlatMapInt64(f func(time.Time) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapTime2Int64{s, f}}
}

type MappingTime2Float32Func func(next time.Time, err error, complete bool, observer Float32Observer)
type MappingTime2Float32FuncFactory func(observer Float32Observer) MappingTime2Float32Func

type MappingTime2Float32Observable struct {
	parent TimeObservable
	mapper MappingTime2Float32FuncFactory
}

func (f *MappingTime2Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2Float32Observable(parent TimeObservable, mapper MappingTime2Float32FuncFactory) Float32Observable {
	return &MappingTime2Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2Float32ObserveDirect(parent TimeObservable, mapper MappingTime2Float32Func) Float32Observable {
	return MapTime2Float32Observable(parent, func(Float32Observer) MappingTime2Float32Func {
		return mapper
	})
}

func MapTime2Float32ObserveNext(parent TimeObservable, mapper func(time.Time) float32) Float32Observable {
	return MapTime2Float32Observable(parent, func(Float32Observer) MappingTime2Float32Func {
		return func(next time.Time, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Float32 struct {
	parent TimeObservable
	mapper func(time.Time) Float32Observable
}

func (f *flatMapTime2Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *TimeStream) MapFloat32(f func(time.Time) float32) *Float32Stream {
	return FromFloat32Observable(MapTime2Float32ObserveNext(s, f))
}

func (s *TimeStream) FlatMapFloat32(f func(time.Time) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapTime2Float32{s, f}}
}

type MappingTime2Float64Func func(next time.Time, err error, complete bool, observer Float64Observer)
type MappingTime2Float64FuncFactory func(observer Float64Observer) MappingTime2Float64Func

type MappingTime2Float64Observable struct {
	parent TimeObservable
	mapper MappingTime2Float64FuncFactory
}

func (f *MappingTime2Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2Float64Observable(parent TimeObservable, mapper MappingTime2Float64FuncFactory) Float64Observable {
	return &MappingTime2Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2Float64ObserveDirect(parent TimeObservable, mapper MappingTime2Float64Func) Float64Observable {
	return MapTime2Float64Observable(parent, func(Float64Observer) MappingTime2Float64Func {
		return mapper
	})
}

func MapTime2Float64ObserveNext(parent TimeObservable, mapper func(time.Time) float64) Float64Observable {
	return MapTime2Float64Observable(parent, func(Float64Observer) MappingTime2Float64Func {
		return func(next time.Time, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Float64 struct {
	parent TimeObservable
	mapper func(time.Time) Float64Observable
}

func (f *flatMapTime2Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *TimeStream) MapFloat64(f func(time.Time) float64) *Float64Stream {
	return FromFloat64Observable(MapTime2Float64ObserveNext(s, f))
}

func (s *TimeStream) FlatMapFloat64(f func(time.Time) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapTime2Float64{s, f}}
}

type MappingTime2Complex64Func func(next time.Time, err error, complete bool, observer Complex64Observer)
type MappingTime2Complex64FuncFactory func(observer Complex64Observer) MappingTime2Complex64Func

type MappingTime2Complex64Observable struct {
	parent TimeObservable
	mapper MappingTime2Complex64FuncFactory
}

func (f *MappingTime2Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2Complex64Observable(parent TimeObservable, mapper MappingTime2Complex64FuncFactory) Complex64Observable {
	return &MappingTime2Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2Complex64ObserveDirect(parent TimeObservable, mapper MappingTime2Complex64Func) Complex64Observable {
	return MapTime2Complex64Observable(parent, func(Complex64Observer) MappingTime2Complex64Func {
		return mapper
	})
}

func MapTime2Complex64ObserveNext(parent TimeObservable, mapper func(time.Time) complex64) Complex64Observable {
	return MapTime2Complex64Observable(parent, func(Complex64Observer) MappingTime2Complex64Func {
		return func(next time.Time, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Complex64 struct {
	parent TimeObservable
	mapper func(time.Time) Complex64Observable
}

func (f *flatMapTime2Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *TimeStream) MapComplex64(f func(time.Time) complex64) *Complex64Stream {
	return FromComplex64Observable(MapTime2Complex64ObserveNext(s, f))
}

func (s *TimeStream) FlatMapComplex64(f func(time.Time) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapTime2Complex64{s, f}}
}

type MappingTime2Complex128Func func(next time.Time, err error, complete bool, observer Complex128Observer)
type MappingTime2Complex128FuncFactory func(observer Complex128Observer) MappingTime2Complex128Func

type MappingTime2Complex128Observable struct {
	parent TimeObservable
	mapper MappingTime2Complex128FuncFactory
}

func (f *MappingTime2Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2Complex128Observable(parent TimeObservable, mapper MappingTime2Complex128FuncFactory) Complex128Observable {
	return &MappingTime2Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2Complex128ObserveDirect(parent TimeObservable, mapper MappingTime2Complex128Func) Complex128Observable {
	return MapTime2Complex128Observable(parent, func(Complex128Observer) MappingTime2Complex128Func {
		return mapper
	})
}

func MapTime2Complex128ObserveNext(parent TimeObservable, mapper func(time.Time) complex128) Complex128Observable {
	return MapTime2Complex128Observable(parent, func(Complex128Observer) MappingTime2Complex128Func {
		return func(next time.Time, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Complex128 struct {
	parent TimeObservable
	mapper func(time.Time) Complex128Observable
}

func (f *flatMapTime2Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *TimeStream) MapComplex128(f func(time.Time) complex128) *Complex128Stream {
	return FromComplex128Observable(MapTime2Complex128ObserveNext(s, f))
}

func (s *TimeStream) FlatMapComplex128(f func(time.Time) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapTime2Complex128{s, f}}
}

type MappingTime2TimeFunc func(next time.Time, err error, complete bool, observer TimeObserver)
type MappingTime2TimeFuncFactory func(observer TimeObserver) MappingTime2TimeFunc

type MappingTime2TimeObservable struct {
	parent TimeObservable
	mapper MappingTime2TimeFuncFactory
}

func (f *MappingTime2TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2TimeObservable(parent TimeObservable, mapper MappingTime2TimeFuncFactory) TimeObservable {
	return &MappingTime2TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2TimeObserveDirect(parent TimeObservable, mapper MappingTime2TimeFunc) TimeObservable {
	return MapTime2TimeObservable(parent, func(TimeObserver) MappingTime2TimeFunc {
		return mapper
	})
}

func MapTime2TimeObserveNext(parent TimeObservable, mapper func(time.Time) time.Time) TimeObservable {
	return MapTime2TimeObservable(parent, func(TimeObserver) MappingTime2TimeFunc {
		return func(next time.Time, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Time struct {
	parent TimeObservable
	mapper func(time.Time) TimeObservable
}

func (f *flatMapTime2Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *TimeStream) Map(f func(time.Time) time.Time) *TimeStream {
	return FromTimeObservable(MapTime2TimeObserveNext(s, f))
}

func (s *TimeStream) FlatMap(f func(time.Time) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapTime2Time{s, f}}
}

type MappingTime2DurationFunc func(next time.Time, err error, complete bool, observer DurationObserver)
type MappingTime2DurationFuncFactory func(observer DurationObserver) MappingTime2DurationFunc

type MappingTime2DurationObservable struct {
	parent TimeObservable
	mapper MappingTime2DurationFuncFactory
}

func (f *MappingTime2DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapTime2DurationObservable(parent TimeObservable, mapper MappingTime2DurationFuncFactory) DurationObservable {
	return &MappingTime2DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2DurationObserveDirect(parent TimeObservable, mapper MappingTime2DurationFunc) DurationObservable {
	return MapTime2DurationObservable(parent, func(DurationObserver) MappingTime2DurationFunc {
		return mapper
	})
}

func MapTime2DurationObserveNext(parent TimeObservable, mapper func(time.Time) time.Duration) DurationObservable {
	return MapTime2DurationObservable(parent, func(DurationObserver) MappingTime2DurationFunc {
		return func(next time.Time, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapTime2Duration struct {
	parent TimeObservable
	mapper func(time.Time) DurationObservable
}

func (f *flatMapTime2Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(TimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapDuration maps this stream to an DurationStream via f.
func (s *TimeStream) MapDuration(f func(time.Time) time.Duration) *DurationStream {
	return FromDurationObservable(MapTime2DurationObserveNext(s, f))
}

func (s *TimeStream) FlatMapDuration(f func(time.Time) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapTime2Duration{s, f}}
}

type DurationObserver interface {
	Next(time.Duration)
	TerminationObserver
}

// A DurationSubscriber represents a subscribed DurationObserver.
type DurationSubscriber interface {
	Subscription
	DurationObserver
}

type implDurationSubscriber struct {
	Subscription
	DurationObserver
}

func DurationObserverAsGenericObserver(observer DurationObserver) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(time.Duration))
		}
	})
}

func GenericObserverAsDurationObserver(observer GenericObserver) DurationObserver {
	return DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type DurationObservableFactory func(observer DurationObserver, subscription Subscription)

func (f DurationObservableFactory) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateDuration calls f(observer, subscription) to produce values for a stream.
func CreateDuration(f func(observer DurationObserver, subscription Subscription)) *DurationStream {
	return FromDurationObservable(DurationObservableFactory(f))
}

// Repeat value count times.
func RepeatDuration(value time.Duration, count int) *DurationStream {
	return CreateDuration(func(observer DurationObserver, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartDuration is designed to be used with functions that return a
// (time.Duration, error) tuple.
//
// If the error is non-nil the returned DurationStream will be that error,
// otherwise it will be a single-value stream of time.Duration.
func StartDuration(f func() (time.Duration, error)) *DurationStream {
	return CreateDuration(func(observer DurationObserver, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughDuration(next time.Duration, err error, complete bool, observer DurationObserver) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

var zeroDuration = *new(time.Duration)

type DurationObserverFunc func(time.Duration, error, bool)

func (f DurationObserverFunc) Next(next time.Duration) { f(next, nil, false) }
func (f DurationObserverFunc) Error(err error)         { f(zeroDuration, err, false) }
func (f DurationObserverFunc) Complete()               { f(zeroDuration, nil, true) }

type DurationObservable interface {
	Subscribe(DurationObserver) Subscription
}

// Convert a GenericObservableFilter to a DurationObservable
func (f GenericObservableFilterFactory) Duration(parent DurationObservable) DurationObservable {
	return MapDuration2DurationObservable(parent, func(observer DurationObserver) MappingDuration2DurationFunc {
		gobserver := DurationObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next time.Duration, err error, complete bool, observer DurationObserver) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverDuration() *DurationStream {
	return CreateDuration(func(observer DurationObserver, subscription Subscription) {})
}

func EmptyDuration() *DurationStream {
	return CreateDuration(func(observer DurationObserver, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowDuration(err error) *DurationStream {
	return CreateDuration(func(observer DurationObserver, subscription Subscription) {
		observer.Error(err)
	})
}

func FromDurationArray(array []time.Duration) *DurationStream {
	return CreateDuration(func(observer DurationObserver, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromDurations(array ...time.Duration) *DurationStream {
	return FromDurationArray(array)
}

func JustDuration(element time.Duration) *DurationStream {
	return FromDurationArray([]time.Duration{element})
}

func MergeDuration(observables ...DurationObservable) *DurationStream {
	if len(observables) == 0 {
		return EmptyDuration()
	}
	return (&DurationStream{observables[0]}).Merge(observables[1:]...)
}

func MergeDurationDelayError(observables ...DurationObservable) *DurationStream {
	if len(observables) == 0 {
		return EmptyDuration()
	}
	return (&DurationStream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromDurationChannel(ch <-chan time.Duration) *DurationStream {
	return CreateDuration(func(observer DurationObserver, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type DurationStream struct {
	DurationObservable
}

func FromDurationObservable(observable DurationObservable) *DurationStream {
	return &DurationStream{observable}
}

func (s *DurationStream) SubscribeFunc(f func(time.Duration, error, bool)) Subscription {
	return s.Subscribe(DurationObserverFunc(f))
}

func (s *DurationStream) SubscribeNext(f func(v time.Duration)) Subscription {
	return s.SubscribeFunc(func(next time.Duration, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *DurationStream) Distinct() *DurationStream {
	return FromDurationObservable(distinctFilter().Duration(s))
}

// ElementAt yields the Nth element of the stream.
func (s *DurationStream) ElementAt(n int) *DurationStream {
	return FromDurationObservable(elementAtFilter(n).Duration(s))
}

// Filter elements in the stream on a function.
func (s *DurationStream) Filter(f func(time.Duration) bool) *DurationStream {
	return FromDurationObservable(filterFilter(func(v interface{}) bool { return f(v.(time.Duration)) }).Duration(s))
}

// Last returns just the first element of the stream.
func (s *DurationStream) First() *DurationStream {
	return FromDurationObservable(firstFilter().Duration(s))
}

// Last returns just the last element of the stream.
func (s *DurationStream) Last() *DurationStream {
	return FromDurationObservable(lastFilter().Duration(s))
}

// SkipLast skips the first N elements of the stream.
func (s *DurationStream) Skip(n int) *DurationStream {
	return FromDurationObservable(skipFilter(n).Duration(s))
}

// SkipLast skips the last N elements of the stream.
func (s *DurationStream) SkipLast(n int) *DurationStream {
	return FromDurationObservable(skipLastFilter(n).Duration(s))
}

// Take returns just the first N elements of the stream.
func (s *DurationStream) Take(n int) *DurationStream {
	return FromDurationObservable(takeFilter(n).Duration(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *DurationStream) TakeLast(n int) *DurationStream {
	return FromDurationObservable(takeLastFilter(n).Duration(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *DurationStream) IgnoreElements() *DurationStream {
	return FromDurationObservable(ignoreElementsFilter().Duration(s))
}

func (s *DurationStream) Replay(size int, duration time.Duration) *DurationStream {
	return FromDurationObservable(replayFilter(size, duration).Duration(s))
}

func (s *DurationStream) Sample(duration time.Duration) *DurationStream {
	return FromDurationObservable(sampleFilter(duration).Duration(s))
}

func (s *DurationStream) Debounce(duration time.Duration) *DurationStream {
	return FromDurationObservable(debounceFilter(duration).Duration(s))
}

// Wait for completion of the stream and return any error.
func (s *DurationStream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeDurationSubscriber(observer DurationObserver) DurationSubscriber {
	if subscriber, ok := observer.(DurationSubscriber); ok {
		return subscriber
	}
	return &implDurationSubscriber{NewGenericSubscription(), observer}
}

type concatDurationSubscriber struct {
	observable  int
	observer    DurationObserver
	observables []DurationObservable
	Subscription
}

func (c *concatDurationSubscriber) Next(next time.Duration) {
	c.observer.Next(next)
}

func (c *concatDurationSubscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatDurationSubscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatDurationObservable struct {
	observables []DurationObservable
}

func (m *concatDurationObservable) Subscribe(observer DurationObserver) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatDurationSubscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *DurationStream) Concat(observables ...DurationObservable) *DurationStream {
	return &DurationStream{&concatDurationObservable{append([]DurationObservable{s}, observables...)}}
}

type mergeDurationObservable struct {
	delayError  bool
	observables []DurationObservable
}

func (m *mergeDurationObservable) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next time.Duration, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(DurationObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *DurationStream) Merge(other ...DurationObservable) *DurationStream {
	if len(other) == 0 {
		return s
	}
	return &DurationStream{&mergeDurationObservable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *DurationStream) MergeDelayError(other ...DurationObservable) *DurationStream {
	if len(other) == 0 {
		return s
	}
	return &DurationStream{&mergeDurationObservable{true, append(other, s)}}
}

type catchDurationObservable struct {
	parent DurationObservable
	catch  DurationObservable
}

func (r *catchDurationObservable) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	run := func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(DurationObserverFunc(run))
	return subscription
}

func (s *DurationStream) Catch(catch DurationObservable) *DurationStream {
	return &DurationStream{&catchDurationObservable{s, catch}}
}

type retryDurationObservable struct {
	observable DurationObservable
}

type retryDurationObserver struct {
	observable DurationObservable
	observer   DurationObserver
}

func (r *retryDurationObserver) retry(next time.Duration, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(DurationObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryDurationObservable) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryDurationObserver{r.observable, observer}
	r.observable.Subscribe(DurationObserverFunc(ro.retry))
	return subscription
}

func (s *DurationStream) Retry() *DurationStream {
	return &DurationStream{&retryDurationObservable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *DurationStream) Do(f func(next time.Duration)) *DurationStream {
	return FromDurationObservable(MapDuration2DurationObserveNext(s, func(next time.Duration) time.Duration {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *DurationStream) DoOnError(f func(err error)) *DurationStream {
	return FromDurationObservable(MapDuration2DurationObserveDirect(s, func(next time.Duration, err error, complete bool, observer DurationObserver) {
		if err != nil {
			f(err)
		}
		PassthroughDuration(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *DurationStream) DoOnComplete(f func()) *DurationStream {
	return FromDurationObservable(MapDuration2DurationObserveDirect(s, func(next time.Duration, err error, complete bool, observer DurationObserver) {
		if complete {
			f()
		}
		PassthroughDuration(next, err, complete, observer)
	}))
}

func (s *DurationStream) Reduce(initial time.Duration, reducer func(time.Duration, time.Duration) time.Duration) *DurationStream {
	value := initial
	return FromDurationObservable(MapDuration2DurationObserveDirect(s, func(next time.Duration, err error, complete bool, observer DurationObserver) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *DurationStream) Scan(initial time.Duration, f func(time.Duration, time.Duration) time.Duration) *DurationStream {
	value := initial
	return FromDurationObservable(MapDuration2DurationObserveDirect(s, func(next time.Duration, err error, complete bool, observer DurationObserver) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

type timeoutDuration struct {
	parent  DurationObservable
	timeout time.Duration
}

func (t *timeoutDuration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewChannelSubscription()
	cancel := t.parent.Subscribe(observer)
	go func() {
		select {
		case <-time.After(t.timeout):
			observer.Error(ErrTimeout)
			_ = cancel.Close()
			_ = subscription.Close()
		case <-subscription:
			_ = cancel.Close()
		}
	}()
	return subscription
}

func (s *DurationStream) Timeout(timeout time.Duration) *DurationStream {
	return &DurationStream{&timeoutDuration{s, timeout}}
}

type forkedDurationStream struct {
	lock      sync.Mutex
	parent    DurationObservable
	observers []DurationObserver
}

func (f *forkedDurationStream) Subscribe(observer DurationObserver) Subscription {
	f.lock.Lock()
	defer f.lock.Unlock()
	f.observers = append(f.observers, observer)
	return nil
}

// Fork replicates each event from the parent to every subscriber of the fork.
func (s *DurationStream) Fork() *DurationStream {
	f := &forkedDurationStream{parent: s}
	go s.Subscribe(DurationObserverFunc(func(n time.Duration, err error, complete bool) {
		f.lock.Lock()
		defer f.lock.Unlock()
		for _, o := range f.observers {
			switch {
			case err != nil:
				o.Error(err)
			case complete:
				o.Complete()
			default:
				o.Next(n)
			}
		}
	}))
	return &DurationStream{f}
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *DurationStream) ToOneWithError() (time.Duration, error) {
	valuech := make(chan time.Duration, 1)
	errch := make(chan error, 1)
	FromDurationObservable(oneFilter().Duration(s)).SubscribeFunc(func(next time.Duration, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroDuration, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *DurationStream) ToOne() time.Duration {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *DurationStream) ToArrayWithError() ([]time.Duration, error) {
	array := []time.Duration{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *DurationStream) ToArray() []time.Duration {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *DurationStream) ToChannelWithError() (<-chan time.Duration, <-chan error) {
	ch := make(chan time.Duration, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *DurationStream) ToChannel() <-chan time.Duration {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *DurationStream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapDuration2IntObserveDirect(s, func(next time.Duration, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

type MappingDuration2BoolFunc func(next time.Duration, err error, complete bool, observer BoolObserver)
type MappingDuration2BoolFuncFactory func(observer BoolObserver) MappingDuration2BoolFunc

type MappingDuration2BoolObservable struct {
	parent DurationObservable
	mapper MappingDuration2BoolFuncFactory
}

func (f *MappingDuration2BoolObservable) Subscribe(observer BoolObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2BoolObservable(parent DurationObservable, mapper MappingDuration2BoolFuncFactory) BoolObservable {
	return &MappingDuration2BoolObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2BoolObserveDirect(parent DurationObservable, mapper MappingDuration2BoolFunc) BoolObservable {
	return MapDuration2BoolObservable(parent, func(BoolObserver) MappingDuration2BoolFunc {
		return mapper
	})
}

func MapDuration2BoolObserveNext(parent DurationObservable, mapper func(time.Duration) bool) BoolObservable {
	return MapDuration2BoolObservable(parent, func(BoolObserver) MappingDuration2BoolFunc {
		return func(next time.Duration, err error, complete bool, observer BoolObserver) {
			var mapped bool
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughBool(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Bool struct {
	parent DurationObservable
	mapper func(time.Duration) BoolObservable
}

func (f *flatMapDuration2Bool) Subscribe(observer BoolObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&BoolStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &BoolStream{ignoreCompletionFilter().Bool(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapBool maps this stream to an BoolStream via f.
func (s *DurationStream) MapBool(f func(time.Duration) bool) *BoolStream {
	return FromBoolObservable(MapDuration2BoolObserveNext(s, f))
}

func (s *DurationStream) FlatMapBool(f func(time.Duration) BoolObservable) *BoolStream {
	return &BoolStream{&flatMapDuration2Bool{s, f}}
}

type MappingDuration2RuneFunc func(next time.Duration, err error, complete bool, observer RuneObserver)
type MappingDuration2RuneFuncFactory func(observer RuneObserver) MappingDuration2RuneFunc

type MappingDuration2RuneObservable struct {
	parent DurationObservable
	mapper MappingDuration2RuneFuncFactory
}

func (f *MappingDuration2RuneObservable) Subscribe(observer RuneObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2RuneObservable(parent DurationObservable, mapper MappingDuration2RuneFuncFactory) RuneObservable {
	return &MappingDuration2RuneObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2RuneObserveDirect(parent DurationObservable, mapper MappingDuration2RuneFunc) RuneObservable {
	return MapDuration2RuneObservable(parent, func(RuneObserver) MappingDuration2RuneFunc {
		return mapper
	})
}

func MapDuration2RuneObserveNext(parent DurationObservable, mapper func(time.Duration) rune) RuneObservable {
	return MapDuration2RuneObservable(parent, func(RuneObserver) MappingDuration2RuneFunc {
		return func(next time.Duration, err error, complete bool, observer RuneObserver) {
			var mapped rune
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughRune(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Rune struct {
	parent DurationObservable
	mapper func(time.Duration) RuneObservable
}

func (f *flatMapDuration2Rune) Subscribe(observer RuneObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&RuneStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &RuneStream{ignoreCompletionFilter().Rune(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapRune maps this stream to an RuneStream via f.
func (s *DurationStream) MapRune(f func(time.Duration) rune) *RuneStream {
	return FromRuneObservable(MapDuration2RuneObserveNext(s, f))
}

func (s *DurationStream) FlatMapRune(f func(time.Duration) RuneObservable) *RuneStream {
	return &RuneStream{&flatMapDuration2Rune{s, f}}
}

type MappingDuration2ByteFunc func(next time.Duration, err error, complete bool, observer ByteObserver)
type MappingDuration2ByteFuncFactory func(observer ByteObserver) MappingDuration2ByteFunc

type MappingDuration2ByteObservable struct {
	parent DurationObservable
	mapper MappingDuration2ByteFuncFactory
}

func (f *MappingDuration2ByteObservable) Subscribe(observer ByteObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2ByteObservable(parent DurationObservable, mapper MappingDuration2ByteFuncFactory) ByteObservable {
	return &MappingDuration2ByteObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2ByteObserveDirect(parent DurationObservable, mapper MappingDuration2ByteFunc) ByteObservable {
	return MapDuration2ByteObservable(parent, func(ByteObserver) MappingDuration2ByteFunc {
		return mapper
	})
}

func MapDuration2ByteObserveNext(parent DurationObservable, mapper func(time.Duration) byte) ByteObservable {
	return MapDuration2ByteObservable(parent, func(ByteObserver) MappingDuration2ByteFunc {
		return func(next time.Duration, err error, complete bool, observer ByteObserver) {
			var mapped byte
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughByte(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Byte struct {
	parent DurationObservable
	mapper func(time.Duration) ByteObservable
}

func (f *flatMapDuration2Byte) Subscribe(observer ByteObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&ByteStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &ByteStream{ignoreCompletionFilter().Byte(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapByte maps this stream to an ByteStream via f.
func (s *DurationStream) MapByte(f func(time.Duration) byte) *ByteStream {
	return FromByteObservable(MapDuration2ByteObserveNext(s, f))
}

func (s *DurationStream) FlatMapByte(f func(time.Duration) ByteObservable) *ByteStream {
	return &ByteStream{&flatMapDuration2Byte{s, f}}
}

type MappingDuration2StringFunc func(next time.Duration, err error, complete bool, observer StringObserver)
type MappingDuration2StringFuncFactory func(observer StringObserver) MappingDuration2StringFunc

type MappingDuration2StringObservable struct {
	parent DurationObservable
	mapper MappingDuration2StringFuncFactory
}

func (f *MappingDuration2StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2StringObservable(parent DurationObservable, mapper MappingDuration2StringFuncFactory) StringObservable {
	return &MappingDuration2StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2StringObserveDirect(parent DurationObservable, mapper MappingDuration2StringFunc) StringObservable {
	return MapDuration2StringObservable(parent, func(StringObserver) MappingDuration2StringFunc {
		return mapper
	})
}

func MapDuration2StringObserveNext(parent DurationObservable, mapper func(time.Duration) string) StringObservable {
	return MapDuration2StringObservable(parent, func(StringObserver) MappingDuration2StringFunc {
		return func(next time.Duration, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2String struct {
	parent DurationObservable
	mapper func(time.Duration) StringObservable
}

func (f *flatMapDuration2String) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&StringStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &StringStream{ignoreCompletionFilter().String(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapString maps this stream to an StringStream via f.
func (s *DurationStream) MapString(f func(time.Duration) string) *StringStream {
	return FromStringObservable(MapDuration2StringObserveNext(s, f))
}

func (s *DurationStream) FlatMapString(f func(time.Duration) StringObservable) *StringStream {
	return &StringStream{&flatMapDuration2String{s, f}}
}

type MappingDuration2UintFunc func(next time.Duration, err error, complete bool, observer UintObserver)
type MappingDuration2UintFuncFactory func(observer UintObserver) MappingDuration2UintFunc

type MappingDuration2UintObservable struct {
	parent DurationObservable
	mapper MappingDuration2UintFuncFactory
}

func (f *MappingDuration2UintObservable) Subscribe(observer UintObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2UintObservable(parent DurationObservable, mapper MappingDuration2UintFuncFactory) UintObservable {
	return &MappingDuration2UintObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2UintObserveDirect(parent DurationObservable, mapper MappingDuration2UintFunc) UintObservable {
	return MapDuration2UintObservable(parent, func(UintObserver) MappingDuration2UintFunc {
		return mapper
	})
}

func MapDuration2UintObserveNext(parent DurationObservable, mapper func(time.Duration) uint) UintObservable {
	return MapDuration2UintObservable(parent, func(UintObserver) MappingDuration2UintFunc {
		return func(next time.Duration, err error, complete bool, observer UintObserver) {
			var mapped uint
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Uint struct {
	parent DurationObservable
	mapper func(time.Duration) UintObservable
}

func (f *flatMapDuration2Uint) Subscribe(observer UintObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&UintStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &UintStream{ignoreCompletionFilter().Uint(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint maps this stream to an UintStream via f.
func (s *DurationStream) MapUint(f func(time.Duration) uint) *UintStream {
	return FromUintObservable(MapDuration2UintObserveNext(s, f))
}

func (s *DurationStream) FlatMapUint(f func(time.Duration) UintObservable) *UintStream {
	return &UintStream{&flatMapDuration2Uint{s, f}}
}

type MappingDuration2IntFunc func(next time.Duration, err error, complete bool, observer IntObserver)
type MappingDuration2IntFuncFactory func(observer IntObserver) MappingDuration2IntFunc

type MappingDuration2IntObservable struct {
	parent DurationObservable
	mapper MappingDuration2IntFuncFactory
}

func (f *MappingDuration2IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2IntObservable(parent DurationObservable, mapper MappingDuration2IntFuncFactory) IntObservable {
	return &MappingDuration2IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2IntObserveDirect(parent DurationObservable, mapper MappingDuration2IntFunc) IntObservable {
	return MapDuration2IntObservable(parent, func(IntObserver) MappingDuration2IntFunc {
		return mapper
	})
}

func MapDuration2IntObserveNext(parent DurationObservable, mapper func(time.Duration) int) IntObservable {
	return MapDuration2IntObservable(parent, func(IntObserver) MappingDuration2IntFunc {
		return func(next time.Duration, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Int struct {
	parent DurationObservable
	mapper func(time.Duration) IntObservable
}

func (f *flatMapDuration2Int) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&IntStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &IntStream{ignoreCompletionFilter().Int(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt maps this stream to an IntStream via f.
func (s *DurationStream) MapInt(f func(time.Duration) int) *IntStream {
	return FromIntObservable(MapDuration2IntObserveNext(s, f))
}

func (s *DurationStream) FlatMapInt(f func(time.Duration) IntObservable) *IntStream {
	return &IntStream{&flatMapDuration2Int{s, f}}
}

type MappingDuration2Uint8Func func(next time.Duration, err error, complete bool, observer Uint8Observer)
type MappingDuration2Uint8FuncFactory func(observer Uint8Observer) MappingDuration2Uint8Func

type MappingDuration2Uint8Observable struct {
	parent DurationObservable
	mapper MappingDuration2Uint8FuncFactory
}

func (f *MappingDuration2Uint8Observable) Subscribe(observer Uint8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2Uint8Observable(parent DurationObservable, mapper MappingDuration2Uint8FuncFactory) Uint8Observable {
	return &MappingDuration2Uint8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2Uint8ObserveDirect(parent DurationObservable, mapper MappingDuration2Uint8Func) Uint8Observable {
	return MapDuration2Uint8Observable(parent, func(Uint8Observer) MappingDuration2Uint8Func {
		return mapper
	})
}

func MapDuration2Uint8ObserveNext(parent DurationObservable, mapper func(time.Duration) uint8) Uint8Observable {
	return MapDuration2Uint8Observable(parent, func(Uint8Observer) MappingDuration2Uint8Func {
		return func(next time.Duration, err error, complete bool, observer Uint8Observer) {
			var mapped uint8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Uint8 struct {
	parent DurationObservable
	mapper func(time.Duration) Uint8Observable
}

func (f *flatMapDuration2Uint8) Subscribe(observer Uint8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint8Stream{ignoreCompletionFilter().Uint8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint8 maps this stream to an Uint8Stream via f.
func (s *DurationStream) MapUint8(f func(time.Duration) uint8) *Uint8Stream {
	return FromUint8Observable(MapDuration2Uint8ObserveNext(s, f))
}

func (s *DurationStream) FlatMapUint8(f func(time.Duration) Uint8Observable) *Uint8Stream {
	return &Uint8Stream{&flatMapDuration2Uint8{s, f}}
}

type MappingDuration2Int8Func func(next time.Duration, err error, complete bool, observer Int8Observer)
type MappingDuration2Int8FuncFactory func(observer Int8Observer) MappingDuration2Int8Func

type MappingDuration2Int8Observable struct {
	parent DurationObservable
	mapper MappingDuration2Int8FuncFactory
}

func (f *MappingDuration2Int8Observable) Subscribe(observer Int8Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2Int8Observable(parent DurationObservable, mapper MappingDuration2Int8FuncFactory) Int8Observable {
	return &MappingDuration2Int8Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2Int8ObserveDirect(parent DurationObservable, mapper MappingDuration2Int8Func) Int8Observable {
	return MapDuration2Int8Observable(parent, func(Int8Observer) MappingDuration2Int8Func {
		return mapper
	})
}

func MapDuration2Int8ObserveNext(parent DurationObservable, mapper func(time.Duration) int8) Int8Observable {
	return MapDuration2Int8Observable(parent, func(Int8Observer) MappingDuration2Int8Func {
		return func(next time.Duration, err error, complete bool, observer Int8Observer) {
			var mapped int8
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt8(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Int8 struct {
	parent DurationObservable
	mapper func(time.Duration) Int8Observable
}

func (f *flatMapDuration2Int8) Subscribe(observer Int8Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int8Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int8Stream{ignoreCompletionFilter().Int8(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt8 maps this stream to an Int8Stream via f.
func (s *DurationStream) MapInt8(f func(time.Duration) int8) *Int8Stream {
	return FromInt8Observable(MapDuration2Int8ObserveNext(s, f))
}

func (s *DurationStream) FlatMapInt8(f func(time.Duration) Int8Observable) *Int8Stream {
	return &Int8Stream{&flatMapDuration2Int8{s, f}}
}

type MappingDuration2Uint16Func func(next time.Duration, err error, complete bool, observer Uint16Observer)
type MappingDuration2Uint16FuncFactory func(observer Uint16Observer) MappingDuration2Uint16Func

type MappingDuration2Uint16Observable struct {
	parent DurationObservable
	mapper MappingDuration2Uint16FuncFactory
}

func (f *MappingDuration2Uint16Observable) Subscribe(observer Uint16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2Uint16Observable(parent DurationObservable, mapper MappingDuration2Uint16FuncFactory) Uint16Observable {
	return &MappingDuration2Uint16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2Uint16ObserveDirect(parent DurationObservable, mapper MappingDuration2Uint16Func) Uint16Observable {
	return MapDuration2Uint16Observable(parent, func(Uint16Observer) MappingDuration2Uint16Func {
		return mapper
	})
}

func MapDuration2Uint16ObserveNext(parent DurationObservable, mapper func(time.Duration) uint16) Uint16Observable {
	return MapDuration2Uint16Observable(parent, func(Uint16Observer) MappingDuration2Uint16Func {
		return func(next time.Duration, err error, complete bool, observer Uint16Observer) {
			var mapped uint16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Uint16 struct {
	parent DurationObservable
	mapper func(time.Duration) Uint16Observable
}

func (f *flatMapDuration2Uint16) Subscribe(observer Uint16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint16Stream{ignoreCompletionFilter().Uint16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint16 maps this stream to an Uint16Stream via f.
func (s *DurationStream) MapUint16(f func(time.Duration) uint16) *Uint16Stream {
	return FromUint16Observable(MapDuration2Uint16ObserveNext(s, f))
}

func (s *DurationStream) FlatMapUint16(f func(time.Duration) Uint16Observable) *Uint16Stream {
	return &Uint16Stream{&flatMapDuration2Uint16{s, f}}
}

type MappingDuration2Int16Func func(next time.Duration, err error, complete bool, observer Int16Observer)
type MappingDuration2Int16FuncFactory func(observer Int16Observer) MappingDuration2Int16Func

type MappingDuration2Int16Observable struct {
	parent DurationObservable
	mapper MappingDuration2Int16FuncFactory
}

func (f *MappingDuration2Int16Observable) Subscribe(observer Int16Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2Int16Observable(parent DurationObservable, mapper MappingDuration2Int16FuncFactory) Int16Observable {
	return &MappingDuration2Int16Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2Int16ObserveDirect(parent DurationObservable, mapper MappingDuration2Int16Func) Int16Observable {
	return MapDuration2Int16Observable(parent, func(Int16Observer) MappingDuration2Int16Func {
		return mapper
	})
}

func MapDuration2Int16ObserveNext(parent DurationObservable, mapper func(time.Duration) int16) Int16Observable {
	return MapDuration2Int16Observable(parent, func(Int16Observer) MappingDuration2Int16Func {
		return func(next time.Duration, err error, complete bool, observer Int16Observer) {
			var mapped int16
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt16(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Int16 struct {
	parent DurationObservable
	mapper func(time.Duration) Int16Observable
}

func (f *flatMapDuration2Int16) Subscribe(observer Int16Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int16Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int16Stream{ignoreCompletionFilter().Int16(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt16 maps this stream to an Int16Stream via f.
func (s *DurationStream) MapInt16(f func(time.Duration) int16) *Int16Stream {
	return FromInt16Observable(MapDuration2Int16ObserveNext(s, f))
}

func (s *DurationStream) FlatMapInt16(f func(time.Duration) Int16Observable) *Int16Stream {
	return &Int16Stream{&flatMapDuration2Int16{s, f}}
}

type MappingDuration2Uint32Func func(next time.Duration, err error, complete bool, observer Uint32Observer)
type MappingDuration2Uint32FuncFactory func(observer Uint32Observer) MappingDuration2Uint32Func

type MappingDuration2Uint32Observable struct {
	parent DurationObservable
	mapper MappingDuration2Uint32FuncFactory
}

func (f *MappingDuration2Uint32Observable) Subscribe(observer Uint32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2Uint32Observable(parent DurationObservable, mapper MappingDuration2Uint32FuncFactory) Uint32Observable {
	return &MappingDuration2Uint32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2Uint32ObserveDirect(parent DurationObservable, mapper MappingDuration2Uint32Func) Uint32Observable {
	return MapDuration2Uint32Observable(parent, func(Uint32Observer) MappingDuration2Uint32Func {
		return mapper
	})
}

func MapDuration2Uint32ObserveNext(parent DurationObservable, mapper func(time.Duration) uint32) Uint32Observable {
	return MapDuration2Uint32Observable(parent, func(Uint32Observer) MappingDuration2Uint32Func {
		return func(next time.Duration, err error, complete bool, observer Uint32Observer) {
			var mapped uint32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Uint32 struct {
	parent DurationObservable
	mapper func(time.Duration) Uint32Observable
}

func (f *flatMapDuration2Uint32) Subscribe(observer Uint32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint32Stream{ignoreCompletionFilter().Uint32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint32 maps this stream to an Uint32Stream via f.
func (s *DurationStream) MapUint32(f func(time.Duration) uint32) *Uint32Stream {
	return FromUint32Observable(MapDuration2Uint32ObserveNext(s, f))
}

func (s *DurationStream) FlatMapUint32(f func(time.Duration) Uint32Observable) *Uint32Stream {
	return &Uint32Stream{&flatMapDuration2Uint32{s, f}}
}

type MappingDuration2Int32Func func(next time.Duration, err error, complete bool, observer Int32Observer)
type MappingDuration2Int32FuncFactory func(observer Int32Observer) MappingDuration2Int32Func

type MappingDuration2Int32Observable struct {
	parent DurationObservable
	mapper MappingDuration2Int32FuncFactory
}

func (f *MappingDuration2Int32Observable) Subscribe(observer Int32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2Int32Observable(parent DurationObservable, mapper MappingDuration2Int32FuncFactory) Int32Observable {
	return &MappingDuration2Int32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2Int32ObserveDirect(parent DurationObservable, mapper MappingDuration2Int32Func) Int32Observable {
	return MapDuration2Int32Observable(parent, func(Int32Observer) MappingDuration2Int32Func {
		return mapper
	})
}

func MapDuration2Int32ObserveNext(parent DurationObservable, mapper func(time.Duration) int32) Int32Observable {
	return MapDuration2Int32Observable(parent, func(Int32Observer) MappingDuration2Int32Func {
		return func(next time.Duration, err error, complete bool, observer Int32Observer) {
			var mapped int32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Int32 struct {
	parent DurationObservable
	mapper func(time.Duration) Int32Observable
}

func (f *flatMapDuration2Int32) Subscribe(observer Int32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int32Stream{ignoreCompletionFilter().Int32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt32 maps this stream to an Int32Stream via f.
func (s *DurationStream) MapInt32(f func(time.Duration) int32) *Int32Stream {
	return FromInt32Observable(MapDuration2Int32ObserveNext(s, f))
}

func (s *DurationStream) FlatMapInt32(f func(time.Duration) Int32Observable) *Int32Stream {
	return &Int32Stream{&flatMapDuration2Int32{s, f}}
}

type MappingDuration2Uint64Func func(next time.Duration, err error, complete bool, observer Uint64Observer)
type MappingDuration2Uint64FuncFactory func(observer Uint64Observer) MappingDuration2Uint64Func

type MappingDuration2Uint64Observable struct {
	parent DurationObservable
	mapper MappingDuration2Uint64FuncFactory
}

func (f *MappingDuration2Uint64Observable) Subscribe(observer Uint64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2Uint64Observable(parent DurationObservable, mapper MappingDuration2Uint64FuncFactory) Uint64Observable {
	return &MappingDuration2Uint64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2Uint64ObserveDirect(parent DurationObservable, mapper MappingDuration2Uint64Func) Uint64Observable {
	return MapDuration2Uint64Observable(parent, func(Uint64Observer) MappingDuration2Uint64Func {
		return mapper
	})
}

func MapDuration2Uint64ObserveNext(parent DurationObservable, mapper func(time.Duration) uint64) Uint64Observable {
	return MapDuration2Uint64Observable(parent, func(Uint64Observer) MappingDuration2Uint64Func {
		return func(next time.Duration, err error, complete bool, observer Uint64Observer) {
			var mapped uint64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughUint64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Uint64 struct {
	parent DurationObservable
	mapper func(time.Duration) Uint64Observable
}

func (f *flatMapDuration2Uint64) Subscribe(observer Uint64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Uint64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Uint64Stream{ignoreCompletionFilter().Uint64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapUint64 maps this stream to an Uint64Stream via f.
func (s *DurationStream) MapUint64(f func(time.Duration) uint64) *Uint64Stream {
	return FromUint64Observable(MapDuration2Uint64ObserveNext(s, f))
}

func (s *DurationStream) FlatMapUint64(f func(time.Duration) Uint64Observable) *Uint64Stream {
	return &Uint64Stream{&flatMapDuration2Uint64{s, f}}
}

type MappingDuration2Int64Func func(next time.Duration, err error, complete bool, observer Int64Observer)
type MappingDuration2Int64FuncFactory func(observer Int64Observer) MappingDuration2Int64Func

type MappingDuration2Int64Observable struct {
	parent DurationObservable
	mapper MappingDuration2Int64FuncFactory
}

func (f *MappingDuration2Int64Observable) Subscribe(observer Int64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2Int64Observable(parent DurationObservable, mapper MappingDuration2Int64FuncFactory) Int64Observable {
	return &MappingDuration2Int64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2Int64ObserveDirect(parent DurationObservable, mapper MappingDuration2Int64Func) Int64Observable {
	return MapDuration2Int64Observable(parent, func(Int64Observer) MappingDuration2Int64Func {
		return mapper
	})
}

func MapDuration2Int64ObserveNext(parent DurationObservable, mapper func(time.Duration) int64) Int64Observable {
	return MapDuration2Int64Observable(parent, func(Int64Observer) MappingDuration2Int64Func {
		return func(next time.Duration, err error, complete bool, observer Int64Observer) {
			var mapped int64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Int64 struct {
	parent DurationObservable
	mapper func(time.Duration) Int64Observable
}

func (f *flatMapDuration2Int64) Subscribe(observer Int64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Int64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Int64Stream{ignoreCompletionFilter().Int64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapInt64 maps this stream to an Int64Stream via f.
func (s *DurationStream) MapInt64(f func(time.Duration) int64) *Int64Stream {
	return FromInt64Observable(MapDuration2Int64ObserveNext(s, f))
}

func (s *DurationStream) FlatMapInt64(f func(time.Duration) Int64Observable) *Int64Stream {
	return &Int64Stream{&flatMapDuration2Int64{s, f}}
}

type MappingDuration2Float32Func func(next time.Duration, err error, complete bool, observer Float32Observer)
type MappingDuration2Float32FuncFactory func(observer Float32Observer) MappingDuration2Float32Func

type MappingDuration2Float32Observable struct {
	parent DurationObservable
	mapper MappingDuration2Float32FuncFactory
}

func (f *MappingDuration2Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2Float32Observable(parent DurationObservable, mapper MappingDuration2Float32FuncFactory) Float32Observable {
	return &MappingDuration2Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2Float32ObserveDirect(parent DurationObservable, mapper MappingDuration2Float32Func) Float32Observable {
	return MapDuration2Float32Observable(parent, func(Float32Observer) MappingDuration2Float32Func {
		return mapper
	})
}

func MapDuration2Float32ObserveNext(parent DurationObservable, mapper func(time.Duration) float32) Float32Observable {
	return MapDuration2Float32Observable(parent, func(Float32Observer) MappingDuration2Float32Func {
		return func(next time.Duration, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Float32 struct {
	parent DurationObservable
	mapper func(time.Duration) Float32Observable
}

func (f *flatMapDuration2Float32) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float32Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float32Stream{ignoreCompletionFilter().Float32(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *DurationStream) MapFloat32(f func(time.Duration) float32) *Float32Stream {
	return FromFloat32Observable(MapDuration2Float32ObserveNext(s, f))
}

func (s *DurationStream) FlatMapFloat32(f func(time.Duration) Float32Observable) *Float32Stream {
	return &Float32Stream{&flatMapDuration2Float32{s, f}}
}

type MappingDuration2Float64Func func(next time.Duration, err error, complete bool, observer Float64Observer)
type MappingDuration2Float64FuncFactory func(observer Float64Observer) MappingDuration2Float64Func

type MappingDuration2Float64Observable struct {
	parent DurationObservable
	mapper MappingDuration2Float64FuncFactory
}

func (f *MappingDuration2Float64Observable) Subscribe(observer Float64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2Float64Observable(parent DurationObservable, mapper MappingDuration2Float64FuncFactory) Float64Observable {
	return &MappingDuration2Float64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2Float64ObserveDirect(parent DurationObservable, mapper MappingDuration2Float64Func) Float64Observable {
	return MapDuration2Float64Observable(parent, func(Float64Observer) MappingDuration2Float64Func {
		return mapper
	})
}

func MapDuration2Float64ObserveNext(parent DurationObservable, mapper func(time.Duration) float64) Float64Observable {
	return MapDuration2Float64Observable(parent, func(Float64Observer) MappingDuration2Float64Func {
		return func(next time.Duration, err error, complete bool, observer Float64Observer) {
			var mapped float64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Float64 struct {
	parent DurationObservable
	mapper func(time.Duration) Float64Observable
}

func (f *flatMapDuration2Float64) Subscribe(observer Float64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Float64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Float64Stream{ignoreCompletionFilter().Float64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapFloat64 maps this stream to an Float64Stream via f.
func (s *DurationStream) MapFloat64(f func(time.Duration) float64) *Float64Stream {
	return FromFloat64Observable(MapDuration2Float64ObserveNext(s, f))
}

func (s *DurationStream) FlatMapFloat64(f func(time.Duration) Float64Observable) *Float64Stream {
	return &Float64Stream{&flatMapDuration2Float64{s, f}}
}

type MappingDuration2Complex64Func func(next time.Duration, err error, complete bool, observer Complex64Observer)
type MappingDuration2Complex64FuncFactory func(observer Complex64Observer) MappingDuration2Complex64Func

type MappingDuration2Complex64Observable struct {
	parent DurationObservable
	mapper MappingDuration2Complex64FuncFactory
}

func (f *MappingDuration2Complex64Observable) Subscribe(observer Complex64Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2Complex64Observable(parent DurationObservable, mapper MappingDuration2Complex64FuncFactory) Complex64Observable {
	return &MappingDuration2Complex64Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2Complex64ObserveDirect(parent DurationObservable, mapper MappingDuration2Complex64Func) Complex64Observable {
	return MapDuration2Complex64Observable(parent, func(Complex64Observer) MappingDuration2Complex64Func {
		return mapper
	})
}

func MapDuration2Complex64ObserveNext(parent DurationObservable, mapper func(time.Duration) complex64) Complex64Observable {
	return MapDuration2Complex64Observable(parent, func(Complex64Observer) MappingDuration2Complex64Func {
		return func(next time.Duration, err error, complete bool, observer Complex64Observer) {
			var mapped complex64
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex64(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Complex64 struct {
	parent DurationObservable
	mapper func(time.Duration) Complex64Observable
}

func (f *flatMapDuration2Complex64) Subscribe(observer Complex64Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex64Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex64Stream{ignoreCompletionFilter().Complex64(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex64 maps this stream to an Complex64Stream via f.
func (s *DurationStream) MapComplex64(f func(time.Duration) complex64) *Complex64Stream {
	return FromComplex64Observable(MapDuration2Complex64ObserveNext(s, f))
}

func (s *DurationStream) FlatMapComplex64(f func(time.Duration) Complex64Observable) *Complex64Stream {
	return &Complex64Stream{&flatMapDuration2Complex64{s, f}}
}

type MappingDuration2Complex128Func func(next time.Duration, err error, complete bool, observer Complex128Observer)
type MappingDuration2Complex128FuncFactory func(observer Complex128Observer) MappingDuration2Complex128Func

type MappingDuration2Complex128Observable struct {
	parent DurationObservable
	mapper MappingDuration2Complex128FuncFactory
}

func (f *MappingDuration2Complex128Observable) Subscribe(observer Complex128Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2Complex128Observable(parent DurationObservable, mapper MappingDuration2Complex128FuncFactory) Complex128Observable {
	return &MappingDuration2Complex128Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2Complex128ObserveDirect(parent DurationObservable, mapper MappingDuration2Complex128Func) Complex128Observable {
	return MapDuration2Complex128Observable(parent, func(Complex128Observer) MappingDuration2Complex128Func {
		return mapper
	})
}

func MapDuration2Complex128ObserveNext(parent DurationObservable, mapper func(time.Duration) complex128) Complex128Observable {
	return MapDuration2Complex128Observable(parent, func(Complex128Observer) MappingDuration2Complex128Func {
		return func(next time.Duration, err error, complete bool, observer Complex128Observer) {
			var mapped complex128
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughComplex128(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Complex128 struct {
	parent DurationObservable
	mapper func(time.Duration) Complex128Observable
}

func (f *flatMapDuration2Complex128) Subscribe(observer Complex128Observer) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&Complex128Stream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &Complex128Stream{ignoreCompletionFilter().Complex128(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapComplex128 maps this stream to an Complex128Stream via f.
func (s *DurationStream) MapComplex128(f func(time.Duration) complex128) *Complex128Stream {
	return FromComplex128Observable(MapDuration2Complex128ObserveNext(s, f))
}

func (s *DurationStream) FlatMapComplex128(f func(time.Duration) Complex128Observable) *Complex128Stream {
	return &Complex128Stream{&flatMapDuration2Complex128{s, f}}
}

type MappingDuration2TimeFunc func(next time.Duration, err error, complete bool, observer TimeObserver)
type MappingDuration2TimeFuncFactory func(observer TimeObserver) MappingDuration2TimeFunc

type MappingDuration2TimeObservable struct {
	parent DurationObservable
	mapper MappingDuration2TimeFuncFactory
}

func (f *MappingDuration2TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2TimeObservable(parent DurationObservable, mapper MappingDuration2TimeFuncFactory) TimeObservable {
	return &MappingDuration2TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2TimeObserveDirect(parent DurationObservable, mapper MappingDuration2TimeFunc) TimeObservable {
	return MapDuration2TimeObservable(parent, func(TimeObserver) MappingDuration2TimeFunc {
		return mapper
	})
}

func MapDuration2TimeObserveNext(parent DurationObservable, mapper func(time.Duration) time.Time) TimeObservable {
	return MapDuration2TimeObservable(parent, func(TimeObserver) MappingDuration2TimeFunc {
		return func(next time.Duration, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Time struct {
	parent DurationObservable
	mapper func(time.Duration) TimeObservable
}

func (f *flatMapDuration2Time) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&TimeStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &TimeStream{ignoreCompletionFilter().Time(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// MapTime maps this stream to an TimeStream via f.
func (s *DurationStream) MapTime(f func(time.Duration) time.Time) *TimeStream {
	return FromTimeObservable(MapDuration2TimeObserveNext(s, f))
}

func (s *DurationStream) FlatMapTime(f func(time.Duration) TimeObservable) *TimeStream {
	return &TimeStream{&flatMapDuration2Time{s, f}}
}

type MappingDuration2DurationFunc func(next time.Duration, err error, complete bool, observer DurationObserver)
type MappingDuration2DurationFuncFactory func(observer DurationObserver) MappingDuration2DurationFunc

type MappingDuration2DurationObservable struct {
	parent DurationObservable
	mapper MappingDuration2DurationFuncFactory
}

func (f *MappingDuration2DurationObservable) Subscribe(observer DurationObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

func MapDuration2DurationObservable(parent DurationObservable, mapper MappingDuration2DurationFuncFactory) DurationObservable {
	return &MappingDuration2DurationObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapDuration2DurationObserveDirect(parent DurationObservable, mapper MappingDuration2DurationFunc) DurationObservable {
	return MapDuration2DurationObservable(parent, func(DurationObserver) MappingDuration2DurationFunc {
		return mapper
	})
}

func MapDuration2DurationObserveNext(parent DurationObservable, mapper func(time.Duration) time.Duration) DurationObservable {
	return MapDuration2DurationObservable(parent, func(DurationObserver) MappingDuration2DurationFunc {
		return func(next time.Duration, err error, complete bool, observer DurationObserver) {
			var mapped time.Duration
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughDuration(mapped, err, complete, observer)
		}
	},
	)
}

type flatMapDuration2Duration struct {
	parent DurationObservable
	mapper func(time.Duration) DurationObservable
}

func (f *flatMapDuration2Duration) Subscribe(observer DurationObserver) Subscription {
	subscription := NewGenericSubscription()
	wg := sync.WaitGroup{}
	f.parent.Subscribe(DurationObserverFunc(func(next time.Duration, err error, complete bool) {
		switch {
		case err != nil:
			wg.Wait()
			observer.Error(err)
		case complete:
			wg.Wait()
			observer.Complete()
		default:
			wg.Add(1)
			observable := f.mapper(next)
			stream := (&DurationStream{observable}).
				DoOnComplete(func() { wg.Done() }).
				DoOnError(func(error) { wg.Done() })
			stream = &DurationStream{ignoreCompletionFilter().Duration(stream)}
			stream.Subscribe(observer)
		}
	}))
	return subscription
}

// Map maps values in this stream to another value.
func (s *DurationStream) Map(f func(time.Duration) time.Duration) *DurationStream {
	return FromDurationObservable(MapDuration2DurationObserveNext(s, f))
}

func (s *DurationStream) FlatMap(f func(time.Duration) DurationObservable) *DurationStream {
	return &DurationStream{&flatMapDuration2Duration{s, f}}
}
