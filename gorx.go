package gorx

// NOTE: This file was generated by github.com/alecthomas/cmd/gorx. Do not modify.

import (
	"errors"
	"io"
	"sync"
	"sync/atomic"
	"time"
)

// Maximum size of a replay buffer. Can be modified.
var MaxReplaySize = 16384

// A Subscription to an observable.
type Subscription interface {
	// Unsubscribe from the subscription.
	io.Closer
	// Closed returns true if this subscription has been unsubscribed.
	Closed() bool
}

// A Subscription that is already closed.
type closedSubscription struct{}

func (closedSubscription) Close() error { return nil }
func (closedSubscription) Closed() bool { return true }

// ClosedSubscription always returns true for Closed()
var ClosedSubscription Subscription = closedSubscription{}

// A LinkedSubscription is a link to a (possible) future Subscription.
type LinkedSubscription struct {
	lock         sync.Mutex
	unsubscribed bool
	linked       Subscription
}

func NewLinkedSubscription() *LinkedSubscription {
	return &LinkedSubscription{}
}

func (l *LinkedSubscription) Link(subscription Subscription) {
	l.lock.Lock()
	defer l.lock.Unlock()
	if l.linked != nil {
		panic("LinkedSubscription is already linked")
	}
	l.linked = subscription
	if l.unsubscribed {
		l.linked.Close()
	}
}

func (l *LinkedSubscription) Close() error {
	l.lock.Lock()
	defer l.lock.Unlock()
	l.unsubscribed = true
	if l.linked != nil {
		return l.linked.Close()
	}
	return nil
}

func (l *LinkedSubscription) Closed() bool {
	l.lock.Lock()
	defer l.lock.Unlock()
	if l.linked != nil {
		return l.linked.Closed()
	}
	return l.unsubscribed
}

// ChannelSubscription is implemented with a channel which is closed when
// unsubscribed.
type ChannelSubscription chan struct{}

func NewChannelSubscription() Subscription {
	return make(ChannelSubscription)
}

func (c ChannelSubscription) Close() error {
	defer recover()
	close(c)
	return nil
}

func (c ChannelSubscription) Closed() bool {
	select {
	case _, ok := <-c:
		return !ok
	default:
		return false
	}
}

// GenericSubscription is implemented with atomic operations.
type GenericSubscription int32

func NewGenericSubscription() Subscription {
	return new(GenericSubscription)
}

func (t *GenericSubscription) Close() error {
	atomic.StoreInt32((*int32)(t), 1)
	return nil
}

func (t *GenericSubscription) Closed() bool {
	return atomic.LoadInt32((*int32)(t)) == 1
}

// TerminationObserver contains functions for observing termination of a stream.
type TerminationObserver interface {
	Error(error)
	Complete()
}

type GenericObserver interface {
	TerminationObserver
	Next(interface{})
}

type GenericObserverFunc struct {
	f func(interface{}, error, bool)
	Subscription
}

func NewGenericObserverFunc(f func(interface{}, error, bool)) *GenericObserverFunc {
	return &GenericObserverFunc{f, NewGenericSubscription()}
}

func (f *GenericObserverFunc) Next(next interface{}) { f.f(next, nil, false) }
func (f *GenericObserverFunc) Error(err error)       { f.f(nil, err, false) }
func (f *GenericObserverFunc) Complete()             { f.f(nil, nil, true) }

type GenericObservableFilter func(next interface{}, err error, complete bool, observer GenericObserver)

// Turtles all the way down!
type GenericObservableFilterFactory func(GenericObserver) GenericObservableFilter

func distinctFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		seen := map[interface{}]struct{}{}
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if _, ok := seen[next]; ok {
					return
				}
				seen[next] = struct{}{}
				observer.Next(next)
			}
		}
	}
}

func elementAtFilter(n int) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		i := 0
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if i == n {
					observer.Next(next)
				}
				i++
			}
		}
	}
}

func filterFilter(f func(next interface{}) bool) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if f(next) {
					observer.Next(next)
				}
			}
		}
	}
}

func firstFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		start := true
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if start {
					observer.Next(next)
				}
				start = false
			}
		}
	}
}

func lastFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		have := false
		var last interface{}
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				if have {
					observer.Next(last)
				}
				observer.Error(err)
			case complete:
				if have {
					observer.Next(last)
				}
				observer.Complete()
			default:
				last = next
				have = true
			}
		}
	}
}

func takeLastFilter(n int) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		read := 0
		write := 0
		n++
		buffer := make([]interface{}, n)
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				for read != write {
					observer.Next(buffer[read])
					read = (read + 1) % n
				}
				observer.Error(err)
			case complete:
				for read != write {
					observer.Next(buffer[read])
					read = (read + 1) % n
				}
				observer.Complete()
			default:
				buffer[write] = next
				write = (write + 1) % n
				if write == read {
					read = (read + 1) % n
				}
			}
		}
	}
}

func takeFilter(n int) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		taken := 0
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			if taken >= n {
				return
			}
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				observer.Next(next)
				taken++
				if taken >= n {
					observer.Complete()
				}
			}
		}
	}
}

func ignoreElementsFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			}
		}
	}
}

func skipFilter(n int) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		i := 0
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if i >= n {
					observer.Next(next)
				}
				i++
			}
		}
	}
}

func skipLastFilter(n int) GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		read := 0
		write := 0
		n++
		buffer := make([]interface{}, n)
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				buffer[write] = next
				write = (write + 1) % n
				if write == read {
					observer.Next(buffer[read])
					read = (read + 1) % n
				}
			}
		}
	}
}

func oneFilter() GenericObservableFilterFactory {
	return func(GenericObserver) GenericObservableFilter {
		count := 0
		var value interface{}
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			if count > 1 {
				return
			}
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				if count == 2 {
					observer.Error(errors.New("expected one value"))
				} else {
					observer.Next(value)
					observer.Complete()
				}
			default:
				count++
				if count == 2 {
					observer.Error(errors.New("expected one value"))
					return
				}
				value = next
			}
		}
	}
}

func sampleFilter(window time.Duration) GenericObservableFilterFactory {
	return func(observer GenericObserver) GenericObservableFilter {
		mutex := &sync.Mutex{}
		cancel := make(chan bool, 1)
		var last interface{}
		haveNew := false
		go func() {
			for {
				select {
				case <-time.After(window):
					mutex.Lock()
					if haveNew {
						observer.Next(last)
						haveNew = false
					}
					mutex.Unlock()
				case <-cancel:
					return
				}
			}
		}()
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				cancel <- true
				observer.Error(err)
			case complete:
				cancel <- true
				observer.Complete()
			default:
				mutex.Lock()
				last = next
				haveNew = true
				mutex.Unlock()
			}
		}
	}
}

func debounceFilter(duration time.Duration) GenericObservableFilterFactory {
	return func(observer GenericObserver) GenericObservableFilter {
		errch := make(chan error)
		completech := make(chan bool)
		valuech := make(chan interface{})
		go func() {
			var timeout <-chan time.Time
			var nextValue interface{}
			for {
				select {
				case <-timeout:
					observer.Next(nextValue)
					timeout = nil
				case nextValue = <-valuech:
					timeout = time.After(duration)
				case err := <-errch:
					if timeout != nil {
						observer.Next(nextValue)
					}
					observer.Error(err)
					return
				case <-completech:
					if timeout != nil {
						observer.Next(nextValue)
					}
					observer.Complete()
					return
				}
			}
		}()
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				errch <- err
			case complete:
				completech <- true
			default:
				valuech <- next
			}
		}
	}
}

type timedEntry struct {
	v interface{}
	t time.Time
}

func replayFilter(size int, duration time.Duration) GenericObservableFilterFactory {
	read := 0
	write := 0
	if size == 0 {
		size = MaxReplaySize
	}
	if duration == 0 {
		duration = time.Hour * 24 * 7 * 52
	}
	size++
	buffer := make([]timedEntry, size)
	return func(observer GenericObserver) GenericObservableFilter {
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			now := time.Now()
			switch {
			case err != nil:
				cursor := read
				for cursor != write {
					if buffer[cursor].t.After(now) {
						observer.Next(buffer[cursor].v)
					}
					cursor = (cursor + 1) % size
				}
				observer.Error(err)
			case complete:
				cursor := read
				for cursor != write {
					if buffer[cursor].t.After(now) {
						observer.Next(buffer[cursor].v)
					}
					cursor = (cursor + 1) % size
				}
				observer.Complete()
			default:
				buffer[write] = timedEntry{next, time.Now().Add(duration)}
				write = (write + 1) % size
				if write == read {
					if buffer[read].t.After(now) {
						observer.Next(buffer[read].v)
					}
					read = (read + 1) % size
				}
			}
		}
	}
}

func Range(start, end int) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		for i := start; i < end; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(i)
		}
		observer.Complete()
		subscription.Close()
	})
}

func Interval(interval time.Duration) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		i := 0
		for {
			time.Sleep(interval)
			if subscription.Closed() {
				return
			}
			observer.Next(i)
			i++
		}
	})
}

type IntObserver interface {
	Next(int)
	TerminationObserver
}

// A IntSubscriber represents a subscribed IntObserver.
type IntSubscriber interface {
	Subscription
	IntObserver
}

type implIntSubscriber struct {
	Subscription
	IntObserver
}

func IntObserverAsGenericObserver(observer IntObserver) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(int))
		}
	})
}

func GenericObserverAsIntObserver(observer GenericObserver) IntObserver {
	return NewIntObserverFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type IntObservableFactory func(observer IntObserver, subscription Subscription)

func (f IntObservableFactory) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateInt calls f(observer, subscription) to produce values for a stream.
func CreateInt(f func(observer IntObserver, subscription Subscription)) *IntStream {
	return FromIntObservable(IntObservableFactory(f))
}

// Repeat value count times.
func RepeatInt(value int, count int) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartInt is designed to be used with functions that return a
// (int, error) tuple.
//
// If the error is non-nil the returned IntStream will be that error,
// otherwise it will be a single-value stream of int.
func StartInt(f func() (int, error)) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughInt(next int, err error, complete bool, observer IntObserver) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

type IntObserverFunc func(int, error, bool)

var zeroInt = *new(int)

func NewIntObserverFunc(f func(int, error, bool)) IntObserverFunc {
	return f
}

func (f IntObserverFunc) Next(next int)   { f(next, nil, false) }
func (f IntObserverFunc) Error(err error) { f(zeroInt, err, false) }
func (f IntObserverFunc) Complete()       { f(zeroInt, nil, true) }

type IntObservable interface {
	Subscribe(IntObserver) Subscription
}

// Convert a GenericObservableFilter to a IntObservable
func (f GenericObservableFilterFactory) Int(parent IntObservable) IntObservable {
	return MapInt2IntObservable(parent, func(observer IntObserver) MappingInt2IntFunc {
		gobserver := IntObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next int, err error, complete bool, observer IntObserver) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverInt() *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {})
}

func EmptyInt() *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowInt(err error) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		observer.Error(err)
	})
}

func FromIntArray(array []int) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromInts(array ...int) *IntStream {
	return FromIntArray(array)
}

func JustInt(element int) *IntStream {
	return FromIntArray([]int{element})
}

func MergeInt(observables ...IntObservable) *IntStream {
	if len(observables) == 0 {
		return EmptyInt()
	}
	return (&IntStream{observables[0]}).Merge(observables[1:]...)
}

func MergeIntDelayError(observables ...IntObservable) *IntStream {
	if len(observables) == 0 {
		return EmptyInt()
	}
	return (&IntStream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromIntChannel(ch <-chan int) *IntStream {
	return CreateInt(func(observer IntObserver, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type IntStream struct {
	IntObservable
}

func FromIntObservable(observable IntObservable) *IntStream {
	return &IntStream{observable}
}

func (s *IntStream) SubscribeFunc(f func(int, error, bool)) Subscription {
	return s.Subscribe(NewIntObserverFunc(f))
}

func (s *IntStream) SubscribeNext(f func(v int)) Subscription {
	return s.SubscribeFunc(func(next int, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *IntStream) Distinct() *IntStream {
	return FromIntObservable(distinctFilter().Int(s))
}

// ElementAt yields the Nth element of the stream.
func (s *IntStream) ElementAt(n int) *IntStream {
	return FromIntObservable(elementAtFilter(n).Int(s))
}

// Filter elements in the stream on a function.
func (s *IntStream) Filter(f func(int) bool) *IntStream {
	return FromIntObservable(filterFilter(func(v interface{}) bool { return f(v.(int)) }).Int(s))
}

// Last returns just the first element of the stream.
func (s *IntStream) First() *IntStream {
	return FromIntObservable(firstFilter().Int(s))
}

// Last returns just the last element of the stream.
func (s *IntStream) Last() *IntStream {
	return FromIntObservable(lastFilter().Int(s))
}

// SkipLast skips the first N elements of the stream.
func (s *IntStream) Skip(n int) *IntStream {
	return FromIntObservable(skipFilter(n).Int(s))
}

// SkipLast skips the last N elements of the stream.
func (s *IntStream) SkipLast(n int) *IntStream {
	return FromIntObservable(skipLastFilter(n).Int(s))
}

// Take returns just the first N elements of the stream.
func (s *IntStream) Take(n int) *IntStream {
	return FromIntObservable(takeFilter(n).Int(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *IntStream) TakeLast(n int) *IntStream {
	return FromIntObservable(takeLastFilter(n).Int(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *IntStream) IgnoreElements() *IntStream {
	return FromIntObservable(ignoreElementsFilter().Int(s))
}

func (s *IntStream) Replay(size int, duration time.Duration) *IntStream {
	return FromIntObservable(replayFilter(size, duration).Int(s))
}

func (s *IntStream) Sample(duration time.Duration) *IntStream {
	return FromIntObservable(sampleFilter(duration).Int(s))
}

func (s *IntStream) Debounce(duration time.Duration) *IntStream {
	return FromIntObservable(debounceFilter(duration).Int(s))
}

// Wait for completion of the stream and return any error.
func (s *IntStream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeIntSubscriber(observer IntObserver) IntSubscriber {
	if subscriber, ok := observer.(IntSubscriber); ok {
		return subscriber
	}
	return &implIntSubscriber{NewGenericSubscription(), observer}
}

type concatIntSubscriber struct {
	observable  int
	observer    IntObserver
	observables []IntObservable
	Subscription
}

func (c *concatIntSubscriber) Next(next int) {
	c.observer.Next(next)
}

func (c *concatIntSubscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatIntSubscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatIntObservable struct {
	observables []IntObservable
}

func (m *concatIntObservable) Subscribe(observer IntObserver) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatIntSubscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *IntStream) Concat(observables ...IntObservable) *IntStream {
	return &IntStream{&concatIntObservable{append([]IntObservable{s}, observables...)}}
}

type mergeIntObservable struct {
	delayError  bool
	observables []IntObservable
}

func (m *mergeIntObservable) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next int, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(NewIntObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *IntStream) Merge(other ...IntObservable) *IntStream {
	if len(other) == 0 {
		return s
	}
	return &IntStream{&mergeIntObservable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *IntStream) MergeDelayError(other ...IntObservable) *IntStream {
	if len(other) == 0 {
		return s
	}
	return &IntStream{&mergeIntObservable{true, append(other, s)}}
}

type catchIntObservable struct {
	parent IntObservable
	catch  IntObservable
}

func (r *catchIntObservable) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	run := func(next int, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(NewIntObserverFunc(run))
	return subscription
}

func (s *IntStream) Catch(catch IntObservable) *IntStream {
	return &IntStream{&catchIntObservable{s, catch}}
}

type retryIntObservable struct {
	observable IntObservable
}

type retryIntObserver struct {
	observable IntObservable
	observer   IntObserver
}

func (r *retryIntObserver) retry(next int, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(NewIntObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryIntObservable) Subscribe(observer IntObserver) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryIntObserver{r.observable, observer}
	r.observable.Subscribe(NewIntObserverFunc(ro.retry))
	return subscription
}

func (s *IntStream) Retry() *IntStream {
	return &IntStream{&retryIntObservable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *IntStream) Do(f func(next int)) *IntStream {
	return FromIntObservable(MapInt2IntObserveNext(s, func(next int) int {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *IntStream) DoOnError(f func(err error)) *IntStream {
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		if err != nil {
			f(err)
		}
		PassthroughInt(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *IntStream) DoOnComplete(f func()) *IntStream {
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		if complete {
			f()
		}
		PassthroughInt(next, err, complete, observer)
	}))
}

func (s *IntStream) Reduce(initial int, reducer func(int, int) int) *IntStream {
	value := initial
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *IntStream) Scan(initial int, f func(int, int) int) *IntStream {
	value := initial
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *IntStream) ToOneWithError() (int, error) {
	valuech := make(chan int, 1)
	errch := make(chan error, 1)
	FromIntObservable(oneFilter().Int(s)).SubscribeFunc(func(next int, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroInt, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *IntStream) ToOne() int {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *IntStream) ToArrayWithError() ([]int, error) {
	array := []int{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *IntStream) ToArray() []int {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *IntStream) ToChannelWithError() (<-chan int, <-chan error) {
	ch := make(chan int, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next int, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *IntStream) ToChannel() <-chan int {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *IntStream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

func (s *IntStream) Average() *IntStream {
	var sum int
	var count int
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(sum / count)
			observer.Error(err)
		case complete:
			observer.Next(sum / count)
			observer.Complete()
		default:
			sum += next
			count++
		}
	}))
}

func (s *IntStream) Sum() *IntStream {
	var sum int
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(sum)
			observer.Error(err)
		case complete:
			observer.Next(sum)
			observer.Complete()
		default:
			sum += next
		}
	}))
}

func (s *IntStream) Min() *IntStream {
	started := false
	var min int
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			if started {
				observer.Next(min)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(min)
			}
			observer.Complete()
		default:
			if started {
				if min > next {
					min = next
				}
			} else {
				min = next
				started = true
			}
		}
	}))
}

func (s *IntStream) Max() *IntStream {
	started := false
	var max int
	return FromIntObservable(MapInt2IntObserveDirect(s, func(next int, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			if started {
				observer.Next(max)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(max)
			}
			observer.Complete()
		default:
			if started {
				if max <= next {
					max = next
				}
			} else {
				max = next
				started = true
			}
		}
	}))
}

type MappingInt2IntFunc func(next int, err error, complete bool, observer IntObserver)
type MappingInt2IntFuncFactory func(observer IntObserver) MappingInt2IntFunc

type MappingInt2IntObservable struct {
	parent IntObservable
	mapper MappingInt2IntFuncFactory
}

func MapInt2IntObservable(parent IntObservable, mapper MappingInt2IntFuncFactory) IntObservable {
	return &MappingInt2IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2IntObserveDirect(parent IntObservable, mapper MappingInt2IntFunc) IntObservable {
	return MapInt2IntObservable(parent, func(IntObserver) MappingInt2IntFunc {
		return mapper
	})
}

func MapInt2IntObserveNext(parent IntObservable, mapper func(int) int) IntObservable {
	return MapInt2IntObservable(parent, func(IntObserver) MappingInt2IntFunc {
		return func(next int, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingInt2IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(NewIntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

type MappingInt2StringFunc func(next int, err error, complete bool, observer StringObserver)
type MappingInt2StringFuncFactory func(observer StringObserver) MappingInt2StringFunc

type MappingInt2StringObservable struct {
	parent IntObservable
	mapper MappingInt2StringFuncFactory
}

func MapInt2StringObservable(parent IntObservable, mapper MappingInt2StringFuncFactory) StringObservable {
	return &MappingInt2StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2StringObserveDirect(parent IntObservable, mapper MappingInt2StringFunc) StringObservable {
	return MapInt2StringObservable(parent, func(StringObserver) MappingInt2StringFunc {
		return mapper
	})
}

func MapInt2StringObserveNext(parent IntObservable, mapper func(int) string) StringObservable {
	return MapInt2StringObservable(parent, func(StringObserver) MappingInt2StringFunc {
		return func(next int, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingInt2StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(NewIntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

// MapString maps this stream to an StringStream via f.
func (s *IntStream) MapString(f func(int) string) *StringStream {
	return FromStringObservable(MapInt2StringObserveNext(s, f))
}

type MappingInt2Float32Func func(next int, err error, complete bool, observer Float32Observer)
type MappingInt2Float32FuncFactory func(observer Float32Observer) MappingInt2Float32Func

type MappingInt2Float32Observable struct {
	parent IntObservable
	mapper MappingInt2Float32FuncFactory
}

func MapInt2Float32Observable(parent IntObservable, mapper MappingInt2Float32FuncFactory) Float32Observable {
	return &MappingInt2Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2Float32ObserveDirect(parent IntObservable, mapper MappingInt2Float32Func) Float32Observable {
	return MapInt2Float32Observable(parent, func(Float32Observer) MappingInt2Float32Func {
		return mapper
	})
}

func MapInt2Float32ObserveNext(parent IntObservable, mapper func(int) float32) Float32Observable {
	return MapInt2Float32Observable(parent, func(Float32Observer) MappingInt2Float32Func {
		return func(next int, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingInt2Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(NewIntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *IntStream) MapFloat32(f func(int) float32) *Float32Stream {
	return FromFloat32Observable(MapInt2Float32ObserveNext(s, f))
}

type MappingInt2TimeFunc func(next int, err error, complete bool, observer TimeObserver)
type MappingInt2TimeFuncFactory func(observer TimeObserver) MappingInt2TimeFunc

type MappingInt2TimeObservable struct {
	parent IntObservable
	mapper MappingInt2TimeFuncFactory
}

func MapInt2TimeObservable(parent IntObservable, mapper MappingInt2TimeFuncFactory) TimeObservable {
	return &MappingInt2TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapInt2TimeObserveDirect(parent IntObservable, mapper MappingInt2TimeFunc) TimeObservable {
	return MapInt2TimeObservable(parent, func(TimeObserver) MappingInt2TimeFunc {
		return mapper
	})
}

func MapInt2TimeObserveNext(parent IntObservable, mapper func(int) time.Time) TimeObservable {
	return MapInt2TimeObservable(parent, func(TimeObserver) MappingInt2TimeFunc {
		return func(next int, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingInt2TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(NewIntObserverFunc(func(next int, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

// MapTime maps this stream to an TimeStream via f.
func (s *IntStream) MapTime(f func(int) time.Time) *TimeStream {
	return FromTimeObservable(MapInt2TimeObserveNext(s, f))
}

type StringObserver interface {
	Next(string)
	TerminationObserver
}

// A StringSubscriber represents a subscribed StringObserver.
type StringSubscriber interface {
	Subscription
	StringObserver
}

type implStringSubscriber struct {
	Subscription
	StringObserver
}

func StringObserverAsGenericObserver(observer StringObserver) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(string))
		}
	})
}

func GenericObserverAsStringObserver(observer GenericObserver) StringObserver {
	return NewStringObserverFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type StringObservableFactory func(observer StringObserver, subscription Subscription)

func (f StringObservableFactory) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateString calls f(observer, subscription) to produce values for a stream.
func CreateString(f func(observer StringObserver, subscription Subscription)) *StringStream {
	return FromStringObservable(StringObservableFactory(f))
}

// Repeat value count times.
func RepeatString(value string, count int) *StringStream {
	return CreateString(func(observer StringObserver, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartString is designed to be used with functions that return a
// (string, error) tuple.
//
// If the error is non-nil the returned StringStream will be that error,
// otherwise it will be a single-value stream of string.
func StartString(f func() (string, error)) *StringStream {
	return CreateString(func(observer StringObserver, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughString(next string, err error, complete bool, observer StringObserver) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

type StringObserverFunc func(string, error, bool)

var zeroString = *new(string)

func NewStringObserverFunc(f func(string, error, bool)) StringObserverFunc {
	return f
}

func (f StringObserverFunc) Next(next string) { f(next, nil, false) }
func (f StringObserverFunc) Error(err error)  { f(zeroString, err, false) }
func (f StringObserverFunc) Complete()        { f(zeroString, nil, true) }

type StringObservable interface {
	Subscribe(StringObserver) Subscription
}

// Convert a GenericObservableFilter to a StringObservable
func (f GenericObservableFilterFactory) String(parent StringObservable) StringObservable {
	return MapString2StringObservable(parent, func(observer StringObserver) MappingString2StringFunc {
		gobserver := StringObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next string, err error, complete bool, observer StringObserver) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverString() *StringStream {
	return CreateString(func(observer StringObserver, subscription Subscription) {})
}

func EmptyString() *StringStream {
	return CreateString(func(observer StringObserver, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowString(err error) *StringStream {
	return CreateString(func(observer StringObserver, subscription Subscription) {
		observer.Error(err)
	})
}

func FromStringArray(array []string) *StringStream {
	return CreateString(func(observer StringObserver, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromStrings(array ...string) *StringStream {
	return FromStringArray(array)
}

func JustString(element string) *StringStream {
	return FromStringArray([]string{element})
}

func MergeString(observables ...StringObservable) *StringStream {
	if len(observables) == 0 {
		return EmptyString()
	}
	return (&StringStream{observables[0]}).Merge(observables[1:]...)
}

func MergeStringDelayError(observables ...StringObservable) *StringStream {
	if len(observables) == 0 {
		return EmptyString()
	}
	return (&StringStream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromStringChannel(ch <-chan string) *StringStream {
	return CreateString(func(observer StringObserver, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type StringStream struct {
	StringObservable
}

func FromStringObservable(observable StringObservable) *StringStream {
	return &StringStream{observable}
}

func (s *StringStream) SubscribeFunc(f func(string, error, bool)) Subscription {
	return s.Subscribe(NewStringObserverFunc(f))
}

func (s *StringStream) SubscribeNext(f func(v string)) Subscription {
	return s.SubscribeFunc(func(next string, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *StringStream) Distinct() *StringStream {
	return FromStringObservable(distinctFilter().String(s))
}

// ElementAt yields the Nth element of the stream.
func (s *StringStream) ElementAt(n int) *StringStream {
	return FromStringObservable(elementAtFilter(n).String(s))
}

// Filter elements in the stream on a function.
func (s *StringStream) Filter(f func(string) bool) *StringStream {
	return FromStringObservable(filterFilter(func(v interface{}) bool { return f(v.(string)) }).String(s))
}

// Last returns just the first element of the stream.
func (s *StringStream) First() *StringStream {
	return FromStringObservable(firstFilter().String(s))
}

// Last returns just the last element of the stream.
func (s *StringStream) Last() *StringStream {
	return FromStringObservable(lastFilter().String(s))
}

// SkipLast skips the first N elements of the stream.
func (s *StringStream) Skip(n int) *StringStream {
	return FromStringObservable(skipFilter(n).String(s))
}

// SkipLast skips the last N elements of the stream.
func (s *StringStream) SkipLast(n int) *StringStream {
	return FromStringObservable(skipLastFilter(n).String(s))
}

// Take returns just the first N elements of the stream.
func (s *StringStream) Take(n int) *StringStream {
	return FromStringObservable(takeFilter(n).String(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *StringStream) TakeLast(n int) *StringStream {
	return FromStringObservable(takeLastFilter(n).String(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *StringStream) IgnoreElements() *StringStream {
	return FromStringObservable(ignoreElementsFilter().String(s))
}

func (s *StringStream) Replay(size int, duration time.Duration) *StringStream {
	return FromStringObservable(replayFilter(size, duration).String(s))
}

func (s *StringStream) Sample(duration time.Duration) *StringStream {
	return FromStringObservable(sampleFilter(duration).String(s))
}

func (s *StringStream) Debounce(duration time.Duration) *StringStream {
	return FromStringObservable(debounceFilter(duration).String(s))
}

// Wait for completion of the stream and return any error.
func (s *StringStream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeStringSubscriber(observer StringObserver) StringSubscriber {
	if subscriber, ok := observer.(StringSubscriber); ok {
		return subscriber
	}
	return &implStringSubscriber{NewGenericSubscription(), observer}
}

type concatStringSubscriber struct {
	observable  int
	observer    StringObserver
	observables []StringObservable
	Subscription
}

func (c *concatStringSubscriber) Next(next string) {
	c.observer.Next(next)
}

func (c *concatStringSubscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatStringSubscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatStringObservable struct {
	observables []StringObservable
}

func (m *concatStringObservable) Subscribe(observer StringObserver) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatStringSubscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *StringStream) Concat(observables ...StringObservable) *StringStream {
	return &StringStream{&concatStringObservable{append([]StringObservable{s}, observables...)}}
}

type mergeStringObservable struct {
	delayError  bool
	observables []StringObservable
}

func (m *mergeStringObservable) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next string, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(NewStringObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *StringStream) Merge(other ...StringObservable) *StringStream {
	if len(other) == 0 {
		return s
	}
	return &StringStream{&mergeStringObservable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *StringStream) MergeDelayError(other ...StringObservable) *StringStream {
	if len(other) == 0 {
		return s
	}
	return &StringStream{&mergeStringObservable{true, append(other, s)}}
}

type catchStringObservable struct {
	parent StringObservable
	catch  StringObservable
}

func (r *catchStringObservable) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	run := func(next string, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(NewStringObserverFunc(run))
	return subscription
}

func (s *StringStream) Catch(catch StringObservable) *StringStream {
	return &StringStream{&catchStringObservable{s, catch}}
}

type retryStringObservable struct {
	observable StringObservable
}

type retryStringObserver struct {
	observable StringObservable
	observer   StringObserver
}

func (r *retryStringObserver) retry(next string, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(NewStringObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryStringObservable) Subscribe(observer StringObserver) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryStringObserver{r.observable, observer}
	r.observable.Subscribe(NewStringObserverFunc(ro.retry))
	return subscription
}

func (s *StringStream) Retry() *StringStream {
	return &StringStream{&retryStringObservable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *StringStream) Do(f func(next string)) *StringStream {
	return FromStringObservable(MapString2StringObserveNext(s, func(next string) string {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *StringStream) DoOnError(f func(err error)) *StringStream {
	return FromStringObservable(MapString2StringObserveDirect(s, func(next string, err error, complete bool, observer StringObserver) {
		if err != nil {
			f(err)
		}
		PassthroughString(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *StringStream) DoOnComplete(f func()) *StringStream {
	return FromStringObservable(MapString2StringObserveDirect(s, func(next string, err error, complete bool, observer StringObserver) {
		if complete {
			f()
		}
		PassthroughString(next, err, complete, observer)
	}))
}

func (s *StringStream) Reduce(initial string, reducer func(string, string) string) *StringStream {
	value := initial
	return FromStringObservable(MapString2StringObserveDirect(s, func(next string, err error, complete bool, observer StringObserver) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *StringStream) Scan(initial string, f func(string, string) string) *StringStream {
	value := initial
	return FromStringObservable(MapString2StringObserveDirect(s, func(next string, err error, complete bool, observer StringObserver) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *StringStream) ToOneWithError() (string, error) {
	valuech := make(chan string, 1)
	errch := make(chan error, 1)
	FromStringObservable(oneFilter().String(s)).SubscribeFunc(func(next string, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroString, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *StringStream) ToOne() string {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *StringStream) ToArrayWithError() ([]string, error) {
	array := []string{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *StringStream) ToArray() []string {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *StringStream) ToChannelWithError() (<-chan string, <-chan error) {
	ch := make(chan string, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next string, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *StringStream) ToChannel() <-chan string {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *StringStream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapString2IntObserveDirect(s, func(next string, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

type MappingString2IntFunc func(next string, err error, complete bool, observer IntObserver)
type MappingString2IntFuncFactory func(observer IntObserver) MappingString2IntFunc

type MappingString2IntObservable struct {
	parent StringObservable
	mapper MappingString2IntFuncFactory
}

func MapString2IntObservable(parent StringObservable, mapper MappingString2IntFuncFactory) IntObservable {
	return &MappingString2IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2IntObserveDirect(parent StringObservable, mapper MappingString2IntFunc) IntObservable {
	return MapString2IntObservable(parent, func(IntObserver) MappingString2IntFunc {
		return mapper
	})
}

func MapString2IntObserveNext(parent StringObservable, mapper func(string) int) IntObservable {
	return MapString2IntObservable(parent, func(IntObserver) MappingString2IntFunc {
		return func(next string, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingString2IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(NewStringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

// MapInt maps this stream to an IntStream via f.
func (s *StringStream) MapInt(f func(string) int) *IntStream {
	return FromIntObservable(MapString2IntObserveNext(s, f))
}

type MappingString2StringFunc func(next string, err error, complete bool, observer StringObserver)
type MappingString2StringFuncFactory func(observer StringObserver) MappingString2StringFunc

type MappingString2StringObservable struct {
	parent StringObservable
	mapper MappingString2StringFuncFactory
}

func MapString2StringObservable(parent StringObservable, mapper MappingString2StringFuncFactory) StringObservable {
	return &MappingString2StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2StringObserveDirect(parent StringObservable, mapper MappingString2StringFunc) StringObservable {
	return MapString2StringObservable(parent, func(StringObserver) MappingString2StringFunc {
		return mapper
	})
}

func MapString2StringObserveNext(parent StringObservable, mapper func(string) string) StringObservable {
	return MapString2StringObservable(parent, func(StringObserver) MappingString2StringFunc {
		return func(next string, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingString2StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(NewStringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

type MappingString2Float32Func func(next string, err error, complete bool, observer Float32Observer)
type MappingString2Float32FuncFactory func(observer Float32Observer) MappingString2Float32Func

type MappingString2Float32Observable struct {
	parent StringObservable
	mapper MappingString2Float32FuncFactory
}

func MapString2Float32Observable(parent StringObservable, mapper MappingString2Float32FuncFactory) Float32Observable {
	return &MappingString2Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2Float32ObserveDirect(parent StringObservable, mapper MappingString2Float32Func) Float32Observable {
	return MapString2Float32Observable(parent, func(Float32Observer) MappingString2Float32Func {
		return mapper
	})
}

func MapString2Float32ObserveNext(parent StringObservable, mapper func(string) float32) Float32Observable {
	return MapString2Float32Observable(parent, func(Float32Observer) MappingString2Float32Func {
		return func(next string, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingString2Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(NewStringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *StringStream) MapFloat32(f func(string) float32) *Float32Stream {
	return FromFloat32Observable(MapString2Float32ObserveNext(s, f))
}

type MappingString2TimeFunc func(next string, err error, complete bool, observer TimeObserver)
type MappingString2TimeFuncFactory func(observer TimeObserver) MappingString2TimeFunc

type MappingString2TimeObservable struct {
	parent StringObservable
	mapper MappingString2TimeFuncFactory
}

func MapString2TimeObservable(parent StringObservable, mapper MappingString2TimeFuncFactory) TimeObservable {
	return &MappingString2TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapString2TimeObserveDirect(parent StringObservable, mapper MappingString2TimeFunc) TimeObservable {
	return MapString2TimeObservable(parent, func(TimeObserver) MappingString2TimeFunc {
		return mapper
	})
}

func MapString2TimeObserveNext(parent StringObservable, mapper func(string) time.Time) TimeObservable {
	return MapString2TimeObservable(parent, func(TimeObserver) MappingString2TimeFunc {
		return func(next string, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingString2TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(NewStringObserverFunc(func(next string, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

// MapTime maps this stream to an TimeStream via f.
func (s *StringStream) MapTime(f func(string) time.Time) *TimeStream {
	return FromTimeObservable(MapString2TimeObserveNext(s, f))
}

type Float32Observer interface {
	Next(float32)
	TerminationObserver
}

// A Float32Subscriber represents a subscribed Float32Observer.
type Float32Subscriber interface {
	Subscription
	Float32Observer
}

type implFloat32Subscriber struct {
	Subscription
	Float32Observer
}

func Float32ObserverAsGenericObserver(observer Float32Observer) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(float32))
		}
	})
}

func GenericObserverAsFloat32Observer(observer GenericObserver) Float32Observer {
	return NewFloat32ObserverFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type Float32ObservableFactory func(observer Float32Observer, subscription Subscription)

func (f Float32ObservableFactory) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateFloat32 calls f(observer, subscription) to produce values for a stream.
func CreateFloat32(f func(observer Float32Observer, subscription Subscription)) *Float32Stream {
	return FromFloat32Observable(Float32ObservableFactory(f))
}

// Repeat value count times.
func RepeatFloat32(value float32, count int) *Float32Stream {
	return CreateFloat32(func(observer Float32Observer, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartFloat32 is designed to be used with functions that return a
// (float32, error) tuple.
//
// If the error is non-nil the returned Float32Stream will be that error,
// otherwise it will be a single-value stream of float32.
func StartFloat32(f func() (float32, error)) *Float32Stream {
	return CreateFloat32(func(observer Float32Observer, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughFloat32(next float32, err error, complete bool, observer Float32Observer) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

type Float32ObserverFunc func(float32, error, bool)

var zeroFloat32 = *new(float32)

func NewFloat32ObserverFunc(f func(float32, error, bool)) Float32ObserverFunc {
	return f
}

func (f Float32ObserverFunc) Next(next float32) { f(next, nil, false) }
func (f Float32ObserverFunc) Error(err error)   { f(zeroFloat32, err, false) }
func (f Float32ObserverFunc) Complete()         { f(zeroFloat32, nil, true) }

type Float32Observable interface {
	Subscribe(Float32Observer) Subscription
}

// Convert a GenericObservableFilter to a Float32Observable
func (f GenericObservableFilterFactory) Float32(parent Float32Observable) Float32Observable {
	return MapFloat322Float32Observable(parent, func(observer Float32Observer) MappingFloat322Float32Func {
		gobserver := Float32ObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next float32, err error, complete bool, observer Float32Observer) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverFloat32() *Float32Stream {
	return CreateFloat32(func(observer Float32Observer, subscription Subscription) {})
}

func EmptyFloat32() *Float32Stream {
	return CreateFloat32(func(observer Float32Observer, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowFloat32(err error) *Float32Stream {
	return CreateFloat32(func(observer Float32Observer, subscription Subscription) {
		observer.Error(err)
	})
}

func FromFloat32Array(array []float32) *Float32Stream {
	return CreateFloat32(func(observer Float32Observer, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromFloat32s(array ...float32) *Float32Stream {
	return FromFloat32Array(array)
}

func JustFloat32(element float32) *Float32Stream {
	return FromFloat32Array([]float32{element})
}

func MergeFloat32(observables ...Float32Observable) *Float32Stream {
	if len(observables) == 0 {
		return EmptyFloat32()
	}
	return (&Float32Stream{observables[0]}).Merge(observables[1:]...)
}

func MergeFloat32DelayError(observables ...Float32Observable) *Float32Stream {
	if len(observables) == 0 {
		return EmptyFloat32()
	}
	return (&Float32Stream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromFloat32Channel(ch <-chan float32) *Float32Stream {
	return CreateFloat32(func(observer Float32Observer, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type Float32Stream struct {
	Float32Observable
}

func FromFloat32Observable(observable Float32Observable) *Float32Stream {
	return &Float32Stream{observable}
}

func (s *Float32Stream) SubscribeFunc(f func(float32, error, bool)) Subscription {
	return s.Subscribe(NewFloat32ObserverFunc(f))
}

func (s *Float32Stream) SubscribeNext(f func(v float32)) Subscription {
	return s.SubscribeFunc(func(next float32, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *Float32Stream) Distinct() *Float32Stream {
	return FromFloat32Observable(distinctFilter().Float32(s))
}

// ElementAt yields the Nth element of the stream.
func (s *Float32Stream) ElementAt(n int) *Float32Stream {
	return FromFloat32Observable(elementAtFilter(n).Float32(s))
}

// Filter elements in the stream on a function.
func (s *Float32Stream) Filter(f func(float32) bool) *Float32Stream {
	return FromFloat32Observable(filterFilter(func(v interface{}) bool { return f(v.(float32)) }).Float32(s))
}

// Last returns just the first element of the stream.
func (s *Float32Stream) First() *Float32Stream {
	return FromFloat32Observable(firstFilter().Float32(s))
}

// Last returns just the last element of the stream.
func (s *Float32Stream) Last() *Float32Stream {
	return FromFloat32Observable(lastFilter().Float32(s))
}

// SkipLast skips the first N elements of the stream.
func (s *Float32Stream) Skip(n int) *Float32Stream {
	return FromFloat32Observable(skipFilter(n).Float32(s))
}

// SkipLast skips the last N elements of the stream.
func (s *Float32Stream) SkipLast(n int) *Float32Stream {
	return FromFloat32Observable(skipLastFilter(n).Float32(s))
}

// Take returns just the first N elements of the stream.
func (s *Float32Stream) Take(n int) *Float32Stream {
	return FromFloat32Observable(takeFilter(n).Float32(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *Float32Stream) TakeLast(n int) *Float32Stream {
	return FromFloat32Observable(takeLastFilter(n).Float32(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *Float32Stream) IgnoreElements() *Float32Stream {
	return FromFloat32Observable(ignoreElementsFilter().Float32(s))
}

func (s *Float32Stream) Replay(size int, duration time.Duration) *Float32Stream {
	return FromFloat32Observable(replayFilter(size, duration).Float32(s))
}

func (s *Float32Stream) Sample(duration time.Duration) *Float32Stream {
	return FromFloat32Observable(sampleFilter(duration).Float32(s))
}

func (s *Float32Stream) Debounce(duration time.Duration) *Float32Stream {
	return FromFloat32Observable(debounceFilter(duration).Float32(s))
}

// Wait for completion of the stream and return any error.
func (s *Float32Stream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeFloat32Subscriber(observer Float32Observer) Float32Subscriber {
	if subscriber, ok := observer.(Float32Subscriber); ok {
		return subscriber
	}
	return &implFloat32Subscriber{NewGenericSubscription(), observer}
}

type concatFloat32Subscriber struct {
	observable  int
	observer    Float32Observer
	observables []Float32Observable
	Subscription
}

func (c *concatFloat32Subscriber) Next(next float32) {
	c.observer.Next(next)
}

func (c *concatFloat32Subscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatFloat32Subscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatFloat32Observable struct {
	observables []Float32Observable
}

func (m *concatFloat32Observable) Subscribe(observer Float32Observer) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatFloat32Subscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *Float32Stream) Concat(observables ...Float32Observable) *Float32Stream {
	return &Float32Stream{&concatFloat32Observable{append([]Float32Observable{s}, observables...)}}
}

type mergeFloat32Observable struct {
	delayError  bool
	observables []Float32Observable
}

func (m *mergeFloat32Observable) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next float32, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(NewFloat32ObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *Float32Stream) Merge(other ...Float32Observable) *Float32Stream {
	if len(other) == 0 {
		return s
	}
	return &Float32Stream{&mergeFloat32Observable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *Float32Stream) MergeDelayError(other ...Float32Observable) *Float32Stream {
	if len(other) == 0 {
		return s
	}
	return &Float32Stream{&mergeFloat32Observable{true, append(other, s)}}
}

type catchFloat32Observable struct {
	parent Float32Observable
	catch  Float32Observable
}

func (r *catchFloat32Observable) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	run := func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(NewFloat32ObserverFunc(run))
	return subscription
}

func (s *Float32Stream) Catch(catch Float32Observable) *Float32Stream {
	return &Float32Stream{&catchFloat32Observable{s, catch}}
}

type retryFloat32Observable struct {
	observable Float32Observable
}

type retryFloat32Observer struct {
	observable Float32Observable
	observer   Float32Observer
}

func (r *retryFloat32Observer) retry(next float32, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(NewFloat32ObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryFloat32Observable) Subscribe(observer Float32Observer) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryFloat32Observer{r.observable, observer}
	r.observable.Subscribe(NewFloat32ObserverFunc(ro.retry))
	return subscription
}

func (s *Float32Stream) Retry() *Float32Stream {
	return &Float32Stream{&retryFloat32Observable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *Float32Stream) Do(f func(next float32)) *Float32Stream {
	return FromFloat32Observable(MapFloat322Float32ObserveNext(s, func(next float32) float32 {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *Float32Stream) DoOnError(f func(err error)) *Float32Stream {
	return FromFloat32Observable(MapFloat322Float32ObserveDirect(s, func(next float32, err error, complete bool, observer Float32Observer) {
		if err != nil {
			f(err)
		}
		PassthroughFloat32(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *Float32Stream) DoOnComplete(f func()) *Float32Stream {
	return FromFloat32Observable(MapFloat322Float32ObserveDirect(s, func(next float32, err error, complete bool, observer Float32Observer) {
		if complete {
			f()
		}
		PassthroughFloat32(next, err, complete, observer)
	}))
}

func (s *Float32Stream) Reduce(initial float32, reducer func(float32, float32) float32) *Float32Stream {
	value := initial
	return FromFloat32Observable(MapFloat322Float32ObserveDirect(s, func(next float32, err error, complete bool, observer Float32Observer) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *Float32Stream) Scan(initial float32, f func(float32, float32) float32) *Float32Stream {
	value := initial
	return FromFloat32Observable(MapFloat322Float32ObserveDirect(s, func(next float32, err error, complete bool, observer Float32Observer) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *Float32Stream) ToOneWithError() (float32, error) {
	valuech := make(chan float32, 1)
	errch := make(chan error, 1)
	FromFloat32Observable(oneFilter().Float32(s)).SubscribeFunc(func(next float32, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroFloat32, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *Float32Stream) ToOne() float32 {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *Float32Stream) ToArrayWithError() ([]float32, error) {
	array := []float32{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *Float32Stream) ToArray() []float32 {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *Float32Stream) ToChannelWithError() (<-chan float32, <-chan error) {
	ch := make(chan float32, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next float32, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *Float32Stream) ToChannel() <-chan float32 {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *Float32Stream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapFloat322IntObserveDirect(s, func(next float32, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

func (s *Float32Stream) Average() *Float32Stream {
	var sum float32
	var count float32
	return FromFloat32Observable(MapFloat322Float32ObserveDirect(s, func(next float32, err error, complete bool, observer Float32Observer) {
		switch {
		case err != nil:
			observer.Next(sum / count)
			observer.Error(err)
		case complete:
			observer.Next(sum / count)
			observer.Complete()
		default:
			sum += next
			count++
		}
	}))
}

func (s *Float32Stream) Sum() *Float32Stream {
	var sum float32
	return FromFloat32Observable(MapFloat322Float32ObserveDirect(s, func(next float32, err error, complete bool, observer Float32Observer) {
		switch {
		case err != nil:
			observer.Next(sum)
			observer.Error(err)
		case complete:
			observer.Next(sum)
			observer.Complete()
		default:
			sum += next
		}
	}))
}

func (s *Float32Stream) Min() *Float32Stream {
	started := false
	var min float32
	return FromFloat32Observable(MapFloat322Float32ObserveDirect(s, func(next float32, err error, complete bool, observer Float32Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(min)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(min)
			}
			observer.Complete()
		default:
			if started {
				if min > next {
					min = next
				}
			} else {
				min = next
				started = true
			}
		}
	}))
}

func (s *Float32Stream) Max() *Float32Stream {
	started := false
	var max float32
	return FromFloat32Observable(MapFloat322Float32ObserveDirect(s, func(next float32, err error, complete bool, observer Float32Observer) {
		switch {
		case err != nil:
			if started {
				observer.Next(max)
			}
			observer.Error(err)
		case complete:
			if started {
				observer.Next(max)
			}
			observer.Complete()
		default:
			if started {
				if max <= next {
					max = next
				}
			} else {
				max = next
				started = true
			}
		}
	}))
}

type MappingFloat322IntFunc func(next float32, err error, complete bool, observer IntObserver)
type MappingFloat322IntFuncFactory func(observer IntObserver) MappingFloat322IntFunc

type MappingFloat322IntObservable struct {
	parent Float32Observable
	mapper MappingFloat322IntFuncFactory
}

func MapFloat322IntObservable(parent Float32Observable, mapper MappingFloat322IntFuncFactory) IntObservable {
	return &MappingFloat322IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322IntObserveDirect(parent Float32Observable, mapper MappingFloat322IntFunc) IntObservable {
	return MapFloat322IntObservable(parent, func(IntObserver) MappingFloat322IntFunc {
		return mapper
	})
}

func MapFloat322IntObserveNext(parent Float32Observable, mapper func(float32) int) IntObservable {
	return MapFloat322IntObservable(parent, func(IntObserver) MappingFloat322IntFunc {
		return func(next float32, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingFloat322IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(NewFloat32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

// MapInt maps this stream to an IntStream via f.
func (s *Float32Stream) MapInt(f func(float32) int) *IntStream {
	return FromIntObservable(MapFloat322IntObserveNext(s, f))
}

type MappingFloat322StringFunc func(next float32, err error, complete bool, observer StringObserver)
type MappingFloat322StringFuncFactory func(observer StringObserver) MappingFloat322StringFunc

type MappingFloat322StringObservable struct {
	parent Float32Observable
	mapper MappingFloat322StringFuncFactory
}

func MapFloat322StringObservable(parent Float32Observable, mapper MappingFloat322StringFuncFactory) StringObservable {
	return &MappingFloat322StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322StringObserveDirect(parent Float32Observable, mapper MappingFloat322StringFunc) StringObservable {
	return MapFloat322StringObservable(parent, func(StringObserver) MappingFloat322StringFunc {
		return mapper
	})
}

func MapFloat322StringObserveNext(parent Float32Observable, mapper func(float32) string) StringObservable {
	return MapFloat322StringObservable(parent, func(StringObserver) MappingFloat322StringFunc {
		return func(next float32, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingFloat322StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(NewFloat32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

// MapString maps this stream to an StringStream via f.
func (s *Float32Stream) MapString(f func(float32) string) *StringStream {
	return FromStringObservable(MapFloat322StringObserveNext(s, f))
}

type MappingFloat322Float32Func func(next float32, err error, complete bool, observer Float32Observer)
type MappingFloat322Float32FuncFactory func(observer Float32Observer) MappingFloat322Float32Func

type MappingFloat322Float32Observable struct {
	parent Float32Observable
	mapper MappingFloat322Float32FuncFactory
}

func MapFloat322Float32Observable(parent Float32Observable, mapper MappingFloat322Float32FuncFactory) Float32Observable {
	return &MappingFloat322Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322Float32ObserveDirect(parent Float32Observable, mapper MappingFloat322Float32Func) Float32Observable {
	return MapFloat322Float32Observable(parent, func(Float32Observer) MappingFloat322Float32Func {
		return mapper
	})
}

func MapFloat322Float32ObserveNext(parent Float32Observable, mapper func(float32) float32) Float32Observable {
	return MapFloat322Float32Observable(parent, func(Float32Observer) MappingFloat322Float32Func {
		return func(next float32, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingFloat322Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(NewFloat32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

type MappingFloat322TimeFunc func(next float32, err error, complete bool, observer TimeObserver)
type MappingFloat322TimeFuncFactory func(observer TimeObserver) MappingFloat322TimeFunc

type MappingFloat322TimeObservable struct {
	parent Float32Observable
	mapper MappingFloat322TimeFuncFactory
}

func MapFloat322TimeObservable(parent Float32Observable, mapper MappingFloat322TimeFuncFactory) TimeObservable {
	return &MappingFloat322TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapFloat322TimeObserveDirect(parent Float32Observable, mapper MappingFloat322TimeFunc) TimeObservable {
	return MapFloat322TimeObservable(parent, func(TimeObserver) MappingFloat322TimeFunc {
		return mapper
	})
}

func MapFloat322TimeObserveNext(parent Float32Observable, mapper func(float32) time.Time) TimeObservable {
	return MapFloat322TimeObservable(parent, func(TimeObserver) MappingFloat322TimeFunc {
		return func(next float32, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingFloat322TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(NewFloat32ObserverFunc(func(next float32, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

// MapTime maps this stream to an TimeStream via f.
func (s *Float32Stream) MapTime(f func(float32) time.Time) *TimeStream {
	return FromTimeObservable(MapFloat322TimeObserveNext(s, f))
}

type TimeObserver interface {
	Next(time.Time)
	TerminationObserver
}

// A TimeSubscriber represents a subscribed TimeObserver.
type TimeSubscriber interface {
	Subscription
	TimeObserver
}

type implTimeSubscriber struct {
	Subscription
	TimeObserver
}

func TimeObserverAsGenericObserver(observer TimeObserver) GenericObserver {
	return NewGenericObserverFunc(func(next interface{}, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next.(time.Time))
		}
	})
}

func GenericObserverAsTimeObserver(observer GenericObserver) TimeObserver {
	return NewTimeObserverFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	})
}

type TimeObservableFactory func(observer TimeObserver, subscription Subscription)

func (f TimeObservableFactory) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	go f(observer, subscription)
	return subscription
}

// CreateTime calls f(observer, subscription) to produce values for a stream.
func CreateTime(f func(observer TimeObserver, subscription Subscription)) *TimeStream {
	return FromTimeObservable(TimeObservableFactory(f))
}

// Repeat value count times.
func RepeatTime(value time.Time, count int) *TimeStream {
	return CreateTime(func(observer TimeObserver, subscription Subscription) {
		for i := 0; i < count; i++ {
			if subscription.Closed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// StartTime is designed to be used with functions that return a
// (time.Time, error) tuple.
//
// If the error is non-nil the returned TimeStream will be that error,
// otherwise it will be a single-value stream of time.Time.
func StartTime(f func() (time.Time, error)) *TimeStream {
	return CreateTime(func(observer TimeObserver, subscription Subscription) {
		if v, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(v)
			observer.Complete()
		}
	})
}

func PassthroughTime(next time.Time, err error, complete bool, observer TimeObserver) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

type TimeObserverFunc func(time.Time, error, bool)

var zeroTime = *new(time.Time)

func NewTimeObserverFunc(f func(time.Time, error, bool)) TimeObserverFunc {
	return f
}

func (f TimeObserverFunc) Next(next time.Time) { f(next, nil, false) }
func (f TimeObserverFunc) Error(err error)     { f(zeroTime, err, false) }
func (f TimeObserverFunc) Complete()           { f(zeroTime, nil, true) }

type TimeObservable interface {
	Subscribe(TimeObserver) Subscription
}

// Convert a GenericObservableFilter to a TimeObservable
func (f GenericObservableFilterFactory) Time(parent TimeObservable) TimeObservable {
	return MapTime2TimeObservable(parent, func(observer TimeObserver) MappingTime2TimeFunc {
		gobserver := TimeObserverAsGenericObserver(observer)
		filter := f(gobserver)
		return func(next time.Time, err error, complete bool, observer TimeObserver) {
			filter(next, err, complete, gobserver)
		}
	},
	)
}

func NeverTime() *TimeStream {
	return CreateTime(func(observer TimeObserver, subscription Subscription) {})
}

func EmptyTime() *TimeStream {
	return CreateTime(func(observer TimeObserver, subscription Subscription) {
		observer.Complete()
	})
}

func ThrowTime(err error) *TimeStream {
	return CreateTime(func(observer TimeObserver, subscription Subscription) {
		observer.Error(err)
	})
}

func FromTimeArray(array []time.Time) *TimeStream {
	return CreateTime(func(observer TimeObserver, subscription Subscription) {
		for _, v := range array {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
		subscription.Close()
	})
}

func FromTimes(array ...time.Time) *TimeStream {
	return FromTimeArray(array)
}

func JustTime(element time.Time) *TimeStream {
	return FromTimeArray([]time.Time{element})
}

func MergeTime(observables ...TimeObservable) *TimeStream {
	if len(observables) == 0 {
		return EmptyTime()
	}
	return (&TimeStream{observables[0]}).Merge(observables[1:]...)
}

func MergeTimeDelayError(observables ...TimeObservable) *TimeStream {
	if len(observables) == 0 {
		return EmptyTime()
	}
	return (&TimeStream{observables[0]}).MergeDelayError(observables[1:]...)
}

func FromTimeChannel(ch <-chan time.Time) *TimeStream {
	return CreateTime(func(observer TimeObserver, subscription Subscription) {
		for v := range ch {
			if subscription.Closed() {
				return
			}
			observer.Next(v)
		}
		observer.Complete()
	})
}

type TimeStream struct {
	TimeObservable
}

func FromTimeObservable(observable TimeObservable) *TimeStream {
	return &TimeStream{observable}
}

func (s *TimeStream) SubscribeFunc(f func(time.Time, error, bool)) Subscription {
	return s.Subscribe(NewTimeObserverFunc(f))
}

func (s *TimeStream) SubscribeNext(f func(v time.Time)) Subscription {
	return s.SubscribeFunc(func(next time.Time, err error, complete bool) {
		if err == nil && !complete {
			f(next)
		}
	})
}

// Distinct removes duplicate elements in the stream.
func (s *TimeStream) Distinct() *TimeStream {
	return FromTimeObservable(distinctFilter().Time(s))
}

// ElementAt yields the Nth element of the stream.
func (s *TimeStream) ElementAt(n int) *TimeStream {
	return FromTimeObservable(elementAtFilter(n).Time(s))
}

// Filter elements in the stream on a function.
func (s *TimeStream) Filter(f func(time.Time) bool) *TimeStream {
	return FromTimeObservable(filterFilter(func(v interface{}) bool { return f(v.(time.Time)) }).Time(s))
}

// Last returns just the first element of the stream.
func (s *TimeStream) First() *TimeStream {
	return FromTimeObservable(firstFilter().Time(s))
}

// Last returns just the last element of the stream.
func (s *TimeStream) Last() *TimeStream {
	return FromTimeObservable(lastFilter().Time(s))
}

// SkipLast skips the first N elements of the stream.
func (s *TimeStream) Skip(n int) *TimeStream {
	return FromTimeObservable(skipFilter(n).Time(s))
}

// SkipLast skips the last N elements of the stream.
func (s *TimeStream) SkipLast(n int) *TimeStream {
	return FromTimeObservable(skipLastFilter(n).Time(s))
}

// Take returns just the first N elements of the stream.
func (s *TimeStream) Take(n int) *TimeStream {
	return FromTimeObservable(takeFilter(n).Time(s))
}

// TakeLast returns just the last N elements of the stream.
func (s *TimeStream) TakeLast(n int) *TimeStream {
	return FromTimeObservable(takeLastFilter(n).Time(s))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (s *TimeStream) IgnoreElements() *TimeStream {
	return FromTimeObservable(ignoreElementsFilter().Time(s))
}

func (s *TimeStream) Replay(size int, duration time.Duration) *TimeStream {
	return FromTimeObservable(replayFilter(size, duration).Time(s))
}

func (s *TimeStream) Sample(duration time.Duration) *TimeStream {
	return FromTimeObservable(sampleFilter(duration).Time(s))
}

func (s *TimeStream) Debounce(duration time.Duration) *TimeStream {
	return FromTimeObservable(debounceFilter(duration).Time(s))
}

// Wait for completion of the stream and return any error.
func (s *TimeStream) Wait() error {
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			errch <- nil
		default:
		}
	})
	return <-errch
}

func MakeTimeSubscriber(observer TimeObserver) TimeSubscriber {
	if subscriber, ok := observer.(TimeSubscriber); ok {
		return subscriber
	}
	return &implTimeSubscriber{NewGenericSubscription(), observer}
}

type concatTimeSubscriber struct {
	observable  int
	observer    TimeObserver
	observables []TimeObservable
	Subscription
}

func (c *concatTimeSubscriber) Next(next time.Time) {
	c.observer.Next(next)
}

func (c *concatTimeSubscriber) Error(err error) {
	c.observer.Error(err)
	c.observable = len(c.observables)
	c.Close()
}

func (c *concatTimeSubscriber) Complete() {
	c.observable++
	if c.observable >= len(c.observables) {
		c.observer.Complete()
		c.Close()
		return
	}
	c.observables[c.observable].Subscribe(c)
}

type concatTimeObservable struct {
	observables []TimeObservable
}

func (m *concatTimeObservable) Subscribe(observer TimeObserver) Subscription {
	if len(m.observables) == 0 {
		observer.Complete()
		return ClosedSubscription
	}
	subscriber := &concatTimeSubscriber{
		observer:     observer,
		Subscription: NewGenericSubscription(),
		observables:  m.observables,
	}
	m.observables[0].Subscribe(subscriber)
	return subscriber
}

func (s *TimeStream) Concat(observables ...TimeObservable) *TimeStream {
	return &TimeStream{&concatTimeObservable{append([]TimeObservable{s}, observables...)}}
}

type mergeTimeObservable struct {
	delayError  bool
	observables []TimeObservable
}

func (m *mergeTimeObservable) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	lock := sync.Mutex{}
	completed := 0
	var firstError error
	relay := func(next time.Time, err error, complete bool) {
		lock.Lock()
		defer lock.Unlock()
		if completed >= len(m.observables) {
			return
		}

		switch {
		case err != nil:
			if m.delayError {
				firstError = err
				completed++
			} else {
				observer.Error(err)
				completed = len(m.observables)
			}

		case complete:
			completed++
			if completed == len(m.observables) {
				if firstError != nil {
					observer.Error(firstError)
				} else {
					observer.Complete()
				}
			}
		default:
			observer.Next(next)
		}
	}
	for _, observable := range m.observables {
		observable.Subscribe(NewTimeObserverFunc(relay))
	}
	return subscription
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (s *TimeStream) Merge(other ...TimeObservable) *TimeStream {
	if len(other) == 0 {
		return s
	}
	return &TimeStream{&mergeTimeObservable{false, append(other, s)}}
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (s *TimeStream) MergeDelayError(other ...TimeObservable) *TimeStream {
	if len(other) == 0 {
		return s
	}
	return &TimeStream{&mergeTimeObservable{true, append(other, s)}}
}

type catchTimeObservable struct {
	parent TimeObservable
	catch  TimeObservable
}

func (r *catchTimeObservable) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	run := func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			r.catch.Subscribe(observer)
		case complete:
			observer.Complete()
		default:
			observer.Next(next)
		}
	}
	r.parent.Subscribe(NewTimeObserverFunc(run))
	return subscription
}

func (s *TimeStream) Catch(catch TimeObservable) *TimeStream {
	return &TimeStream{&catchTimeObservable{s, catch}}
}

type retryTimeObservable struct {
	observable TimeObservable
}

type retryTimeObserver struct {
	observable TimeObservable
	observer   TimeObserver
}

func (r *retryTimeObserver) retry(next time.Time, err error, complete bool) {
	switch {
	case err != nil:
		r.observable.Subscribe(NewTimeObserverFunc(r.retry))
	case complete:
		r.observer.Complete()
	default:
		r.observer.Next(next)
	}
}

func (r *retryTimeObservable) Subscribe(observer TimeObserver) Subscription {
	subscription := NewGenericSubscription()
	ro := &retryTimeObserver{r.observable, observer}
	r.observable.Subscribe(NewTimeObserverFunc(ro.retry))
	return subscription
}

func (s *TimeStream) Retry() *TimeStream {
	return &TimeStream{&retryTimeObservable{s}}
}

// Do applies a function for each value passing through the stream.
func (s *TimeStream) Do(f func(next time.Time)) *TimeStream {
	return FromTimeObservable(MapTime2TimeObserveNext(s, func(next time.Time) time.Time {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *TimeStream) DoOnError(f func(err error)) *TimeStream {
	return FromTimeObservable(MapTime2TimeObserveDirect(s, func(next time.Time, err error, complete bool, observer TimeObserver) {
		if err != nil {
			f(err)
		}
		PassthroughTime(next, err, complete, observer)
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *TimeStream) DoOnComplete(f func()) *TimeStream {
	return FromTimeObservable(MapTime2TimeObserveDirect(s, func(next time.Time, err error, complete bool, observer TimeObserver) {
		if complete {
			f()
		}
		PassthroughTime(next, err, complete, observer)
	}))
}

func (s *TimeStream) Reduce(initial time.Time, reducer func(time.Time, time.Time) time.Time) *TimeStream {
	value := initial
	return FromTimeObservable(MapTime2TimeObserveDirect(s, func(next time.Time, err error, complete bool, observer TimeObserver) {
		switch {
		case err != nil:
			observer.Next(value)
			observer.Error(err)
		case complete:
			observer.Next(value)
			observer.Complete()
		default:
			value = reducer(value, next)
		}
	}))
}

func (s *TimeStream) Scan(initial time.Time, f func(time.Time, time.Time) time.Time) *TimeStream {
	value := initial
	return FromTimeObservable(MapTime2TimeObserveDirect(s, func(next time.Time, err error, complete bool, observer TimeObserver) {
		switch {
		case err != nil:
			observer.Error(err)
		case complete:
			observer.Complete()
		default:
			value = f(value, next)
			observer.Next(value)
		}
	}))
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *TimeStream) ToOneWithError() (time.Time, error) {
	valuech := make(chan time.Time, 1)
	errch := make(chan error, 1)
	FromTimeObservable(oneFilter().Time(s)).SubscribeFunc(func(next time.Time, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zeroTime, err
	}
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (s *TimeStream) ToOne() time.Time {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (s *TimeStream) ToArrayWithError() ([]time.Time, error) {
	array := []time.Time{}
	completech := make(chan bool, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

// ToArray blocks and returns the values from the stream in an array.
func (s *TimeStream) ToArray() []time.Time {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *TimeStream) ToChannelWithError() (<-chan time.Time, <-chan error) {
	ch := make(chan time.Time, 1)
	errch := make(chan error, 1)
	s.SubscribeFunc(func(next time.Time, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			close(errch)
			close(ch)
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *TimeStream) ToChannel() <-chan time.Time {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *TimeStream) Count() *IntStream {
	count := 0
	return FromIntObservable(MapTime2IntObserveDirect(s, func(next time.Time, err error, complete bool, observer IntObserver) {
		switch {
		case err != nil:
			observer.Next(count)
			observer.Error(err)
		case complete:
			observer.Next(count)
			observer.Complete()
		default:
			count++
		}
	}))
}

type MappingTime2IntFunc func(next time.Time, err error, complete bool, observer IntObserver)
type MappingTime2IntFuncFactory func(observer IntObserver) MappingTime2IntFunc

type MappingTime2IntObservable struct {
	parent TimeObservable
	mapper MappingTime2IntFuncFactory
}

func MapTime2IntObservable(parent TimeObservable, mapper MappingTime2IntFuncFactory) IntObservable {
	return &MappingTime2IntObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2IntObserveDirect(parent TimeObservable, mapper MappingTime2IntFunc) IntObservable {
	return MapTime2IntObservable(parent, func(IntObserver) MappingTime2IntFunc {
		return mapper
	})
}

func MapTime2IntObserveNext(parent TimeObservable, mapper func(time.Time) int) IntObservable {
	return MapTime2IntObservable(parent, func(IntObserver) MappingTime2IntFunc {
		return func(next time.Time, err error, complete bool, observer IntObserver) {
			var mapped int
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughInt(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingTime2IntObservable) Subscribe(observer IntObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(NewTimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

// MapInt maps this stream to an IntStream via f.
func (s *TimeStream) MapInt(f func(time.Time) int) *IntStream {
	return FromIntObservable(MapTime2IntObserveNext(s, f))
}

type MappingTime2StringFunc func(next time.Time, err error, complete bool, observer StringObserver)
type MappingTime2StringFuncFactory func(observer StringObserver) MappingTime2StringFunc

type MappingTime2StringObservable struct {
	parent TimeObservable
	mapper MappingTime2StringFuncFactory
}

func MapTime2StringObservable(parent TimeObservable, mapper MappingTime2StringFuncFactory) StringObservable {
	return &MappingTime2StringObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2StringObserveDirect(parent TimeObservable, mapper MappingTime2StringFunc) StringObservable {
	return MapTime2StringObservable(parent, func(StringObserver) MappingTime2StringFunc {
		return mapper
	})
}

func MapTime2StringObserveNext(parent TimeObservable, mapper func(time.Time) string) StringObservable {
	return MapTime2StringObservable(parent, func(StringObserver) MappingTime2StringFunc {
		return func(next time.Time, err error, complete bool, observer StringObserver) {
			var mapped string
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughString(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingTime2StringObservable) Subscribe(observer StringObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(NewTimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

// MapString maps this stream to an StringStream via f.
func (s *TimeStream) MapString(f func(time.Time) string) *StringStream {
	return FromStringObservable(MapTime2StringObserveNext(s, f))
}

type MappingTime2Float32Func func(next time.Time, err error, complete bool, observer Float32Observer)
type MappingTime2Float32FuncFactory func(observer Float32Observer) MappingTime2Float32Func

type MappingTime2Float32Observable struct {
	parent TimeObservable
	mapper MappingTime2Float32FuncFactory
}

func MapTime2Float32Observable(parent TimeObservable, mapper MappingTime2Float32FuncFactory) Float32Observable {
	return &MappingTime2Float32Observable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2Float32ObserveDirect(parent TimeObservable, mapper MappingTime2Float32Func) Float32Observable {
	return MapTime2Float32Observable(parent, func(Float32Observer) MappingTime2Float32Func {
		return mapper
	})
}

func MapTime2Float32ObserveNext(parent TimeObservable, mapper func(time.Time) float32) Float32Observable {
	return MapTime2Float32Observable(parent, func(Float32Observer) MappingTime2Float32Func {
		return func(next time.Time, err error, complete bool, observer Float32Observer) {
			var mapped float32
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughFloat32(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingTime2Float32Observable) Subscribe(observer Float32Observer) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(NewTimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}

// MapFloat32 maps this stream to an Float32Stream via f.
func (s *TimeStream) MapFloat32(f func(time.Time) float32) *Float32Stream {
	return FromFloat32Observable(MapTime2Float32ObserveNext(s, f))
}

type MappingTime2TimeFunc func(next time.Time, err error, complete bool, observer TimeObserver)
type MappingTime2TimeFuncFactory func(observer TimeObserver) MappingTime2TimeFunc

type MappingTime2TimeObservable struct {
	parent TimeObservable
	mapper MappingTime2TimeFuncFactory
}

func MapTime2TimeObservable(parent TimeObservable, mapper MappingTime2TimeFuncFactory) TimeObservable {
	return &MappingTime2TimeObservable{
		parent: parent,
		mapper: mapper,
	}
}

func MapTime2TimeObserveDirect(parent TimeObservable, mapper MappingTime2TimeFunc) TimeObservable {
	return MapTime2TimeObservable(parent, func(TimeObserver) MappingTime2TimeFunc {
		return mapper
	})
}

func MapTime2TimeObserveNext(parent TimeObservable, mapper func(time.Time) time.Time) TimeObservable {
	return MapTime2TimeObservable(parent, func(TimeObserver) MappingTime2TimeFunc {
		return func(next time.Time, err error, complete bool, observer TimeObserver) {
			var mapped time.Time
			if err == nil && !complete {
				mapped = mapper(next)
			}
			PassthroughTime(mapped, err, complete, observer)
		}
	},
	)
}

func (f *MappingTime2TimeObservable) Subscribe(observer TimeObserver) Subscription {
	mapper := f.mapper(observer)
	return f.parent.Subscribe(NewTimeObserverFunc(func(next time.Time, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}
