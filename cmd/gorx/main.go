package main

import (
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/alecthomas/template"
	"gopkg.in/alecthomas/kingpin.v2"
)

var (
	packageArg  = kingpin.Arg("package", "Go package.").Required().String()
	typesArg    = kingpin.Arg("types", "List of types to provide Reactive types for.").Strings()
	importsFlag = kingpin.Flag("import", "Extra imports.").Strings()
	outputFlag  = kingpin.Flag("output", "File to write to.").Short('o').String()
	debugFlag   = kingpin.Flag("debug", "Debug mode.").Bool()
)

var mapExtractRe = regexp.MustCompile(`map\[([^\]]+)\](.*)`)

var reactTemplate = `package {{.Package}}

// NOTE: This file was generated by github.com/alecthomas/cmd/gorx. Do not modify.

import (
	"errors"
	"sync/atomic"
{{range .Imports}}
	"{{.}}"
{{end}}\
)

type Subscription interface {
	// Unsubscribe from the subscription.
	Unsubscribe()
	// Unsubscribed returns true if this subscription has been unsubscribed.
	Unsubscribed() bool
}

type GenericSubscription int32

func (t *GenericSubscription) Unsubscribe() {
	atomic.StoreInt32((*int32)(t), 1)
}

func (t *GenericSubscription) Unsubscribed() bool {
	return atomic.LoadInt32((*int32)(t)) == 1
}

type PartialObserver interface {
	Error(error)
	Complete()
}

type GenericObserver interface {
	PartialObserver
	Next(interface{})
}

type GenericObserverFunc func(interface{}, error, bool)

func (f GenericObserverFunc) Next(next interface{}) { f(next, nil, false) }
func (f GenericObserverFunc) Error(err error)       { f(nil, err, false) }
func (f GenericObserverFunc) Complete()             { f(nil, nil, true) }

type GenericObservableFilter func(next interface{}, err error, complete bool, observer GenericObserver)

// Turtles all the way down!
type GenericObservableFilterFactory func() GenericObservableFilter

func distinctFilter() GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		seen := map[interface{}]struct{}{}
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if _, ok := seen[next]; ok {
					return
				}
				seen[next] = struct{}{}
				observer.Next(next)
			}
		}
	}
}

func elementAtFilter(n int) GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		i := 0
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if i == n {
					observer.Next(next)
				}
				i++
			}
		}
	}
}

func filterFilter(f func(next interface{}) bool) GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if f(next) {
					observer.Next(next)
				}
			}
		}
	}
}

func firstFilter() GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		start := true
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if start {
					observer.Next(next)
				}
				start = false
			}
		}
	}
}

func lastFilter() GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		have := false
		var last interface{}
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				if have {
					observer.Next(last)
				}
				observer.Error(err)
			case complete:
				if have {
					observer.Next(last)
				}
				observer.Complete()
			default:
				last = next
				have = true
			}
		}
	}
}

func skipFilter(n int) GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		i := 0
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				if i >= n {
					observer.Next(next)
				}
				i++
			}
		}
	}
}

func skipLastFilter(n int) GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		read := 0
		write := 0
		buffer := make([]interface{}, n+1)
		n++
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				observer.Complete()
			default:
				buffer[write] = next
				write = (write + 1) % n
				if write == read {
					observer.Next(buffer[read])
					read = (read + 1) % n
				}
			}
		}
	}
}

func oneFilter() GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		count := 0
		var value interface{}
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			switch {
			case err != nil:
				observer.Error(err)
			case complete:
				if count != 1 {
					observer.Error(errors.New("expected one value"))
				} else {
					observer.Next(value)
					observer.Complete()
				}
			default:
				count++
				if count == 2 {
					observer.Error(errors.New("expected one value"))
					return
				}
				value = next
			}
		}
	}
}

func raiseFilter(err error) GenericObservableFilterFactory {
	return func() GenericObservableFilter {
		return func(next interface{}, err error, complete bool, observer GenericObserver) {
			observer.Error(err)
		}
	}
}

{{range $type := .Types}}
{{with $name := .|TypeName}}
type {{$name}}Observer interface {
	Next({{$type}})
	PartialObserver
}

func Passthrough{{$name}}(next {{$type}}, err error, complete bool, observer {{$name}}Observer) {
	switch {
	case err != nil:
		observer.Error(err)
	case complete:
		observer.Complete()
	default:
		observer.Next(next)
	}
}

type {{$name}}ObserverFunc func({{$type}}, error, bool)

var zero{{$name}} = *new({{$type}})

func (f {{$name}}ObserverFunc) Next(next {{$type}}) { f(next, nil, false) }
func (f {{$name}}ObserverFunc) Error(err error)  { f(zero{{$name}}, err, false) }
func (f {{$name}}ObserverFunc) Complete()        { f(zero{{$name}}, nil, true) }

type {{$name}}Observable interface {
	Subscribe({{$name}}Observer) Subscription
}

// Convert a GenericObservableFilter to a {{$name}}Observable
func (f GenericObservableFilterFactory) {{$name}}(parent {{$name}}Observable) {{$name}}Observable {
	return Map{{$name}}{{$name}}Observable(parent, func() Mapping{{$name}}{{$name}}Func {
		// Initialise the adapter.
		filter := f()
		return func(next {{$type}}, err error, complete bool, observer {{$name}}Observer) {
			filter(next, err, complete, GenericObserverFunc(func(next interface{}, err error, complete bool) {
				switch {
				case err != nil:
					observer.Error(err)
				case complete:
					observer.Complete()
				default:
					observer.Next(next.({{$type}}))
				}
			}))
		}
	})
}

type Observable{{$name}}Complete struct {}

func (o *Observable{{$name}}Complete) Subscribe(observer {{$name}}Observer) Subscription {
	subscription := new(GenericSubscription)
	go func() {
		observer.Complete()
		subscription.Unsubscribe()
	}()
	return subscription
}

func From{{$name}}Complete() *{{$name}}Stream {
	return From{{$name}}Observable(&Observable{{$name}}Complete{})
}

type Observable{{$name}}Error struct {
	Err error
}

func (o *Observable{{$name}}Error) Error() string {
	return o.Err.Error()
}

func (o *Observable{{$name}}Error) Subscribe(observer {{$name}}Observer) Subscription {
	subscription := new(GenericSubscription)
	go func() {
		observer.Error(o)
		subscription.Unsubscribe()
	}()
	return subscription
}

func From{{$name}}Error(err error) *{{$name}}Stream {
	return From{{$name}}Observable(&Observable{{$name}}Error{ err })
}

type Observable{{$name}}Array []{{$type}}

func (o Observable{{$name}}Array) Subscribe(observer {{$name}}Observer) Subscription {
	subscription := new(GenericSubscription)
	go func() {
		for _, v := range o {
			observer.Next(v)
			if subscription.Unsubscribed() {
				break
			}
		}
		observer.Complete()
		subscription.Unsubscribe()
	}()
	return subscription
}

func From{{$name}}Array(array []{{$type}}) *{{$name}}Stream {
	return From{{$name}}Observable(Observable{{$name}}Array(array))
}

type Observable{{$name}}Channel <-chan {{$type}}

func (o Observable{{$name}}Channel) Subscribe(observer {{$name}}Observer) Subscription {
	subscription := new(GenericSubscription)
	go func() {
		for v := range o {
			observer.Next(v)
			if subscription.Unsubscribed() {
				break
			}
		}
		observer.Complete()
		subscription.Unsubscribe()
	}()
	return subscription
}


func From{{$name}}Channel(ch <-chan {{$type}}) *{{$name}}Stream {
	return From{{$name}}Observable(Observable{{$name}}Channel(ch))
}

type {{$name}}Stream struct {
	{{$name}}Observable
}

func From{{$name}}Observable(observable {{$name}}Observable) *{{$name}}Stream {
	return &{{$name}}Stream{observable}
}

func (s *{{$name}}Stream) SubscribeFunc(f {{$name}}ObserverFunc) Subscription {
	return s.Subscribe(f)
}

// Distinct removes duplicate elements in the stream.
func (s *{{$name}}Stream) Distinct() *{{$name}}Stream {
	return From{{$name}}Observable(distinctFilter().{{$name}}(s))
}

// ElementAt yields the Nth element of the stream.
func (s *{{$name}}Stream) ElementAt(n int) *{{$name}}Stream {
	return From{{$name}}Observable(elementAtFilter(n).{{$name}}(s))
}

// Filter elements in the stream on a function.
func (s *{{$name}}Stream) Filter(f func({{$type}}) bool) *{{$name}}Stream {
	return From{{$name}}Observable(filterFilter(func(v interface{}) bool { return f(v.({{$type}})) }).{{$name}}(s))
}

// Last returns just the first element of the stream.
func (s *{{$name}}Stream) First() *{{$name}}Stream {
	return From{{$name}}Observable(firstFilter().{{$name}}(s))
}

// Last returns just the last element of the stream.
func (s *{{$name}}Stream) Last() *{{$name}}Stream {
	return From{{$name}}Observable(lastFilter().{{$name}}(s))
}

// SkipLast skips the first N elements of the stream.
func (s *{{$name}}Stream) Skip(n int) *{{$name}}Stream {
	return From{{$name}}Observable(skipFilter(n).{{$name}}(s))
}

// SkipLast skips the last N elements of the stream.
func (s *{{$name}}Stream) SkipLast(n int) *{{$name}}Stream {
	return From{{$name}}Observable(skipLastFilter(n).{{$name}}(s))
}

// Do applies a function for each value passing through the stream.
func (s *{{$name}}Stream) Do(f func(next {{$type}})) *{{$name}}Stream {
	return From{{$name}}Observable(Map{{$name}}{{$name}}ObserveNext(s, func(next {{$type}}) {{$type}} {
		f(next)
		return next
	}))
}

// DoOnError applies a function for any error on the stream.
func (s *{{$name}}Stream) DoOnError(f func(err error)) *{{$name}}Stream {
	return From{{$name}}Observable(Map{{$name}}{{$name}}Observable(s, func() Mapping{{$name}}{{$name}}Func {
		return func(next {{$type}}, err error, complete bool, observer {{$name}}Observer) {
			if err != nil {
				f(err)
			}
			Passthrough{{$name}}(next, err, complete, observer)
		}
	}))
}

// DoOnComplete applies a function when the stream completes.
func (s *{{$name}}Stream) DoOnComplete(f func()) *{{$name}}Stream {
	return From{{$name}}Observable(Map{{$name}}{{$name}}Observable(s, func() Mapping{{$name}}{{$name}}Func {
		return func(next {{$type}}, err error, complete bool, observer {{$name}}Observer) {
			if complete {
				f()
			}
			Passthrough{{$name}}(next, err, complete, observer)
		}
	}))
}

func (s *{{$name}}Stream) Reduce(initial {{$type}}, reducer func ({{$type}}, {{$type}}) {{$type}}) *{{$name}}Stream {
	return From{{$name}}Observable(Map{{$name}}{{$name}}Observable(s, func() Mapping{{$name}}{{$name}}Func {
		value := initial
		return func(next {{$type}}, err error, complete bool, observer {{$name}}Observer) {
			switch {
			case err != nil:
				observer.Next(value)
				observer.Error(err)
			case complete:
				observer.Next(value)
				observer.Complete()
			default:
				value = reducer(value, next)
			}
		}
	}))
}

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (s *{{$name}}Stream) ToOneWithError() ({{$type}}, error) {
	valuech := make(chan {{$type}})
	errch := make(chan error)
	From{{$name}}Observable(oneFilter().{{$name}}(s)).SubscribeFunc(func (next {{$type}}, err error, complete bool) {
		if err != nil {
			errch <- err
		} else if !complete {
			valuech <- next
		}
	})
	select {
	case value := <-valuech:
		return value, nil
	case err := <-errch:
		return zero{{$name}}, err
	}
}

func (s *{{$name}}Stream) ToOne() {{$type}} {
	value, _ := s.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array, returning it and any error.
func (s *{{$name}}Stream) ToArrayWithError() ([]{{$type}}, error) {
	array := []{{$type}}{}
	completech := make(chan bool)
	errch := make(chan error)
	s.SubscribeFunc(func(next {{$type}}, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
			completech <- true
		case complete:
			completech <- true
		default:
			array = append(array, next)
		}
	})
	select {
	case <-completech:
		return array, nil
	case err := <-errch:
		return array, err
	}
}

func (s *{{$name}}Stream) ToArray() []{{$type}} {
	out, _ := s.ToArrayWithError()
	return out
}

// ToChannelWithError returns value and error channels corresponding to the stream elements and any error.
func (s *{{$name}}Stream) ToChannelWithError() (<-chan {{$type}}, <-chan error) {
	ch := make(chan {{$type}})
	errch := make(chan error)
	s.SubscribeFunc(func(next {{$type}}, err error, complete bool) {
		switch {
		case err != nil:
			errch <- err
		case complete:
			close(ch)
		default:
			ch <- next
		}
	})
	return ch, errch
}

func (s *{{$name}}Stream) ToChannel() <-chan {{$type}} {
	ch, _ := s.ToChannelWithError()
	return ch
}

// Count returns an IntStream with the count of elements in this stream.
func (s *{{$name}}Stream) Count() *IntStream {
	return FromIntObservable(Map{{$name}}IntObservable(s, func() Mapping{{$name}}IntFunc {
		count := 0
		return func(next {{$type}}, err error, complete bool, observer IntObserver) {
			switch {
			case err != nil:
				observer.Next(count)
				observer.Error(err)
			case complete:
				observer.Next(count)
				observer.Complete()
			default:
				count++
			}
		}
	}))
}

{{if $type|IsNumeric}}\
func (s *{{$name}}Stream) Average() *{{$name}}Stream {
	return From{{$name}}Observable(Map{{$name}}{{$name}}Observable(s, func() Mapping{{$name}}{{$name}}Func {
		var sum {{$type}}
		var count {{$type}}
		return func(next {{$type}}, err error, complete bool, observer {{$name}}Observer) {
			switch {
			case err != nil:
				observer.Next(sum / count)
				observer.Error(err)
			case complete:
				observer.Next(sum / count)
				observer.Complete()
			default:
				sum += next
				count++
			}
		}
	}))
}

func (s *{{$name}}Stream) Sum() *{{$name}}Stream {
	return From{{$name}}Observable(Map{{$name}}{{$name}}Observable(s, func() Mapping{{$name}}{{$name}}Func {
		var sum {{$type}}
		return func(next {{$type}}, err error, complete bool, observer {{$name}}Observer) {
			switch {
			case err != nil:
				observer.Next(sum)
				observer.Error(err)
			case complete:
				observer.Next(sum)
				observer.Complete()
			default:
				sum += next
			}
		}
	}))
}

func (s *{{$name}}Stream) Min() *{{$name}}Stream {
	return From{{$name}}Observable(Map{{$name}}{{$name}}Observable(s, func() Mapping{{$name}}{{$name}}Func {
		started := false
		var min {{$type}}
		return func(next {{$type}}, err error, complete bool, observer {{$name}}Observer) {
			switch {
			case err != nil:
				if started {
					observer.Next(min)
				}
				observer.Error(err)
			case complete:
				if started {
					observer.Next(min)
				}
				observer.Complete()
			default:
				if started {
					if min > next {
						min = next
					}
				} else {
					min = next
					started = true
				}
			}
		}
	}))
}

func (s *{{$name}}Stream) Max() *{{$name}}Stream {
	return From{{$name}}Observable(Map{{$name}}{{$name}}Observable(s, func() Mapping{{$name}}{{$name}}Func {
		started := false
		var max {{$type}}
		return func(next {{$type}}, err error, complete bool, observer {{$name}}Observer) {
			switch {
			case err != nil:
				if started {
					observer.Next(max)
				}
				observer.Error(err)
			case complete:
				if started {
					observer.Next(max)
				}
				observer.Complete()
			default:
				if started {
					if max <= next {
						max = next
					}
				} else {
					max = next
					started = true
				}
			}
		}
	}))
}
{{end}}\

{{range $other := $.Types}}\
{{with $otherName := .|TypeName}}\
{{with $mapName := printf "%s%s" $name $otherName}}
type Mapping{{$mapName}}Func func(next {{$type}}, err error, complete bool, observer {{$otherName}}Observer)
type Mapping{{$mapName}}FuncFactory func() Mapping{{$mapName}}Func

type Mapping{{$mapName}}Observable struct {
	parent  {{$name}}Observable
	factory Mapping{{$mapName}}FuncFactory
}

func Map{{$mapName}}Observable(parent {{$name}}Observable, factory Mapping{{$mapName}}FuncFactory) {{$otherName}}Observable {
	return &Mapping{{$mapName}}Observable{
		parent:  parent,
		factory: factory,
	}
}

func Map{{$mapName}}ObserveNext(parent {{$name}}Observable, mapper func({{$type}}) {{$other}}) {{$otherName}}Observable {
	return Map{{$mapName}}Observable(parent, func() Mapping{{$mapName}}Func {
		return func(next {{$type}}, err error, complete bool, observer {{$otherName}}Observer) {
			var mapped {{$other}}
			if err == nil && !complete {
				mapped = mapper(next)
			}
			Passthrough{{$otherName}}(mapped, err, complete, observer)
		}
	},
	)
}

func (f *Mapping{{$mapName}}Observable) Subscribe(observer {{$otherName}}Observer) Subscription {
	mapper := f.factory()
	return f.parent.Subscribe({{$name}}ObserverFunc(func(next {{$type}}, err error, complete bool) {
		mapper(next, err, complete, observer)
	}))
}
{{end}}

{{if ne $type $other}}\
// Map{{$otherName}} maps this stream to an {{$otherName}}Stream via f.
func (s *{{$name}}Stream) Map{{$otherName}}(f func ({{$type}}) {{$other}}) *{{$otherName}}Stream {
	return From{{$otherName}}Observable(Map{{$name}}{{$otherName}}ObserveNext(s, f))
}
{{end}}\
{{end}}\
{{end}}
{{end}}\
{{end}}\
`

type Context struct {
	Package string
	Types   []string
	Imports []string
}

func main() {
	kingpin.Parse()
	t := template.Must(template.New("react").Funcs(template.FuncMap{
		"TypeName": func(s string) string {
			if strings.HasPrefix(s, "[]") {
				return strings.Title(s[2:]) + "Array"
			}
			match := mapExtractRe.FindAllStringSubmatch(s, -1)
			if len(match) > 0 {
				return strings.Title(match[0][1]) + strings.Title(match[0][2]) + "Map"
			}
			parts := strings.SplitN(s, ".", -1)
			return strings.Title(parts[len(parts)-1])
		},
		"IsNumeric": func(v string) bool {
			switch v {
			case "byte", "uint", "int", "uint8", "int8", "uint16", "int16", "uint32",
				"int32", "uint64", "int64", "float32", "float64":
				return true
			}
			return false
		},
	}).Parse(reactTemplate))
	// We always include int. As an aside, this kind of verbosity is my
	// biggest peeve with Go. 10 lines compared to basically any other
	// language:
	//
	// 		if *typesArg.Contains("int") { ... }
	//
	// Super annoying.
	found := false
	for _, s := range *typesArg {
		if s == "int" {
			found = true
			break
		}
	}
	if !found {
		*typesArg = append(*typesArg, "int")
	}
	cmd := exec.Command("goimports")
	if *debugFlag {
		cmd = exec.Command("cat")
	}
	outputFile := os.Stdout
	if *outputFlag != "" {
		dir := filepath.Dir(*outputFlag)
		var err error
		outputFile, err = ioutil.TempFile(dir, ".gorx-")
		kingpin.FatalIfError(err, "")
		defer os.Remove(outputFile.Name())
	}
	cmd.Stdout = outputFile
	stdin, err := cmd.StdinPipe()
	kingpin.FatalIfError(err, "")
	kingpin.FatalIfError(cmd.Start(), "")
	err = t.Execute(stdin, &Context{
		Package: *packageArg,
		Types:   *typesArg,
		Imports: *importsFlag,
	})
	kingpin.FatalIfError(err, "")
	stdin.Close()
	kingpin.FatalIfError(cmd.Wait(), "")
	outputFile.Close()
	if *outputFlag != "" {
		kingpin.FatalIfError(os.Rename(outputFile.Name(), *outputFlag), "")
	}
}
